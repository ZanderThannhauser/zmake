#include "zebu.h"

#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

#include <limits.h>
#include <stdarg.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <assert.h>
#include <stdio.h>
#include <errno.h>

const unsigned zebu_shifts[617][36] = {
	[1][2] = 2,
	[1][3] = 3,
	[1][4] = 4,
	[1][5] = 5,
	[1][6] = 6,
	[1][7] = 7,
	[1][8] = 8,
	[1][9] = 9,
	[2][2] = 18,
	[2][3] = 19,
	[2][10] = 20,
	[2][11] = 21,
	[2][12] = 22,
	[2][13] = 23,
	[2][14] = 24,
	[5][16] = 33,
	[5][17] = 34,
	[6][2] = 2,
	[6][3] = 3,
	[6][4] = 4,
	[6][5] = 5,
	[6][6] = 6,
	[6][7] = 7,
	[6][8] = 8,
	[6][9] = 9,
	[7][2] = 36,
	[7][3] = 37,
	[7][10] = 38,
	[7][11] = 39,
	[7][12] = 40,
	[7][13] = 41,
	[7][14] = 42,
	[8][11] = 51,
	[9][2] = 52,
	[9][3] = 53,
	[9][4] = 54,
	[10][15] = 56,
	[17][2] = 2,
	[17][3] = 3,
	[17][4] = 4,
	[17][5] = 5,
	[17][7] = 7,
	[17][8] = 8,
	[17][9] = 9,
	[18][2] = 18,
	[18][3] = 19,
	[18][10] = 20,
	[18][11] = 21,
	[18][12] = 22,
	[18][13] = 23,
	[18][14] = 24,
	[20][2] = 60,
	[20][3] = 61,
	[20][10] = 62,
	[20][11] = 64,
	[20][12] = 65,
	[20][13] = 66,
	[20][14] = 67,
	[20][28] = 63,
	[23][2] = 18,
	[23][3] = 19,
	[23][10] = 20,
	[23][11] = 21,
	[23][12] = 22,
	[23][13] = 23,
	[23][14] = 24,
	[24][2] = 18,
	[24][3] = 19,
	[24][10] = 20,
	[24][11] = 21,
	[24][12] = 22,
	[24][13] = 23,
	[24][14] = 24,
	[25][13] = 79,
	[25][14] = 80,
	[26][26] = 81,
	[26][27] = 82,
	[27][19] = 83,
	[28][22] = 84,
	[28][23] = 85,
	[32][20] = 86,
	[32][21] = 87,
	[32][24] = 88,
	[32][25] = 89,
	[33][2] = 90,
	[33][3] = 91,
	[33][10] = 92,
	[33][11] = 93,
	[33][12] = 94,
	[33][13] = 95,
	[33][14] = 96,
	[34][2] = 90,
	[34][3] = 91,
	[34][10] = 92,
	[34][11] = 93,
	[34][12] = 94,
	[34][13] = 95,
	[34][14] = 96,
	[36][2] = 18,
	[36][3] = 19,
	[36][10] = 20,
	[36][11] = 21,
	[36][12] = 22,
	[36][13] = 23,
	[36][14] = 24,
	[38][2] = 60,
	[38][3] = 61,
	[38][10] = 62,
	[38][11] = 64,
	[38][12] = 65,
	[38][13] = 66,
	[38][14] = 67,
	[38][28] = 108,
	[41][2] = 36,
	[41][3] = 37,
	[41][10] = 38,
	[41][11] = 39,
	[41][12] = 40,
	[41][13] = 41,
	[41][14] = 42,
	[42][2] = 36,
	[42][3] = 37,
	[42][10] = 38,
	[42][11] = 39,
	[42][12] = 40,
	[42][13] = 41,
	[42][14] = 42,
	[43][13] = 113,
	[43][14] = 114,
	[44][26] = 115,
	[44][27] = 116,
	[45][15] = 117,
	[46][22] = 118,
	[46][23] = 119,
	[50][20] = 120,
	[50][21] = 121,
	[50][24] = 122,
	[50][25] = 123,
	[51][29] = 124,
	[52][2] = 18,
	[52][3] = 19,
	[52][10] = 20,
	[52][11] = 21,
	[52][12] = 22,
	[52][13] = 23,
	[52][14] = 24,
	[55][6] = 126,
	[56][2] = 127,
	[56][3] = 128,
	[56][4] = 129,
	[56][6] = 131,
	[56][30] = 130,
	[58][2] = 2,
	[58][3] = 3,
	[58][4] = 4,
	[58][5] = 5,
	[58][7] = 7,
	[58][8] = 8,
	[58][9] = 9,
	[59][19] = 137,
	[60][2] = 18,
	[60][3] = 19,
	[60][10] = 20,
	[60][11] = 21,
	[60][12] = 22,
	[60][13] = 23,
	[60][14] = 24,
	[62][2] = 60,
	[62][3] = 61,
	[62][10] = 62,
	[62][11] = 64,
	[62][12] = 65,
	[62][13] = 66,
	[62][14] = 67,
	[62][28] = 139,
	[66][2] = 60,
	[66][3] = 61,
	[66][10] = 62,
	[66][11] = 64,
	[66][12] = 65,
	[66][13] = 66,
	[66][14] = 67,
	[67][2] = 60,
	[67][3] = 61,
	[67][10] = 62,
	[67][11] = 64,
	[67][12] = 65,
	[67][13] = 66,
	[67][14] = 67,
	[68][13] = 144,
	[68][14] = 145,
	[69][26] = 146,
	[69][27] = 147,
	[70][28] = 149,
	[70][31] = 148,
	[71][22] = 151,
	[71][23] = 152,
	[75][20] = 153,
	[75][21] = 154,
	[75][24] = 155,
	[75][25] = 156,
	[79][2] = 18,
	[79][3] = 19,
	[79][10] = 20,
	[79][11] = 21,
	[79][12] = 22,
	[79][13] = 23,
	[79][14] = 24,
	[80][2] = 18,
	[80][3] = 19,
	[80][10] = 20,
	[80][11] = 21,
	[80][12] = 22,
	[80][13] = 23,
	[80][14] = 24,
	[81][2] = 18,
	[81][3] = 19,
	[81][10] = 20,
	[81][11] = 21,
	[81][12] = 22,
	[81][13] = 23,
	[81][14] = 24,
	[82][2] = 18,
	[82][3] = 19,
	[82][10] = 20,
	[82][11] = 21,
	[82][12] = 22,
	[82][13] = 23,
	[82][14] = 24,
	[84][2] = 18,
	[84][3] = 19,
	[84][10] = 20,
	[84][11] = 21,
	[84][12] = 22,
	[84][13] = 23,
	[84][14] = 24,
	[85][2] = 18,
	[85][3] = 19,
	[85][10] = 20,
	[85][11] = 21,
	[85][12] = 22,
	[85][13] = 23,
	[85][14] = 24,
	[86][2] = 18,
	[86][3] = 19,
	[86][10] = 20,
	[86][11] = 21,
	[86][12] = 22,
	[86][13] = 23,
	[86][14] = 24,
	[87][2] = 18,
	[87][3] = 19,
	[87][10] = 20,
	[87][11] = 21,
	[87][12] = 22,
	[87][13] = 23,
	[87][14] = 24,
	[88][2] = 18,
	[88][3] = 19,
	[88][10] = 20,
	[88][11] = 21,
	[88][12] = 22,
	[88][13] = 23,
	[88][14] = 24,
	[89][2] = 18,
	[89][3] = 19,
	[89][10] = 20,
	[89][11] = 21,
	[89][12] = 22,
	[89][13] = 23,
	[89][14] = 24,
	[90][2] = 18,
	[90][3] = 19,
	[90][10] = 20,
	[90][11] = 21,
	[90][12] = 22,
	[90][13] = 23,
	[90][14] = 24,
	[92][2] = 60,
	[92][3] = 61,
	[92][10] = 62,
	[92][11] = 64,
	[92][12] = 65,
	[92][13] = 66,
	[92][14] = 67,
	[92][28] = 172,
	[95][2] = 90,
	[95][3] = 91,
	[95][10] = 92,
	[95][11] = 93,
	[95][12] = 94,
	[95][13] = 95,
	[95][14] = 96,
	[96][2] = 90,
	[96][3] = 91,
	[96][10] = 92,
	[96][11] = 93,
	[96][12] = 94,
	[96][13] = 95,
	[96][14] = 96,
	[98][13] = 177,
	[98][14] = 178,
	[99][26] = 179,
	[99][27] = 180,
	[100][6] = 181,
	[101][22] = 182,
	[101][23] = 183,
	[105][20] = 184,
	[105][21] = 185,
	[105][24] = 186,
	[105][25] = 187,
	[107][19] = 188,
	[109][28] = 190,
	[109][31] = 189,
	[113][2] = 36,
	[113][3] = 37,
	[113][10] = 38,
	[113][11] = 39,
	[113][12] = 40,
	[113][13] = 41,
	[113][14] = 42,
	[114][2] = 36,
	[114][3] = 37,
	[114][10] = 38,
	[114][11] = 39,
	[114][12] = 40,
	[114][13] = 41,
	[114][14] = 42,
	[115][2] = 36,
	[115][3] = 37,
	[115][10] = 38,
	[115][11] = 39,
	[115][12] = 40,
	[115][13] = 41,
	[115][14] = 42,
	[116][2] = 36,
	[116][3] = 37,
	[116][10] = 38,
	[116][11] = 39,
	[116][12] = 40,
	[116][13] = 41,
	[116][14] = 42,
	[117][2] = 2,
	[117][3] = 3,
	[117][4] = 4,
	[117][5] = 198,
	[117][7] = 199,
	[117][8] = 200,
	[117][9] = 201,
	[118][2] = 36,
	[118][3] = 37,
	[118][10] = 38,
	[118][11] = 39,
	[118][12] = 40,
	[118][13] = 41,
	[118][14] = 42,
	[119][2] = 36,
	[119][3] = 37,
	[119][10] = 38,
	[119][11] = 39,
	[119][12] = 40,
	[119][13] = 41,
	[119][14] = 42,
	[120][2] = 36,
	[120][3] = 37,
	[120][10] = 38,
	[120][11] = 39,
	[120][12] = 40,
	[120][13] = 41,
	[120][14] = 42,
	[121][2] = 36,
	[121][3] = 37,
	[121][10] = 38,
	[121][11] = 39,
	[121][12] = 40,
	[121][13] = 41,
	[121][14] = 42,
	[122][2] = 36,
	[122][3] = 37,
	[122][10] = 38,
	[122][11] = 39,
	[122][12] = 40,
	[122][13] = 41,
	[122][14] = 42,
	[123][2] = 36,
	[123][3] = 37,
	[123][10] = 38,
	[123][11] = 39,
	[123][12] = 40,
	[123][13] = 41,
	[123][14] = 42,
	[124][2] = 36,
	[124][3] = 37,
	[124][10] = 38,
	[124][11] = 39,
	[124][12] = 40,
	[124][13] = 41,
	[124][14] = 42,
	[125][19] = 218,
	[126][6] = 219,
	[127][2] = 18,
	[127][3] = 19,
	[127][10] = 20,
	[127][11] = 21,
	[127][12] = 22,
	[127][13] = 23,
	[127][14] = 24,
	[130][2] = 222,
	[130][3] = 223,
	[130][4] = 224,
	[131][6] = 227,
	[131][30] = 130,
	[133][2] = 127,
	[133][3] = 128,
	[133][4] = 129,
	[133][6] = 131,
	[133][30] = 130,
	[134][30] = 130,
	[135][6] = 232,
	[138][19] = 234,
	[140][28] = 236,
	[140][31] = 235,
	[144][2] = 60,
	[144][3] = 61,
	[144][10] = 62,
	[144][11] = 64,
	[144][12] = 65,
	[144][13] = 66,
	[144][14] = 67,
	[145][2] = 60,
	[145][3] = 61,
	[145][10] = 62,
	[145][11] = 64,
	[145][12] = 65,
	[145][13] = 66,
	[145][14] = 67,
	[146][2] = 60,
	[146][3] = 61,
	[146][10] = 62,
	[146][11] = 64,
	[146][12] = 65,
	[146][13] = 66,
	[146][14] = 67,
	[147][2] = 60,
	[147][3] = 61,
	[147][10] = 62,
	[147][11] = 64,
	[147][12] = 65,
	[147][13] = 66,
	[147][14] = 67,
	[148][2] = 60,
	[148][3] = 61,
	[148][10] = 62,
	[148][11] = 64,
	[148][12] = 65,
	[148][13] = 66,
	[148][14] = 67,
	[151][2] = 60,
	[151][3] = 61,
	[151][10] = 62,
	[151][11] = 64,
	[151][12] = 65,
	[151][13] = 66,
	[151][14] = 67,
	[152][2] = 60,
	[152][3] = 61,
	[152][10] = 62,
	[152][11] = 64,
	[152][12] = 65,
	[152][13] = 66,
	[152][14] = 67,
	[153][2] = 60,
	[153][3] = 61,
	[153][10] = 62,
	[153][11] = 64,
	[153][12] = 65,
	[153][13] = 66,
	[153][14] = 67,
	[154][2] = 60,
	[154][3] = 61,
	[154][10] = 62,
	[154][11] = 64,
	[154][12] = 65,
	[154][13] = 66,
	[154][14] = 67,
	[155][2] = 60,
	[155][3] = 61,
	[155][10] = 62,
	[155][11] = 64,
	[155][12] = 65,
	[155][13] = 66,
	[155][14] = 67,
	[156][2] = 60,
	[156][3] = 61,
	[156][10] = 62,
	[156][11] = 64,
	[156][12] = 65,
	[156][13] = 66,
	[156][14] = 67,
	[158][22] = 84,
	[158][23] = 85,
	[161][20] = 86,
	[161][21] = 87,
	[161][24] = 88,
	[161][25] = 89,
	[167][13] = 79,
	[167][14] = 80,
	[171][19] = 253,
	[173][28] = 255,
	[173][31] = 254,
	[177][2] = 90,
	[177][3] = 91,
	[177][10] = 92,
	[177][11] = 93,
	[177][12] = 94,
	[177][13] = 95,
	[177][14] = 96,
	[178][2] = 90,
	[178][3] = 91,
	[178][10] = 92,
	[178][11] = 93,
	[178][12] = 94,
	[178][13] = 95,
	[178][14] = 96,
	[179][2] = 90,
	[179][3] = 91,
	[179][10] = 92,
	[179][11] = 93,
	[179][12] = 94,
	[179][13] = 95,
	[179][14] = 96,
	[180][2] = 90,
	[180][3] = 91,
	[180][10] = 92,
	[180][11] = 93,
	[180][12] = 94,
	[180][13] = 95,
	[180][14] = 96,
	[181][6] = 263,
	[182][2] = 90,
	[182][3] = 91,
	[182][10] = 92,
	[182][11] = 93,
	[182][12] = 94,
	[182][13] = 95,
	[182][14] = 96,
	[183][2] = 90,
	[183][3] = 91,
	[183][10] = 92,
	[183][11] = 93,
	[183][12] = 94,
	[183][13] = 95,
	[183][14] = 96,
	[184][2] = 90,
	[184][3] = 91,
	[184][10] = 92,
	[184][11] = 93,
	[184][12] = 94,
	[184][13] = 95,
	[184][14] = 96,
	[185][2] = 90,
	[185][3] = 91,
	[185][10] = 92,
	[185][11] = 93,
	[185][12] = 94,
	[185][13] = 95,
	[185][14] = 96,
	[186][2] = 90,
	[186][3] = 91,
	[186][10] = 92,
	[186][11] = 93,
	[186][12] = 94,
	[186][13] = 95,
	[186][14] = 96,
	[187][2] = 90,
	[187][3] = 91,
	[187][10] = 92,
	[187][11] = 93,
	[187][12] = 94,
	[187][13] = 95,
	[187][14] = 96,
	[189][2] = 60,
	[189][3] = 61,
	[189][10] = 62,
	[189][11] = 64,
	[189][12] = 65,
	[189][13] = 66,
	[189][14] = 67,
	[193][22] = 118,
	[193][23] = 119,
	[196][20] = 120,
	[196][21] = 121,
	[196][24] = 122,
	[196][25] = 123,
	[198][16] = 274,
	[198][17] = 275,
	[199][2] = 36,
	[199][3] = 37,
	[199][10] = 38,
	[199][11] = 39,
	[199][12] = 40,
	[199][13] = 41,
	[199][14] = 42,
	[200][11] = 277,
	[201][2] = 52,
	[201][3] = 53,
	[201][4] = 54,
	[202][15] = 279,
	[208][2] = 2,
	[208][3] = 3,
	[208][4] = 4,
	[208][5] = 198,
	[208][7] = 199,
	[208][8] = 200,
	[208][9] = 201,
	[208][32] = 280,
	[208][33] = 281,
	[213][13] = 113,
	[213][14] = 114,
	[217][15] = 284,
	[219][6] = 219,
	[221][19] = 286,
	[222][2] = 18,
	[222][3] = 19,
	[222][10] = 20,
	[222][11] = 21,
	[222][12] = 22,
	[222][13] = 23,
	[222][14] = 24,
	[225][2] = 222,
	[225][3] = 223,
	[225][4] = 224,
	[226][6] = 293,
	[226][20] = 290,
	[226][21] = 292,
	[226][34] = 291,
	[227][6] = 232,
	[228][6] = 232,
	[231][30] = 130,
	[232][6] = 232,
	[235][2] = 60,
	[235][3] = 61,
	[235][10] = 62,
	[235][11] = 64,
	[235][12] = 65,
	[235][13] = 66,
	[235][14] = 67,
	[239][22] = 151,
	[239][23] = 152,
	[242][20] = 153,
	[242][21] = 154,
	[242][24] = 155,
	[242][25] = 156,
	[244][28] = 149,
	[244][31] = 148,
	[249][13] = 144,
	[249][14] = 145,
	[254][2] = 60,
	[254][3] = 61,
	[254][10] = 62,
	[254][11] = 64,
	[254][12] = 65,
	[254][13] = 66,
	[254][14] = 67,
	[258][22] = 182,
	[258][23] = 183,
	[261][20] = 184,
	[261][21] = 185,
	[261][24] = 186,
	[261][25] = 187,
	[263][6] = 263,
	[269][13] = 177,
	[269][14] = 178,
	[273][28] = 190,
	[273][31] = 189,
	[274][2] = 90,
	[274][3] = 91,
	[274][10] = 92,
	[274][11] = 93,
	[274][12] = 94,
	[274][13] = 95,
	[274][14] = 96,
	[275][2] = 90,
	[275][3] = 91,
	[275][10] = 92,
	[275][11] = 93,
	[275][12] = 94,
	[275][13] = 95,
	[275][14] = 96,
	[276][15] = 306,
	[277][29] = 307,
	[278][6] = 308,
	[279][2] = 127,
	[279][3] = 128,
	[279][4] = 129,
	[279][6] = 310,
	[279][30] = 309,
	[280][2] = 2,
	[280][3] = 3,
	[280][4] = 4,
	[280][5] = 315,
	[280][7] = 316,
	[280][8] = 317,
	[280][9] = 318,
	[281][6] = 326,
	[283][2] = 2,
	[283][3] = 3,
	[283][4] = 4,
	[283][5] = 198,
	[283][7] = 199,
	[283][8] = 200,
	[283][9] = 201,
	[283][32] = 280,
	[283][33] = 281,
	[284][6] = 329,
	[287][19] = 330,
	[289][2] = 222,
	[289][3] = 223,
	[289][4] = 224,
	[290][2] = 332,
	[290][3] = 333,
	[290][4] = 334,
	[291][2] = 336,
	[291][3] = 337,
	[291][4] = 338,
	[292][2] = 52,
	[292][3] = 53,
	[292][4] = 54,
	[298][28] = 236,
	[298][31] = 235,
	[300][28] = 255,
	[300][31] = 254,
	[304][6] = 346,
	[306][2] = 2,
	[306][3] = 3,
	[306][4] = 4,
	[306][5] = 198,
	[306][7] = 199,
	[306][8] = 200,
	[306][9] = 201,
	[307][2] = 36,
	[307][3] = 37,
	[307][10] = 38,
	[307][11] = 39,
	[307][12] = 40,
	[307][13] = 41,
	[307][14] = 42,
	[308][6] = 349,
	[309][2] = 222,
	[309][3] = 223,
	[309][4] = 224,
	[310][6] = 352,
	[310][30] = 309,
	[312][2] = 127,
	[312][3] = 128,
	[312][4] = 129,
	[312][6] = 310,
	[312][30] = 309,
	[313][30] = 309,
	[314][6] = 357,
	[315][16] = 359,
	[315][17] = 360,
	[316][2] = 36,
	[316][3] = 37,
	[316][10] = 38,
	[316][11] = 39,
	[316][12] = 40,
	[316][13] = 41,
	[316][14] = 42,
	[317][11] = 362,
	[318][2] = 52,
	[318][3] = 53,
	[318][4] = 54,
	[319][15] = 364,
	[325][2] = 2,
	[325][3] = 3,
	[325][4] = 4,
	[325][5] = 315,
	[325][7] = 316,
	[325][8] = 317,
	[325][9] = 318,
	[325][33] = 365,
	[326][6] = 368,
	[329][2] = 2,
	[329][3] = 3,
	[329][4] = 4,
	[329][5] = 370,
	[329][7] = 371,
	[329][8] = 372,
	[329][9] = 373,
	[332][2] = 18,
	[332][3] = 19,
	[332][10] = 20,
	[332][11] = 21,
	[332][12] = 22,
	[332][13] = 23,
	[332][14] = 24,
	[335][6] = 384,
	[335][21] = 383,
	[335][34] = 382,
	[336][2] = 18,
	[336][3] = 19,
	[336][10] = 20,
	[336][11] = 21,
	[336][12] = 22,
	[336][13] = 23,
	[336][14] = 24,
	[340][2] = 336,
	[340][3] = 337,
	[340][4] = 338,
	[341][6] = 384,
	[341][21] = 383,
	[341][34] = 382,
	[343][6] = 390,
	[346][6] = 391,
	[347][2] = 2,
	[347][3] = 3,
	[347][4] = 4,
	[347][5] = 198,
	[347][7] = 199,
	[347][8] = 200,
	[347][9] = 201,
	[347][32] = 393,
	[347][33] = 394,
	[348][15] = 397,
	[349][6] = 349,
	[351][6] = 402,
	[351][20] = 399,
	[351][21] = 401,
	[351][34] = 400,
	[352][6] = 357,
	[353][6] = 357,
	[356][30] = 309,
	[357][6] = 357,
	[359][2] = 90,
	[359][3] = 91,
	[359][10] = 92,
	[359][11] = 93,
	[359][12] = 94,
	[359][13] = 95,
	[359][14] = 96,
	[360][2] = 90,
	[360][3] = 91,
	[360][10] = 92,
	[360][11] = 93,
	[360][12] = 94,
	[360][13] = 95,
	[360][14] = 96,
	[361][15] = 410,
	[362][29] = 411,
	[363][6] = 412,
	[364][2] = 127,
	[364][3] = 128,
	[364][4] = 129,
	[364][6] = 414,
	[364][30] = 413,
	[365][6] = 326,
	[367][2] = 2,
	[367][3] = 3,
	[367][4] = 4,
	[367][5] = 315,
	[367][7] = 316,
	[367][8] = 317,
	[367][9] = 318,
	[367][33] = 365,
	[368][6] = 368,
	[370][16] = 422,
	[370][17] = 423,
	[371][2] = 36,
	[371][3] = 37,
	[371][10] = 38,
	[371][11] = 39,
	[371][12] = 40,
	[371][13] = 41,
	[371][14] = 42,
	[372][11] = 425,
	[373][2] = 52,
	[373][3] = 53,
	[373][4] = 54,
	[374][15] = 427,
	[380][2] = 2,
	[380][3] = 3,
	[380][4] = 4,
	[380][5] = 370,
	[380][7] = 371,
	[380][8] = 372,
	[380][9] = 373,
	[380][35] = 428,
	[381][19] = 431,
	[382][2] = 336,
	[382][3] = 337,
	[382][4] = 338,
	[383][2] = 52,
	[383][3] = 53,
	[383][4] = 54,
	[386][19] = 434,
	[388][2] = 336,
	[388][3] = 337,
	[388][4] = 338,
	[391][6] = 391,
	[393][2] = 2,
	[393][3] = 3,
	[393][4] = 4,
	[393][5] = 315,
	[393][7] = 316,
	[393][8] = 317,
	[393][9] = 318,
	[394][6] = 438,
	[396][2] = 2,
	[396][3] = 3,
	[396][4] = 4,
	[396][5] = 198,
	[396][7] = 199,
	[396][8] = 200,
	[396][9] = 201,
	[396][32] = 393,
	[396][33] = 394,
	[397][6] = 441,
	[399][2] = 332,
	[399][3] = 333,
	[399][4] = 334,
	[400][2] = 336,
	[400][3] = 337,
	[400][4] = 338,
	[401][2] = 52,
	[401][3] = 53,
	[401][4] = 54,
	[408][6] = 447,
	[410][2] = 2,
	[410][3] = 3,
	[410][4] = 4,
	[410][5] = 198,
	[410][7] = 199,
	[410][8] = 200,
	[410][9] = 201,
	[411][2] = 36,
	[411][3] = 37,
	[411][10] = 38,
	[411][11] = 39,
	[411][12] = 40,
	[411][13] = 41,
	[411][14] = 42,
	[412][6] = 450,
	[413][2] = 222,
	[413][3] = 223,
	[413][4] = 224,
	[414][6] = 453,
	[414][30] = 413,
	[416][2] = 127,
	[416][3] = 128,
	[416][4] = 129,
	[416][6] = 414,
	[416][30] = 413,
	[417][30] = 413,
	[418][6] = 458,
	[422][2] = 90,
	[422][3] = 91,
	[422][10] = 92,
	[422][11] = 93,
	[422][12] = 94,
	[422][13] = 95,
	[422][14] = 96,
	[423][2] = 90,
	[423][3] = 91,
	[423][10] = 92,
	[423][11] = 93,
	[423][12] = 94,
	[423][13] = 95,
	[423][14] = 96,
	[424][15] = 463,
	[425][29] = 464,
	[426][6] = 465,
	[427][2] = 127,
	[427][3] = 128,
	[427][4] = 129,
	[427][6] = 467,
	[427][30] = 466,
	[428][6] = 472,
	[430][2] = 2,
	[430][3] = 3,
	[430][4] = 4,
	[430][5] = 370,
	[430][7] = 371,
	[430][8] = 372,
	[430][9] = 373,
	[430][35] = 428,
	[437][2] = 2,
	[437][3] = 3,
	[437][4] = 4,
	[437][5] = 315,
	[437][7] = 316,
	[437][8] = 317,
	[437][9] = 318,
	[437][33] = 474,
	[438][6] = 477,
	[441][2] = 2,
	[441][3] = 3,
	[441][4] = 4,
	[441][5] = 370,
	[441][7] = 371,
	[441][8] = 372,
	[441][9] = 373,
	[442][6] = 482,
	[442][21] = 481,
	[442][34] = 480,
	[444][6] = 482,
	[444][21] = 481,
	[444][34] = 480,
	[446][6] = 485,
	[447][6] = 486,
	[448][2] = 2,
	[448][3] = 3,
	[448][4] = 4,
	[448][5] = 198,
	[448][7] = 199,
	[448][8] = 200,
	[448][9] = 201,
	[448][32] = 488,
	[448][33] = 489,
	[449][15] = 492,
	[450][6] = 450,
	[452][6] = 497,
	[452][20] = 494,
	[452][21] = 496,
	[452][34] = 495,
	[453][6] = 458,
	[454][6] = 458,
	[457][30] = 413,
	[458][6] = 458,
	[461][6] = 502,
	[463][2] = 2,
	[463][3] = 3,
	[463][4] = 4,
	[463][5] = 198,
	[463][7] = 199,
	[463][8] = 200,
	[463][9] = 201,
	[464][2] = 36,
	[464][3] = 37,
	[464][10] = 38,
	[464][11] = 39,
	[464][12] = 40,
	[464][13] = 41,
	[464][14] = 42,
	[465][6] = 505,
	[466][2] = 222,
	[466][3] = 223,
	[466][4] = 224,
	[467][6] = 508,
	[467][30] = 466,
	[469][2] = 127,
	[469][3] = 128,
	[469][4] = 129,
	[469][6] = 467,
	[469][30] = 466,
	[470][30] = 466,
	[471][6] = 513,
	[472][6] = 515,
	[474][6] = 438,
	[476][2] = 2,
	[476][3] = 3,
	[476][4] = 4,
	[476][5] = 315,
	[476][7] = 316,
	[476][8] = 317,
	[476][9] = 318,
	[476][33] = 474,
	[477][6] = 477,
	[479][2] = 2,
	[479][3] = 3,
	[479][4] = 4,
	[479][5] = 370,
	[479][7] = 371,
	[479][8] = 372,
	[479][9] = 373,
	[479][35] = 520,
	[480][2] = 336,
	[480][3] = 337,
	[480][4] = 338,
	[481][2] = 52,
	[481][3] = 53,
	[481][4] = 54,
	[486][6] = 486,
	[488][2] = 2,
	[488][3] = 3,
	[488][4] = 4,
	[488][5] = 315,
	[488][7] = 316,
	[488][8] = 317,
	[488][9] = 318,
	[489][6] = 527,
	[491][2] = 2,
	[491][3] = 3,
	[491][4] = 4,
	[491][5] = 198,
	[491][7] = 199,
	[491][8] = 200,
	[491][9] = 201,
	[491][32] = 488,
	[491][33] = 489,
	[492][6] = 530,
	[494][2] = 332,
	[494][3] = 333,
	[494][4] = 334,
	[495][2] = 336,
	[495][3] = 337,
	[495][4] = 338,
	[496][2] = 52,
	[496][3] = 53,
	[496][4] = 54,
	[502][6] = 536,
	[503][2] = 2,
	[503][3] = 3,
	[503][4] = 4,
	[503][5] = 198,
	[503][7] = 199,
	[503][8] = 200,
	[503][9] = 201,
	[503][32] = 538,
	[503][33] = 539,
	[504][15] = 542,
	[505][6] = 505,
	[507][6] = 547,
	[507][20] = 544,
	[507][21] = 546,
	[507][34] = 545,
	[508][6] = 513,
	[509][6] = 513,
	[512][30] = 466,
	[513][6] = 513,
	[515][6] = 515,
	[520][6] = 553,
	[522][2] = 2,
	[522][3] = 3,
	[522][4] = 4,
	[522][5] = 370,
	[522][7] = 371,
	[522][8] = 372,
	[522][9] = 373,
	[522][35] = 520,
	[526][2] = 2,
	[526][3] = 3,
	[526][4] = 4,
	[526][5] = 315,
	[526][7] = 316,
	[526][8] = 317,
	[526][9] = 318,
	[526][33] = 555,
	[527][6] = 558,
	[530][2] = 2,
	[530][3] = 3,
	[530][4] = 4,
	[530][5] = 370,
	[530][7] = 371,
	[530][8] = 372,
	[530][9] = 373,
	[531][6] = 563,
	[531][21] = 562,
	[531][34] = 561,
	[533][6] = 563,
	[533][21] = 562,
	[533][34] = 561,
	[535][6] = 566,
	[536][6] = 536,
	[538][2] = 2,
	[538][3] = 3,
	[538][4] = 4,
	[538][5] = 315,
	[538][7] = 316,
	[538][8] = 317,
	[538][9] = 318,
	[539][6] = 569,
	[541][2] = 2,
	[541][3] = 3,
	[541][4] = 4,
	[541][5] = 198,
	[541][7] = 199,
	[541][8] = 200,
	[541][9] = 201,
	[541][32] = 538,
	[541][33] = 539,
	[542][6] = 572,
	[544][2] = 332,
	[544][3] = 333,
	[544][4] = 334,
	[545][2] = 336,
	[545][3] = 337,
	[545][4] = 338,
	[546][2] = 52,
	[546][3] = 53,
	[546][4] = 54,
	[553][6] = 578,
	[555][6] = 527,
	[557][2] = 2,
	[557][3] = 3,
	[557][4] = 4,
	[557][5] = 315,
	[557][7] = 316,
	[557][8] = 317,
	[557][9] = 318,
	[557][33] = 555,
	[558][6] = 558,
	[560][2] = 2,
	[560][3] = 3,
	[560][4] = 4,
	[560][5] = 370,
	[560][7] = 371,
	[560][8] = 372,
	[560][9] = 373,
	[560][35] = 583,
	[561][2] = 336,
	[561][3] = 337,
	[561][4] = 338,
	[562][2] = 52,
	[562][3] = 53,
	[562][4] = 54,
	[568][2] = 2,
	[568][3] = 3,
	[568][4] = 4,
	[568][5] = 315,
	[568][7] = 316,
	[568][8] = 317,
	[568][9] = 318,
	[568][33] = 588,
	[569][6] = 591,
	[572][2] = 2,
	[572][3] = 3,
	[572][4] = 4,
	[572][5] = 370,
	[572][7] = 371,
	[572][8] = 372,
	[572][9] = 373,
	[573][6] = 596,
	[573][21] = 595,
	[573][34] = 594,
	[575][6] = 596,
	[575][21] = 595,
	[575][34] = 594,
	[577][6] = 599,
	[578][6] = 578,
	[583][6] = 601,
	[585][2] = 2,
	[585][3] = 3,
	[585][4] = 4,
	[585][5] = 370,
	[585][7] = 371,
	[585][8] = 372,
	[585][9] = 373,
	[585][35] = 583,
	[588][6] = 569,
	[590][2] = 2,
	[590][3] = 3,
	[590][4] = 4,
	[590][5] = 315,
	[590][7] = 316,
	[590][8] = 317,
	[590][9] = 318,
	[590][33] = 588,
	[591][6] = 591,
	[593][2] = 2,
	[593][3] = 3,
	[593][4] = 4,
	[593][5] = 370,
	[593][7] = 371,
	[593][8] = 372,
	[593][9] = 373,
	[593][35] = 606,
	[594][2] = 336,
	[594][3] = 337,
	[594][4] = 338,
	[595][2] = 52,
	[595][3] = 53,
	[595][4] = 54,
	[601][6] = 611,
	[606][6] = 613,
	[608][2] = 2,
	[608][3] = 3,
	[608][4] = 4,
	[608][5] = 370,
	[608][7] = 371,
	[608][8] = 372,
	[608][9] = 373,
	[608][35] = 606,
	[611][6] = 611,
	[613][6] = 616,
	[616][6] = 616,
};


const unsigned zebu_reduces[619][36] = {
	[3][15] = 1,
	[4][15] = 2,
	[5][15] = 2,
	[11][2] = 3,
	[11][3] = 3,
	[11][4] = 3,
	[11][5] = 3,
	[11][7] = 3,
	[11][8] = 3,
	[11][9] = 3,
	[11][18] = 3,
	[12][2] = 4,
	[12][3] = 4,
	[12][4] = 4,
	[12][5] = 4,
	[12][7] = 4,
	[12][8] = 4,
	[12][9] = 4,
	[12][18] = 4,
	[13][2] = 5,
	[13][3] = 5,
	[13][4] = 5,
	[13][5] = 5,
	[13][7] = 5,
	[13][8] = 5,
	[13][9] = 5,
	[13][18] = 5,
	[14][2] = 6,
	[14][3] = 6,
	[14][4] = 6,
	[14][5] = 6,
	[14][7] = 6,
	[14][8] = 6,
	[14][9] = 6,
	[14][18] = 6,
	[15][2] = 7,
	[15][3] = 7,
	[15][4] = 7,
	[15][5] = 7,
	[15][7] = 7,
	[15][8] = 7,
	[15][9] = 7,
	[15][18] = 7,
	[16][18] = 8,
	[17][18] = 9,
	[19][13] = 10,
	[19][14] = 10,
	[19][19] = 10,
	[19][20] = 10,
	[19][21] = 10,
	[19][22] = 10,
	[19][23] = 10,
	[19][24] = 10,
	[19][25] = 10,
	[19][26] = 10,
	[19][27] = 10,
	[21][13] = 11,
	[21][14] = 11,
	[21][19] = 11,
	[21][20] = 11,
	[21][21] = 11,
	[21][22] = 11,
	[21][23] = 11,
	[21][24] = 11,
	[21][25] = 11,
	[21][26] = 11,
	[21][27] = 11,
	[22][13] = 12,
	[22][14] = 12,
	[22][19] = 12,
	[22][20] = 12,
	[22][21] = 12,
	[22][22] = 12,
	[22][23] = 12,
	[22][24] = 12,
	[22][25] = 12,
	[22][26] = 12,
	[22][27] = 12,
	[25][19] = 13,
	[25][20] = 13,
	[25][21] = 13,
	[25][24] = 13,
	[25][25] = 13,
	[25][26] = 13,
	[25][27] = 13,
	[26][19] = 14,
	[28][13] = 15,
	[28][14] = 15,
	[28][19] = 15,
	[28][20] = 15,
	[28][21] = 15,
	[28][24] = 15,
	[28][25] = 15,
	[28][26] = 15,
	[28][27] = 15,
	[29][13] = 16,
	[29][14] = 16,
	[29][19] = 16,
	[29][20] = 16,
	[29][21] = 16,
	[29][22] = 16,
	[29][23] = 16,
	[29][24] = 16,
	[29][25] = 16,
	[29][26] = 16,
	[29][27] = 16,
	[30][13] = 17,
	[30][14] = 17,
	[30][19] = 17,
	[30][20] = 17,
	[30][21] = 17,
	[30][22] = 17,
	[30][23] = 17,
	[30][24] = 17,
	[30][25] = 17,
	[30][26] = 17,
	[30][27] = 17,
	[31][13] = 18,
	[31][14] = 18,
	[31][19] = 18,
	[31][20] = 18,
	[31][21] = 18,
	[31][22] = 18,
	[31][23] = 18,
	[31][24] = 18,
	[31][25] = 18,
	[31][26] = 18,
	[31][27] = 18,
	[32][19] = 19,
	[32][26] = 19,
	[32][27] = 19,
	[35][18] = 20,
	[37][13] = 10,
	[37][14] = 10,
	[37][15] = 10,
	[37][20] = 10,
	[37][21] = 10,
	[37][22] = 10,
	[37][23] = 10,
	[37][24] = 10,
	[37][25] = 10,
	[37][26] = 10,
	[37][27] = 10,
	[39][13] = 11,
	[39][14] = 11,
	[39][15] = 11,
	[39][20] = 11,
	[39][21] = 11,
	[39][22] = 11,
	[39][23] = 11,
	[39][24] = 11,
	[39][25] = 11,
	[39][26] = 11,
	[39][27] = 11,
	[40][13] = 12,
	[40][14] = 12,
	[40][15] = 12,
	[40][20] = 12,
	[40][21] = 12,
	[40][22] = 12,
	[40][23] = 12,
	[40][24] = 12,
	[40][25] = 12,
	[40][26] = 12,
	[40][27] = 12,
	[43][15] = 13,
	[43][20] = 13,
	[43][21] = 13,
	[43][24] = 13,
	[43][25] = 13,
	[43][26] = 13,
	[43][27] = 13,
	[44][15] = 14,
	[46][13] = 15,
	[46][14] = 15,
	[46][15] = 15,
	[46][20] = 15,
	[46][21] = 15,
	[46][24] = 15,
	[46][25] = 15,
	[46][26] = 15,
	[46][27] = 15,
	[47][13] = 16,
	[47][14] = 16,
	[47][15] = 16,
	[47][20] = 16,
	[47][21] = 16,
	[47][22] = 16,
	[47][23] = 16,
	[47][24] = 16,
	[47][25] = 16,
	[47][26] = 16,
	[47][27] = 16,
	[48][13] = 17,
	[48][14] = 17,
	[48][15] = 17,
	[48][20] = 17,
	[48][21] = 17,
	[48][22] = 17,
	[48][23] = 17,
	[48][24] = 17,
	[48][25] = 17,
	[48][26] = 17,
	[48][27] = 17,
	[49][13] = 18,
	[49][14] = 18,
	[49][15] = 18,
	[49][20] = 18,
	[49][21] = 18,
	[49][22] = 18,
	[49][23] = 18,
	[49][24] = 18,
	[49][25] = 18,
	[49][26] = 18,
	[49][27] = 18,
	[50][15] = 19,
	[50][26] = 19,
	[50][27] = 19,
	[53][6] = 1,
	[54][6] = 2,
	[57][18] = 21,
	[58][18] = 22,
	[61][13] = 10,
	[61][14] = 10,
	[61][20] = 10,
	[61][21] = 10,
	[61][22] = 10,
	[61][23] = 10,
	[61][24] = 10,
	[61][25] = 10,
	[61][26] = 10,
	[61][27] = 10,
	[61][28] = 10,
	[61][31] = 10,
	[63][13] = 23,
	[63][14] = 23,
	[63][19] = 23,
	[63][20] = 23,
	[63][21] = 23,
	[63][22] = 23,
	[63][23] = 23,
	[63][24] = 23,
	[63][25] = 23,
	[63][26] = 23,
	[63][27] = 23,
	[64][13] = 11,
	[64][14] = 11,
	[64][20] = 11,
	[64][21] = 11,
	[64][22] = 11,
	[64][23] = 11,
	[64][24] = 11,
	[64][25] = 11,
	[64][26] = 11,
	[64][27] = 11,
	[64][28] = 11,
	[64][31] = 11,
	[65][13] = 12,
	[65][14] = 12,
	[65][20] = 12,
	[65][21] = 12,
	[65][22] = 12,
	[65][23] = 12,
	[65][24] = 12,
	[65][25] = 12,
	[65][26] = 12,
	[65][27] = 12,
	[65][28] = 12,
	[65][31] = 12,
	[68][20] = 13,
	[68][21] = 13,
	[68][24] = 13,
	[68][25] = 13,
	[68][26] = 13,
	[68][27] = 13,
	[68][28] = 13,
	[68][31] = 13,
	[69][28] = 14,
	[69][31] = 14,
	[71][13] = 15,
	[71][14] = 15,
	[71][20] = 15,
	[71][21] = 15,
	[71][24] = 15,
	[71][25] = 15,
	[71][26] = 15,
	[71][27] = 15,
	[71][28] = 15,
	[71][31] = 15,
	[72][13] = 16,
	[72][14] = 16,
	[72][20] = 16,
	[72][21] = 16,
	[72][22] = 16,
	[72][23] = 16,
	[72][24] = 16,
	[72][25] = 16,
	[72][26] = 16,
	[72][27] = 16,
	[72][28] = 16,
	[72][31] = 16,
	[73][13] = 17,
	[73][14] = 17,
	[73][20] = 17,
	[73][21] = 17,
	[73][22] = 17,
	[73][23] = 17,
	[73][24] = 17,
	[73][25] = 17,
	[73][26] = 17,
	[73][27] = 17,
	[73][28] = 17,
	[73][31] = 17,
	[74][13] = 18,
	[74][14] = 18,
	[74][20] = 18,
	[74][21] = 18,
	[74][22] = 18,
	[74][23] = 18,
	[74][24] = 18,
	[74][25] = 18,
	[74][26] = 18,
	[74][27] = 18,
	[74][28] = 18,
	[74][31] = 18,
	[75][26] = 19,
	[75][27] = 19,
	[75][28] = 19,
	[75][31] = 19,
	[76][13] = 24,
	[76][14] = 24,
	[76][19] = 24,
	[76][20] = 24,
	[76][21] = 24,
	[76][22] = 24,
	[76][23] = 24,
	[76][24] = 24,
	[76][25] = 24,
	[76][26] = 24,
	[76][27] = 24,
	[77][13] = 25,
	[77][14] = 25,
	[77][19] = 25,
	[77][20] = 25,
	[77][21] = 25,
	[77][22] = 25,
	[77][23] = 25,
	[77][24] = 25,
	[77][25] = 25,
	[77][26] = 25,
	[77][27] = 25,
	[78][13] = 26,
	[78][14] = 26,
	[78][19] = 26,
	[78][20] = 26,
	[78][21] = 26,
	[78][22] = 26,
	[78][23] = 26,
	[78][24] = 26,
	[78][25] = 26,
	[78][26] = 26,
	[78][27] = 26,
	[83][15] = 27,
	[91][6] = 10,
	[91][13] = 10,
	[91][14] = 10,
	[91][20] = 10,
	[91][21] = 10,
	[91][22] = 10,
	[91][23] = 10,
	[91][24] = 10,
	[91][25] = 10,
	[91][26] = 10,
	[91][27] = 10,
	[93][6] = 11,
	[93][13] = 11,
	[93][14] = 11,
	[93][20] = 11,
	[93][21] = 11,
	[93][22] = 11,
	[93][23] = 11,
	[93][24] = 11,
	[93][25] = 11,
	[93][26] = 11,
	[93][27] = 11,
	[94][6] = 12,
	[94][13] = 12,
	[94][14] = 12,
	[94][20] = 12,
	[94][21] = 12,
	[94][22] = 12,
	[94][23] = 12,
	[94][24] = 12,
	[94][25] = 12,
	[94][26] = 12,
	[94][27] = 12,
	[97][2] = 28,
	[97][3] = 28,
	[97][4] = 28,
	[97][5] = 28,
	[97][7] = 28,
	[97][8] = 28,
	[97][9] = 28,
	[97][18] = 28,
	[98][6] = 13,
	[98][20] = 13,
	[98][21] = 13,
	[98][24] = 13,
	[98][25] = 13,
	[98][26] = 13,
	[98][27] = 13,
	[99][6] = 14,
	[101][6] = 15,
	[101][13] = 15,
	[101][14] = 15,
	[101][20] = 15,
	[101][21] = 15,
	[101][24] = 15,
	[101][25] = 15,
	[101][26] = 15,
	[101][27] = 15,
	[102][6] = 16,
	[102][13] = 16,
	[102][14] = 16,
	[102][20] = 16,
	[102][21] = 16,
	[102][22] = 16,
	[102][23] = 16,
	[102][24] = 16,
	[102][25] = 16,
	[102][26] = 16,
	[102][27] = 16,
	[103][6] = 17,
	[103][13] = 17,
	[103][14] = 17,
	[103][20] = 17,
	[103][21] = 17,
	[103][22] = 17,
	[103][23] = 17,
	[103][24] = 17,
	[103][25] = 17,
	[103][26] = 17,
	[103][27] = 17,
	[104][6] = 18,
	[104][13] = 18,
	[104][14] = 18,
	[104][20] = 18,
	[104][21] = 18,
	[104][22] = 18,
	[104][23] = 18,
	[104][24] = 18,
	[104][25] = 18,
	[104][26] = 18,
	[104][27] = 18,
	[105][6] = 19,
	[105][26] = 19,
	[105][27] = 19,
	[106][2] = 29,
	[106][3] = 29,
	[106][4] = 29,
	[106][5] = 29,
	[106][7] = 29,
	[106][8] = 29,
	[106][9] = 29,
	[106][18] = 29,
	[108][13] = 23,
	[108][14] = 23,
	[108][15] = 23,
	[108][20] = 23,
	[108][21] = 23,
	[108][22] = 23,
	[108][23] = 23,
	[108][24] = 23,
	[108][25] = 23,
	[108][26] = 23,
	[108][27] = 23,
	[110][13] = 24,
	[110][14] = 24,
	[110][15] = 24,
	[110][20] = 24,
	[110][21] = 24,
	[110][22] = 24,
	[110][23] = 24,
	[110][24] = 24,
	[110][25] = 24,
	[110][26] = 24,
	[110][27] = 24,
	[111][13] = 25,
	[111][14] = 25,
	[111][15] = 25,
	[111][20] = 25,
	[111][21] = 25,
	[111][22] = 25,
	[111][23] = 25,
	[111][24] = 25,
	[111][25] = 25,
	[111][26] = 25,
	[111][27] = 25,
	[112][13] = 26,
	[112][14] = 26,
	[112][15] = 26,
	[112][20] = 26,
	[112][21] = 26,
	[112][22] = 26,
	[112][23] = 26,
	[112][24] = 26,
	[112][25] = 26,
	[112][26] = 26,
	[112][27] = 26,
	[126][2] = 30,
	[126][3] = 30,
	[126][4] = 30,
	[126][5] = 30,
	[126][7] = 30,
	[126][8] = 30,
	[126][9] = 30,
	[126][18] = 30,
	[128][2] = 1,
	[128][3] = 1,
	[128][4] = 1,
	[128][6] = 1,
	[128][30] = 1,
	[129][2] = 2,
	[129][3] = 2,
	[129][4] = 2,
	[129][6] = 2,
	[129][30] = 2,
	[131][2] = 31,
	[131][3] = 31,
	[131][4] = 31,
	[131][5] = 31,
	[131][7] = 31,
	[131][8] = 31,
	[131][9] = 31,
	[131][18] = 31,
	[132][2] = 32,
	[132][3] = 32,
	[132][4] = 32,
	[132][5] = 32,
	[132][7] = 32,
	[132][8] = 32,
	[132][9] = 32,
	[132][18] = 32,
	[134][2] = 33,
	[134][3] = 33,
	[134][4] = 33,
	[134][5] = 33,
	[134][6] = 33,
	[134][7] = 33,
	[134][8] = 33,
	[134][9] = 33,
	[134][18] = 33,
	[135][2] = 34,
	[135][3] = 34,
	[135][4] = 34,
	[135][5] = 34,
	[135][7] = 34,
	[135][8] = 34,
	[135][9] = 34,
	[135][18] = 34,
	[136][18] = 35,
	[137][13] = 36,
	[137][14] = 36,
	[137][19] = 36,
	[137][20] = 36,
	[137][21] = 36,
	[137][22] = 36,
	[137][23] = 36,
	[137][24] = 36,
	[137][25] = 36,
	[137][26] = 36,
	[137][27] = 36,
	[139][13] = 23,
	[139][14] = 23,
	[139][20] = 23,
	[139][21] = 23,
	[139][22] = 23,
	[139][23] = 23,
	[139][24] = 23,
	[139][25] = 23,
	[139][26] = 23,
	[139][27] = 23,
	[139][28] = 23,
	[139][31] = 23,
	[141][13] = 24,
	[141][14] = 24,
	[141][20] = 24,
	[141][21] = 24,
	[141][22] = 24,
	[141][23] = 24,
	[141][24] = 24,
	[141][25] = 24,
	[141][26] = 24,
	[141][27] = 24,
	[141][28] = 24,
	[141][31] = 24,
	[142][13] = 25,
	[142][14] = 25,
	[142][20] = 25,
	[142][21] = 25,
	[142][22] = 25,
	[142][23] = 25,
	[142][24] = 25,
	[142][25] = 25,
	[142][26] = 25,
	[142][27] = 25,
	[142][28] = 25,
	[142][31] = 25,
	[143][13] = 26,
	[143][14] = 26,
	[143][20] = 26,
	[143][21] = 26,
	[143][22] = 26,
	[143][23] = 26,
	[143][24] = 26,
	[143][25] = 26,
	[143][26] = 26,
	[143][27] = 26,
	[143][28] = 26,
	[143][31] = 26,
	[149][13] = 37,
	[149][14] = 37,
	[149][19] = 37,
	[149][20] = 37,
	[149][21] = 37,
	[149][22] = 37,
	[149][23] = 37,
	[149][24] = 37,
	[149][25] = 37,
	[149][26] = 37,
	[149][27] = 37,
	[150][13] = 38,
	[150][14] = 38,
	[150][19] = 38,
	[150][20] = 38,
	[150][21] = 38,
	[150][22] = 38,
	[150][23] = 38,
	[150][24] = 38,
	[150][25] = 38,
	[150][26] = 38,
	[150][27] = 38,
	[157][13] = 39,
	[157][14] = 39,
	[157][19] = 39,
	[157][20] = 39,
	[157][21] = 39,
	[157][24] = 39,
	[157][25] = 39,
	[157][26] = 39,
	[157][27] = 39,
	[158][13] = 40,
	[158][14] = 40,
	[158][19] = 40,
	[158][20] = 40,
	[158][21] = 40,
	[158][24] = 40,
	[158][25] = 40,
	[158][26] = 40,
	[158][27] = 40,
	[159][13] = 41,
	[159][14] = 41,
	[159][19] = 41,
	[159][20] = 41,
	[159][21] = 41,
	[159][24] = 41,
	[159][25] = 41,
	[159][26] = 41,
	[159][27] = 41,
	[160][19] = 42,
	[160][26] = 42,
	[160][27] = 42,
	[161][19] = 43,
	[161][26] = 43,
	[161][27] = 43,
	[162][19] = 44,
	[162][26] = 44,
	[162][27] = 44,
	[163][13] = 45,
	[163][14] = 45,
	[163][19] = 45,
	[163][20] = 45,
	[163][21] = 45,
	[163][22] = 45,
	[163][23] = 45,
	[163][24] = 45,
	[163][25] = 45,
	[163][26] = 45,
	[163][27] = 45,
	[164][13] = 46,
	[164][14] = 46,
	[164][19] = 46,
	[164][20] = 46,
	[164][21] = 46,
	[164][22] = 46,
	[164][23] = 46,
	[164][24] = 46,
	[164][25] = 46,
	[164][26] = 46,
	[164][27] = 46,
	[165][13] = 47,
	[165][14] = 47,
	[165][19] = 47,
	[165][20] = 47,
	[165][21] = 47,
	[165][22] = 47,
	[165][23] = 47,
	[165][24] = 47,
	[165][25] = 47,
	[165][26] = 47,
	[165][27] = 47,
	[166][19] = 48,
	[166][20] = 48,
	[166][21] = 48,
	[166][24] = 48,
	[166][25] = 48,
	[166][26] = 48,
	[166][27] = 48,
	[167][19] = 49,
	[167][20] = 49,
	[167][21] = 49,
	[167][24] = 49,
	[167][25] = 49,
	[167][26] = 49,
	[167][27] = 49,
	[168][19] = 50,
	[168][20] = 50,
	[168][21] = 50,
	[168][24] = 50,
	[168][25] = 50,
	[168][26] = 50,
	[168][27] = 50,
	[169][19] = 51,
	[169][20] = 51,
	[169][21] = 51,
	[169][24] = 51,
	[169][25] = 51,
	[169][26] = 51,
	[169][27] = 51,
	[170][19] = 52,
	[170][20] = 52,
	[170][21] = 52,
	[170][24] = 52,
	[170][25] = 52,
	[170][26] = 52,
	[170][27] = 52,
	[172][6] = 23,
	[172][13] = 23,
	[172][14] = 23,
	[172][20] = 23,
	[172][21] = 23,
	[172][22] = 23,
	[172][23] = 23,
	[172][24] = 23,
	[172][25] = 23,
	[172][26] = 23,
	[172][27] = 23,
	[174][6] = 24,
	[174][13] = 24,
	[174][14] = 24,
	[174][20] = 24,
	[174][21] = 24,
	[174][22] = 24,
	[174][23] = 24,
	[174][24] = 24,
	[174][25] = 24,
	[174][26] = 24,
	[174][27] = 24,
	[175][6] = 25,
	[175][13] = 25,
	[175][14] = 25,
	[175][20] = 25,
	[175][21] = 25,
	[175][22] = 25,
	[175][23] = 25,
	[175][24] = 25,
	[175][25] = 25,
	[175][26] = 25,
	[175][27] = 25,
	[176][6] = 26,
	[176][13] = 26,
	[176][14] = 26,
	[176][20] = 26,
	[176][21] = 26,
	[176][22] = 26,
	[176][23] = 26,
	[176][24] = 26,
	[176][25] = 26,
	[176][26] = 26,
	[176][27] = 26,
	[181][2] = 53,
	[181][3] = 53,
	[181][4] = 53,
	[181][5] = 53,
	[181][7] = 53,
	[181][8] = 53,
	[181][9] = 53,
	[181][18] = 53,
	[188][13] = 36,
	[188][14] = 36,
	[188][15] = 36,
	[188][20] = 36,
	[188][21] = 36,
	[188][22] = 36,
	[188][23] = 36,
	[188][24] = 36,
	[188][25] = 36,
	[188][26] = 36,
	[188][27] = 36,
	[190][13] = 37,
	[190][14] = 37,
	[190][15] = 37,
	[190][20] = 37,
	[190][21] = 37,
	[190][22] = 37,
	[190][23] = 37,
	[190][24] = 37,
	[190][25] = 37,
	[190][26] = 37,
	[190][27] = 37,
	[191][13] = 38,
	[191][14] = 38,
	[191][15] = 38,
	[191][20] = 38,
	[191][21] = 38,
	[191][22] = 38,
	[191][23] = 38,
	[191][24] = 38,
	[191][25] = 38,
	[191][26] = 38,
	[191][27] = 38,
	[192][13] = 39,
	[192][14] = 39,
	[192][15] = 39,
	[192][20] = 39,
	[192][21] = 39,
	[192][24] = 39,
	[192][25] = 39,
	[192][26] = 39,
	[192][27] = 39,
	[193][13] = 40,
	[193][14] = 40,
	[193][15] = 40,
	[193][20] = 40,
	[193][21] = 40,
	[193][24] = 40,
	[193][25] = 40,
	[193][26] = 40,
	[193][27] = 40,
	[194][13] = 41,
	[194][14] = 41,
	[194][15] = 41,
	[194][20] = 41,
	[194][21] = 41,
	[194][24] = 41,
	[194][25] = 41,
	[194][26] = 41,
	[194][27] = 41,
	[195][15] = 42,
	[195][26] = 42,
	[195][27] = 42,
	[196][15] = 43,
	[196][26] = 43,
	[196][27] = 43,
	[197][15] = 44,
	[197][26] = 44,
	[197][27] = 44,
	[198][15] = 2,
	[203][2] = 3,
	[203][3] = 3,
	[203][4] = 3,
	[203][5] = 3,
	[203][7] = 3,
	[203][8] = 3,
	[203][9] = 3,
	[203][32] = 3,
	[203][33] = 3,
	[204][2] = 4,
	[204][3] = 4,
	[204][4] = 4,
	[204][5] = 4,
	[204][7] = 4,
	[204][8] = 4,
	[204][9] = 4,
	[204][32] = 4,
	[204][33] = 4,
	[205][2] = 5,
	[205][3] = 5,
	[205][4] = 5,
	[205][5] = 5,
	[205][7] = 5,
	[205][8] = 5,
	[205][9] = 5,
	[205][32] = 5,
	[205][33] = 5,
	[206][2] = 6,
	[206][3] = 6,
	[206][4] = 6,
	[206][5] = 6,
	[206][7] = 6,
	[206][8] = 6,
	[206][9] = 6,
	[206][32] = 6,
	[206][33] = 6,
	[207][2] = 7,
	[207][3] = 7,
	[207][4] = 7,
	[207][5] = 7,
	[207][7] = 7,
	[207][8] = 7,
	[207][9] = 7,
	[207][32] = 7,
	[207][33] = 7,
	[209][13] = 45,
	[209][14] = 45,
	[209][15] = 45,
	[209][20] = 45,
	[209][21] = 45,
	[209][22] = 45,
	[209][23] = 45,
	[209][24] = 45,
	[209][25] = 45,
	[209][26] = 45,
	[209][27] = 45,
	[210][13] = 46,
	[210][14] = 46,
	[210][15] = 46,
	[210][20] = 46,
	[210][21] = 46,
	[210][22] = 46,
	[210][23] = 46,
	[210][24] = 46,
	[210][25] = 46,
	[210][26] = 46,
	[210][27] = 46,
	[211][13] = 47,
	[211][14] = 47,
	[211][15] = 47,
	[211][20] = 47,
	[211][21] = 47,
	[211][22] = 47,
	[211][23] = 47,
	[211][24] = 47,
	[211][25] = 47,
	[211][26] = 47,
	[211][27] = 47,
	[212][15] = 48,
	[212][20] = 48,
	[212][21] = 48,
	[212][24] = 48,
	[212][25] = 48,
	[212][26] = 48,
	[212][27] = 48,
	[213][15] = 49,
	[213][20] = 49,
	[213][21] = 49,
	[213][24] = 49,
	[213][25] = 49,
	[213][26] = 49,
	[213][27] = 49,
	[214][15] = 50,
	[214][20] = 50,
	[214][21] = 50,
	[214][24] = 50,
	[214][25] = 50,
	[214][26] = 50,
	[214][27] = 50,
	[215][15] = 51,
	[215][20] = 51,
	[215][21] = 51,
	[215][24] = 51,
	[215][25] = 51,
	[215][26] = 51,
	[215][27] = 51,
	[216][15] = 52,
	[216][20] = 52,
	[216][21] = 52,
	[216][24] = 52,
	[216][25] = 52,
	[216][26] = 52,
	[216][27] = 52,
	[218][6] = 27,
	[219][2] = 54,
	[219][3] = 54,
	[219][4] = 54,
	[219][5] = 54,
	[219][7] = 54,
	[219][8] = 54,
	[219][9] = 54,
	[219][18] = 54,
	[220][2] = 55,
	[220][3] = 55,
	[220][4] = 55,
	[220][5] = 55,
	[220][7] = 55,
	[220][8] = 55,
	[220][9] = 55,
	[220][18] = 55,
	[223][2] = 1,
	[223][3] = 1,
	[223][4] = 1,
	[223][6] = 1,
	[223][20] = 1,
	[223][21] = 1,
	[223][34] = 1,
	[224][2] = 2,
	[224][3] = 2,
	[224][4] = 2,
	[224][6] = 2,
	[224][20] = 2,
	[224][21] = 2,
	[224][34] = 2,
	[225][6] = 56,
	[225][20] = 56,
	[225][21] = 56,
	[225][34] = 56,
	[227][2] = 57,
	[227][3] = 57,
	[227][4] = 57,
	[227][5] = 57,
	[227][7] = 57,
	[227][8] = 57,
	[227][9] = 57,
	[227][18] = 57,
	[228][2] = 58,
	[228][3] = 58,
	[228][4] = 58,
	[228][5] = 58,
	[228][7] = 58,
	[228][8] = 58,
	[228][9] = 58,
	[228][18] = 58,
	[229][2] = 59,
	[229][3] = 59,
	[229][4] = 59,
	[229][5] = 59,
	[229][7] = 59,
	[229][8] = 59,
	[229][9] = 59,
	[229][18] = 59,
	[230][2] = 60,
	[230][3] = 60,
	[230][4] = 60,
	[230][5] = 60,
	[230][6] = 60,
	[230][7] = 60,
	[230][8] = 60,
	[230][9] = 60,
	[230][18] = 60,
	[231][2] = 61,
	[231][3] = 61,
	[231][4] = 61,
	[231][5] = 61,
	[231][6] = 61,
	[231][7] = 61,
	[231][8] = 61,
	[231][9] = 61,
	[231][18] = 61,
	[232][2] = 62,
	[232][3] = 62,
	[232][4] = 62,
	[232][5] = 62,
	[232][7] = 62,
	[232][8] = 62,
	[232][9] = 62,
	[232][18] = 62,
	[233][2] = 63,
	[233][3] = 63,
	[233][4] = 63,
	[233][5] = 63,
	[233][7] = 63,
	[233][8] = 63,
	[233][9] = 63,
	[233][18] = 63,
	[234][13] = 36,
	[234][14] = 36,
	[234][20] = 36,
	[234][21] = 36,
	[234][22] = 36,
	[234][23] = 36,
	[234][24] = 36,
	[234][25] = 36,
	[234][26] = 36,
	[234][27] = 36,
	[234][28] = 36,
	[234][31] = 36,
	[236][13] = 37,
	[236][14] = 37,
	[236][20] = 37,
	[236][21] = 37,
	[236][22] = 37,
	[236][23] = 37,
	[236][24] = 37,
	[236][25] = 37,
	[236][26] = 37,
	[236][27] = 37,
	[236][28] = 37,
	[236][31] = 37,
	[237][13] = 38,
	[237][14] = 38,
	[237][20] = 38,
	[237][21] = 38,
	[237][22] = 38,
	[237][23] = 38,
	[237][24] = 38,
	[237][25] = 38,
	[237][26] = 38,
	[237][27] = 38,
	[237][28] = 38,
	[237][31] = 38,
	[238][13] = 39,
	[238][14] = 39,
	[238][20] = 39,
	[238][21] = 39,
	[238][24] = 39,
	[238][25] = 39,
	[238][26] = 39,
	[238][27] = 39,
	[238][28] = 39,
	[238][31] = 39,
	[239][13] = 40,
	[239][14] = 40,
	[239][20] = 40,
	[239][21] = 40,
	[239][24] = 40,
	[239][25] = 40,
	[239][26] = 40,
	[239][27] = 40,
	[239][28] = 40,
	[239][31] = 40,
	[240][13] = 41,
	[240][14] = 41,
	[240][20] = 41,
	[240][21] = 41,
	[240][24] = 41,
	[240][25] = 41,
	[240][26] = 41,
	[240][27] = 41,
	[240][28] = 41,
	[240][31] = 41,
	[241][26] = 42,
	[241][27] = 42,
	[241][28] = 42,
	[241][31] = 42,
	[242][26] = 43,
	[242][27] = 43,
	[242][28] = 43,
	[242][31] = 43,
	[243][26] = 44,
	[243][27] = 44,
	[243][28] = 44,
	[243][31] = 44,
	[245][13] = 45,
	[245][14] = 45,
	[245][20] = 45,
	[245][21] = 45,
	[245][22] = 45,
	[245][23] = 45,
	[245][24] = 45,
	[245][25] = 45,
	[245][26] = 45,
	[245][27] = 45,
	[245][28] = 45,
	[245][31] = 45,
	[246][13] = 46,
	[246][14] = 46,
	[246][20] = 46,
	[246][21] = 46,
	[246][22] = 46,
	[246][23] = 46,
	[246][24] = 46,
	[246][25] = 46,
	[246][26] = 46,
	[246][27] = 46,
	[246][28] = 46,
	[246][31] = 46,
	[247][13] = 47,
	[247][14] = 47,
	[247][20] = 47,
	[247][21] = 47,
	[247][22] = 47,
	[247][23] = 47,
	[247][24] = 47,
	[247][25] = 47,
	[247][26] = 47,
	[247][27] = 47,
	[247][28] = 47,
	[247][31] = 47,
	[248][20] = 48,
	[248][21] = 48,
	[248][24] = 48,
	[248][25] = 48,
	[248][26] = 48,
	[248][27] = 48,
	[248][28] = 48,
	[248][31] = 48,
	[249][20] = 49,
	[249][21] = 49,
	[249][24] = 49,
	[249][25] = 49,
	[249][26] = 49,
	[249][27] = 49,
	[249][28] = 49,
	[249][31] = 49,
	[250][20] = 50,
	[250][21] = 50,
	[250][24] = 50,
	[250][25] = 50,
	[250][26] = 50,
	[250][27] = 50,
	[250][28] = 50,
	[250][31] = 50,
	[251][20] = 51,
	[251][21] = 51,
	[251][24] = 51,
	[251][25] = 51,
	[251][26] = 51,
	[251][27] = 51,
	[251][28] = 51,
	[251][31] = 51,
	[252][20] = 52,
	[252][21] = 52,
	[252][24] = 52,
	[252][25] = 52,
	[252][26] = 52,
	[252][27] = 52,
	[252][28] = 52,
	[252][31] = 52,
	[253][6] = 36,
	[253][13] = 36,
	[253][14] = 36,
	[253][20] = 36,
	[253][21] = 36,
	[253][22] = 36,
	[253][23] = 36,
	[253][24] = 36,
	[253][25] = 36,
	[253][26] = 36,
	[253][27] = 36,
	[255][6] = 37,
	[255][13] = 37,
	[255][14] = 37,
	[255][20] = 37,
	[255][21] = 37,
	[255][22] = 37,
	[255][23] = 37,
	[255][24] = 37,
	[255][25] = 37,
	[255][26] = 37,
	[255][27] = 37,
	[256][6] = 38,
	[256][13] = 38,
	[256][14] = 38,
	[256][20] = 38,
	[256][21] = 38,
	[256][22] = 38,
	[256][23] = 38,
	[256][24] = 38,
	[256][25] = 38,
	[256][26] = 38,
	[256][27] = 38,
	[257][6] = 39,
	[257][13] = 39,
	[257][14] = 39,
	[257][20] = 39,
	[257][21] = 39,
	[257][24] = 39,
	[257][25] = 39,
	[257][26] = 39,
	[257][27] = 39,
	[258][6] = 40,
	[258][13] = 40,
	[258][14] = 40,
	[258][20] = 40,
	[258][21] = 40,
	[258][24] = 40,
	[258][25] = 40,
	[258][26] = 40,
	[258][27] = 40,
	[259][6] = 41,
	[259][13] = 41,
	[259][14] = 41,
	[259][20] = 41,
	[259][21] = 41,
	[259][24] = 41,
	[259][25] = 41,
	[259][26] = 41,
	[259][27] = 41,
	[260][6] = 42,
	[260][26] = 42,
	[260][27] = 42,
	[261][6] = 43,
	[261][26] = 43,
	[261][27] = 43,
	[262][6] = 44,
	[262][26] = 44,
	[262][27] = 44,
	[263][2] = 64,
	[263][3] = 64,
	[263][4] = 64,
	[263][5] = 64,
	[263][7] = 64,
	[263][8] = 64,
	[263][9] = 64,
	[263][18] = 64,
	[264][2] = 65,
	[264][3] = 65,
	[264][4] = 65,
	[264][5] = 65,
	[264][7] = 65,
	[264][8] = 65,
	[264][9] = 65,
	[264][18] = 65,
	[265][6] = 45,
	[265][13] = 45,
	[265][14] = 45,
	[265][20] = 45,
	[265][21] = 45,
	[265][22] = 45,
	[265][23] = 45,
	[265][24] = 45,
	[265][25] = 45,
	[265][26] = 45,
	[265][27] = 45,
	[266][6] = 46,
	[266][13] = 46,
	[266][14] = 46,
	[266][20] = 46,
	[266][21] = 46,
	[266][22] = 46,
	[266][23] = 46,
	[266][24] = 46,
	[266][25] = 46,
	[266][26] = 46,
	[266][27] = 46,
	[267][6] = 47,
	[267][13] = 47,
	[267][14] = 47,
	[267][20] = 47,
	[267][21] = 47,
	[267][22] = 47,
	[267][23] = 47,
	[267][24] = 47,
	[267][25] = 47,
	[267][26] = 47,
	[267][27] = 47,
	[268][6] = 48,
	[268][20] = 48,
	[268][21] = 48,
	[268][24] = 48,
	[268][25] = 48,
	[268][26] = 48,
	[268][27] = 48,
	[269][6] = 49,
	[269][20] = 49,
	[269][21] = 49,
	[269][24] = 49,
	[269][25] = 49,
	[269][26] = 49,
	[269][27] = 49,
	[270][6] = 50,
	[270][20] = 50,
	[270][21] = 50,
	[270][24] = 50,
	[270][25] = 50,
	[270][26] = 50,
	[270][27] = 50,
	[271][6] = 51,
	[271][20] = 51,
	[271][21] = 51,
	[271][24] = 51,
	[271][25] = 51,
	[271][26] = 51,
	[271][27] = 51,
	[272][6] = 52,
	[272][20] = 52,
	[272][21] = 52,
	[272][24] = 52,
	[272][25] = 52,
	[272][26] = 52,
	[272][27] = 52,
	[282][2] = 66,
	[282][3] = 66,
	[282][4] = 66,
	[282][5] = 66,
	[282][7] = 66,
	[282][8] = 66,
	[282][9] = 66,
	[282][18] = 66,
	[285][2] = 67,
	[285][3] = 67,
	[285][4] = 67,
	[285][5] = 67,
	[285][7] = 67,
	[285][8] = 67,
	[285][9] = 67,
	[285][18] = 67,
	[286][2] = 27,
	[286][3] = 27,
	[286][4] = 27,
	[286][6] = 27,
	[286][30] = 27,
	[288][6] = 68,
	[288][20] = 68,
	[288][21] = 68,
	[288][34] = 68,
	[289][6] = 69,
	[289][20] = 69,
	[289][21] = 69,
	[289][34] = 69,
	[293][2] = 70,
	[293][3] = 70,
	[293][4] = 70,
	[293][5] = 70,
	[293][6] = 70,
	[293][7] = 70,
	[293][8] = 70,
	[293][9] = 70,
	[293][18] = 70,
	[293][30] = 70,
	[294][2] = 71,
	[294][3] = 71,
	[294][4] = 71,
	[294][5] = 71,
	[294][7] = 71,
	[294][8] = 71,
	[294][9] = 71,
	[294][18] = 71,
	[295][2] = 72,
	[295][3] = 72,
	[295][4] = 72,
	[295][5] = 72,
	[295][7] = 72,
	[295][8] = 72,
	[295][9] = 72,
	[295][18] = 72,
	[296][2] = 73,
	[296][3] = 73,
	[296][4] = 73,
	[296][5] = 73,
	[296][6] = 73,
	[296][7] = 73,
	[296][8] = 73,
	[296][9] = 73,
	[296][18] = 73,
	[297][2] = 74,
	[297][3] = 74,
	[297][4] = 74,
	[297][5] = 74,
	[297][7] = 74,
	[297][8] = 74,
	[297][9] = 74,
	[297][18] = 74,
	[299][13] = 75,
	[299][14] = 75,
	[299][19] = 75,
	[299][20] = 75,
	[299][21] = 75,
	[299][22] = 75,
	[299][23] = 75,
	[299][24] = 75,
	[299][25] = 75,
	[299][26] = 75,
	[299][27] = 75,
	[301][2] = 76,
	[301][3] = 76,
	[301][4] = 76,
	[301][5] = 76,
	[301][7] = 76,
	[301][8] = 76,
	[301][9] = 76,
	[301][18] = 76,
	[302][13] = 75,
	[302][14] = 75,
	[302][15] = 75,
	[302][20] = 75,
	[302][21] = 75,
	[302][22] = 75,
	[302][23] = 75,
	[302][24] = 75,
	[302][25] = 75,
	[302][26] = 75,
	[302][27] = 75,
	[303][2] = 28,
	[303][3] = 28,
	[303][4] = 28,
	[303][5] = 28,
	[303][7] = 28,
	[303][8] = 28,
	[303][9] = 28,
	[303][32] = 28,
	[303][33] = 28,
	[305][2] = 29,
	[305][3] = 29,
	[305][4] = 29,
	[305][5] = 29,
	[305][7] = 29,
	[305][8] = 29,
	[305][9] = 29,
	[305][32] = 29,
	[305][33] = 29,
	[308][2] = 30,
	[308][3] = 30,
	[308][4] = 30,
	[308][5] = 30,
	[308][7] = 30,
	[308][8] = 30,
	[308][9] = 30,
	[308][32] = 30,
	[308][33] = 30,
	[310][2] = 31,
	[310][3] = 31,
	[310][4] = 31,
	[310][5] = 31,
	[310][7] = 31,
	[310][8] = 31,
	[310][9] = 31,
	[310][32] = 31,
	[310][33] = 31,
	[311][2] = 32,
	[311][3] = 32,
	[311][4] = 32,
	[311][5] = 32,
	[311][7] = 32,
	[311][8] = 32,
	[311][9] = 32,
	[311][32] = 32,
	[311][33] = 32,
	[313][2] = 33,
	[313][3] = 33,
	[313][4] = 33,
	[313][5] = 33,
	[313][6] = 33,
	[313][7] = 33,
	[313][8] = 33,
	[313][9] = 33,
	[313][32] = 33,
	[313][33] = 33,
	[314][2] = 34,
	[314][3] = 34,
	[314][4] = 34,
	[314][5] = 34,
	[314][7] = 34,
	[314][8] = 34,
	[314][9] = 34,
	[314][32] = 34,
	[314][33] = 34,
	[315][15] = 2,
	[320][2] = 3,
	[320][3] = 3,
	[320][4] = 3,
	[320][5] = 3,
	[320][7] = 3,
	[320][8] = 3,
	[320][9] = 3,
	[320][33] = 3,
	[321][2] = 4,
	[321][3] = 4,
	[321][4] = 4,
	[321][5] = 4,
	[321][7] = 4,
	[321][8] = 4,
	[321][9] = 4,
	[321][33] = 4,
	[322][2] = 5,
	[322][3] = 5,
	[322][4] = 5,
	[322][5] = 5,
	[322][7] = 5,
	[322][8] = 5,
	[322][9] = 5,
	[322][33] = 5,
	[323][2] = 6,
	[323][3] = 6,
	[323][4] = 6,
	[323][5] = 6,
	[323][7] = 6,
	[323][8] = 6,
	[323][9] = 6,
	[323][33] = 6,
	[324][2] = 7,
	[324][3] = 7,
	[324][4] = 7,
	[324][5] = 7,
	[324][7] = 7,
	[324][8] = 7,
	[324][9] = 7,
	[324][33] = 7,
	[326][2] = 77,
	[326][3] = 77,
	[326][4] = 77,
	[326][5] = 77,
	[326][7] = 77,
	[326][8] = 77,
	[326][9] = 77,
	[326][18] = 77,
	[327][2] = 78,
	[327][3] = 78,
	[327][4] = 78,
	[327][5] = 78,
	[327][7] = 78,
	[327][8] = 78,
	[327][9] = 78,
	[327][18] = 78,
	[328][2] = 79,
	[328][3] = 79,
	[328][4] = 79,
	[328][5] = 79,
	[328][7] = 79,
	[328][8] = 79,
	[328][9] = 79,
	[328][18] = 79,
	[330][2] = 27,
	[330][3] = 27,
	[330][4] = 27,
	[330][6] = 27,
	[330][20] = 27,
	[330][21] = 27,
	[330][34] = 27,
	[331][6] = 80,
	[331][20] = 80,
	[331][21] = 80,
	[331][34] = 80,
	[333][6] = 1,
	[333][21] = 1,
	[333][34] = 1,
	[334][6] = 2,
	[334][21] = 2,
	[334][34] = 2,
	[337][2] = 1,
	[337][3] = 1,
	[337][4] = 1,
	[337][6] = 1,
	[337][21] = 1,
	[337][34] = 1,
	[338][2] = 2,
	[338][3] = 2,
	[338][4] = 2,
	[338][6] = 2,
	[338][21] = 2,
	[338][34] = 2,
	[339][2] = 81,
	[339][3] = 81,
	[339][4] = 81,
	[339][5] = 81,
	[339][6] = 81,
	[339][7] = 81,
	[339][8] = 81,
	[339][9] = 81,
	[339][18] = 81,
	[339][30] = 81,
	[340][6] = 56,
	[340][21] = 56,
	[340][34] = 56,
	[342][2] = 82,
	[342][3] = 82,
	[342][4] = 82,
	[342][5] = 82,
	[342][6] = 82,
	[342][7] = 82,
	[342][8] = 82,
	[342][9] = 82,
	[342][18] = 82,
	[342][30] = 82,
	[344][13] = 75,
	[344][14] = 75,
	[344][20] = 75,
	[344][21] = 75,
	[344][22] = 75,
	[344][23] = 75,
	[344][24] = 75,
	[344][25] = 75,
	[344][26] = 75,
	[344][27] = 75,
	[344][28] = 75,
	[344][31] = 75,
	[345][6] = 75,
	[345][13] = 75,
	[345][14] = 75,
	[345][20] = 75,
	[345][21] = 75,
	[345][22] = 75,
	[345][23] = 75,
	[345][24] = 75,
	[345][25] = 75,
	[345][26] = 75,
	[345][27] = 75,
	[346][2] = 53,
	[346][3] = 53,
	[346][4] = 53,
	[346][5] = 53,
	[346][7] = 53,
	[346][8] = 53,
	[346][9] = 53,
	[346][32] = 53,
	[346][33] = 53,
	[349][2] = 54,
	[349][3] = 54,
	[349][4] = 54,
	[349][5] = 54,
	[349][7] = 54,
	[349][8] = 54,
	[349][9] = 54,
	[349][32] = 54,
	[349][33] = 54,
	[350][2] = 55,
	[350][3] = 55,
	[350][4] = 55,
	[350][5] = 55,
	[350][7] = 55,
	[350][8] = 55,
	[350][9] = 55,
	[350][32] = 55,
	[350][33] = 55,
	[352][2] = 57,
	[352][3] = 57,
	[352][4] = 57,
	[352][5] = 57,
	[352][7] = 57,
	[352][8] = 57,
	[352][9] = 57,
	[352][32] = 57,
	[352][33] = 57,
	[353][2] = 58,
	[353][3] = 58,
	[353][4] = 58,
	[353][5] = 58,
	[353][7] = 58,
	[353][8] = 58,
	[353][9] = 58,
	[353][32] = 58,
	[353][33] = 58,
	[354][2] = 59,
	[354][3] = 59,
	[354][4] = 59,
	[354][5] = 59,
	[354][7] = 59,
	[354][8] = 59,
	[354][9] = 59,
	[354][32] = 59,
	[354][33] = 59,
	[355][2] = 60,
	[355][3] = 60,
	[355][4] = 60,
	[355][5] = 60,
	[355][6] = 60,
	[355][7] = 60,
	[355][8] = 60,
	[355][9] = 60,
	[355][32] = 60,
	[355][33] = 60,
	[356][2] = 61,
	[356][3] = 61,
	[356][4] = 61,
	[356][5] = 61,
	[356][6] = 61,
	[356][7] = 61,
	[356][8] = 61,
	[356][9] = 61,
	[356][32] = 61,
	[356][33] = 61,
	[357][2] = 62,
	[357][3] = 62,
	[357][4] = 62,
	[357][5] = 62,
	[357][7] = 62,
	[357][8] = 62,
	[357][9] = 62,
	[357][32] = 62,
	[357][33] = 62,
	[358][2] = 63,
	[358][3] = 63,
	[358][4] = 63,
	[358][5] = 63,
	[358][7] = 63,
	[358][8] = 63,
	[358][9] = 63,
	[358][32] = 63,
	[358][33] = 63,
	[366][2] = 83,
	[366][3] = 83,
	[366][4] = 83,
	[366][5] = 83,
	[366][7] = 83,
	[366][8] = 83,
	[366][9] = 83,
	[366][18] = 83,
	[368][2] = 84,
	[368][3] = 84,
	[368][4] = 84,
	[368][5] = 84,
	[368][7] = 84,
	[368][8] = 84,
	[368][9] = 84,
	[368][18] = 84,
	[369][2] = 85,
	[369][3] = 85,
	[369][4] = 85,
	[369][5] = 85,
	[369][7] = 85,
	[369][8] = 85,
	[369][9] = 85,
	[369][18] = 85,
	[370][15] = 2,
	[375][2] = 3,
	[375][3] = 3,
	[375][4] = 3,
	[375][5] = 3,
	[375][7] = 3,
	[375][8] = 3,
	[375][9] = 3,
	[375][35] = 3,
	[376][2] = 4,
	[376][3] = 4,
	[376][4] = 4,
	[376][5] = 4,
	[376][7] = 4,
	[376][8] = 4,
	[376][9] = 4,
	[376][35] = 4,
	[377][2] = 5,
	[377][3] = 5,
	[377][4] = 5,
	[377][5] = 5,
	[377][7] = 5,
	[377][8] = 5,
	[377][9] = 5,
	[377][35] = 5,
	[378][2] = 6,
	[378][3] = 6,
	[378][4] = 6,
	[378][5] = 6,
	[378][7] = 6,
	[378][8] = 6,
	[378][9] = 6,
	[378][35] = 6,
	[379][2] = 7,
	[379][3] = 7,
	[379][4] = 7,
	[379][5] = 7,
	[379][7] = 7,
	[379][8] = 7,
	[379][9] = 7,
	[379][35] = 7,
	[384][2] = 86,
	[384][3] = 86,
	[384][4] = 86,
	[384][5] = 86,
	[384][6] = 86,
	[384][7] = 86,
	[384][8] = 86,
	[384][9] = 86,
	[384][18] = 86,
	[384][30] = 86,
	[385][2] = 87,
	[385][3] = 87,
	[385][4] = 87,
	[385][5] = 87,
	[385][6] = 87,
	[385][7] = 87,
	[385][8] = 87,
	[385][9] = 87,
	[385][18] = 87,
	[385][30] = 87,
	[387][6] = 68,
	[387][21] = 68,
	[387][34] = 68,
	[388][6] = 69,
	[388][21] = 69,
	[388][34] = 69,
	[389][2] = 88,
	[389][3] = 88,
	[389][4] = 88,
	[389][5] = 88,
	[389][6] = 88,
	[389][7] = 88,
	[389][8] = 88,
	[389][9] = 88,
	[389][18] = 88,
	[389][30] = 88,
	[390][2] = 89,
	[390][3] = 89,
	[390][4] = 89,
	[390][5] = 89,
	[390][6] = 89,
	[390][7] = 89,
	[390][8] = 89,
	[390][9] = 89,
	[390][18] = 89,
	[390][30] = 89,
	[391][2] = 64,
	[391][3] = 64,
	[391][4] = 64,
	[391][5] = 64,
	[391][7] = 64,
	[391][8] = 64,
	[391][9] = 64,
	[391][32] = 64,
	[391][33] = 64,
	[392][2] = 65,
	[392][3] = 65,
	[392][4] = 65,
	[392][5] = 65,
	[392][7] = 65,
	[392][8] = 65,
	[392][9] = 65,
	[392][32] = 65,
	[392][33] = 65,
	[395][2] = 66,
	[395][3] = 66,
	[395][4] = 66,
	[395][5] = 66,
	[395][7] = 66,
	[395][8] = 66,
	[395][9] = 66,
	[395][32] = 66,
	[395][33] = 66,
	[398][2] = 67,
	[398][3] = 67,
	[398][4] = 67,
	[398][5] = 67,
	[398][7] = 67,
	[398][8] = 67,
	[398][9] = 67,
	[398][32] = 67,
	[398][33] = 67,
	[402][2] = 70,
	[402][3] = 70,
	[402][4] = 70,
	[402][5] = 70,
	[402][6] = 70,
	[402][7] = 70,
	[402][8] = 70,
	[402][9] = 70,
	[402][30] = 70,
	[402][32] = 70,
	[402][33] = 70,
	[403][2] = 71,
	[403][3] = 71,
	[403][4] = 71,
	[403][5] = 71,
	[403][7] = 71,
	[403][8] = 71,
	[403][9] = 71,
	[403][32] = 71,
	[403][33] = 71,
	[404][2] = 72,
	[404][3] = 72,
	[404][4] = 72,
	[404][5] = 72,
	[404][7] = 72,
	[404][8] = 72,
	[404][9] = 72,
	[404][32] = 72,
	[404][33] = 72,
	[405][2] = 73,
	[405][3] = 73,
	[405][4] = 73,
	[405][5] = 73,
	[405][6] = 73,
	[405][7] = 73,
	[405][8] = 73,
	[405][9] = 73,
	[405][32] = 73,
	[405][33] = 73,
	[406][2] = 74,
	[406][3] = 74,
	[406][4] = 74,
	[406][5] = 74,
	[406][7] = 74,
	[406][8] = 74,
	[406][9] = 74,
	[406][32] = 74,
	[406][33] = 74,
	[407][2] = 28,
	[407][3] = 28,
	[407][4] = 28,
	[407][5] = 28,
	[407][7] = 28,
	[407][8] = 28,
	[407][9] = 28,
	[407][33] = 28,
	[409][2] = 29,
	[409][3] = 29,
	[409][4] = 29,
	[409][5] = 29,
	[409][7] = 29,
	[409][8] = 29,
	[409][9] = 29,
	[409][33] = 29,
	[412][2] = 30,
	[412][3] = 30,
	[412][4] = 30,
	[412][5] = 30,
	[412][7] = 30,
	[412][8] = 30,
	[412][9] = 30,
	[412][33] = 30,
	[414][2] = 31,
	[414][3] = 31,
	[414][4] = 31,
	[414][5] = 31,
	[414][7] = 31,
	[414][8] = 31,
	[414][9] = 31,
	[414][33] = 31,
	[415][2] = 32,
	[415][3] = 32,
	[415][4] = 32,
	[415][5] = 32,
	[415][7] = 32,
	[415][8] = 32,
	[415][9] = 32,
	[415][33] = 32,
	[417][2] = 33,
	[417][3] = 33,
	[417][4] = 33,
	[417][5] = 33,
	[417][6] = 33,
	[417][7] = 33,
	[417][8] = 33,
	[417][9] = 33,
	[417][33] = 33,
	[418][2] = 34,
	[418][3] = 34,
	[418][4] = 34,
	[418][5] = 34,
	[418][7] = 34,
	[418][8] = 34,
	[418][9] = 34,
	[418][33] = 34,
	[419][2] = 90,
	[419][3] = 90,
	[419][4] = 90,
	[419][5] = 90,
	[419][7] = 90,
	[419][8] = 90,
	[419][9] = 90,
	[419][18] = 90,
	[420][2] = 91,
	[420][3] = 91,
	[420][4] = 91,
	[420][5] = 91,
	[420][7] = 91,
	[420][8] = 91,
	[420][9] = 91,
	[420][18] = 91,
	[421][2] = 92,
	[421][3] = 92,
	[421][4] = 92,
	[421][5] = 92,
	[421][7] = 92,
	[421][8] = 92,
	[421][9] = 92,
	[421][18] = 92,
	[429][2] = 93,
	[429][3] = 93,
	[429][4] = 93,
	[429][5] = 93,
	[429][7] = 93,
	[429][8] = 93,
	[429][9] = 93,
	[429][18] = 93,
	[431][6] = 27,
	[431][21] = 27,
	[431][34] = 27,
	[432][2] = 94,
	[432][3] = 94,
	[432][4] = 94,
	[432][5] = 94,
	[432][6] = 94,
	[432][7] = 94,
	[432][8] = 94,
	[432][9] = 94,
	[432][18] = 94,
	[432][30] = 94,
	[433][2] = 95,
	[433][3] = 95,
	[433][4] = 95,
	[433][5] = 95,
	[433][6] = 95,
	[433][7] = 95,
	[433][8] = 95,
	[433][9] = 95,
	[433][18] = 95,
	[433][30] = 95,
	[434][2] = 27,
	[434][3] = 27,
	[434][4] = 27,
	[434][6] = 27,
	[434][21] = 27,
	[434][34] = 27,
	[435][6] = 80,
	[435][21] = 80,
	[435][34] = 80,
	[436][2] = 76,
	[436][3] = 76,
	[436][4] = 76,
	[436][5] = 76,
	[436][7] = 76,
	[436][8] = 76,
	[436][9] = 76,
	[436][32] = 76,
	[436][33] = 76,
	[438][2] = 77,
	[438][3] = 77,
	[438][4] = 77,
	[438][5] = 77,
	[438][7] = 77,
	[438][8] = 77,
	[438][9] = 77,
	[438][32] = 77,
	[438][33] = 77,
	[439][2] = 78,
	[439][3] = 78,
	[439][4] = 78,
	[439][5] = 78,
	[439][7] = 78,
	[439][8] = 78,
	[439][9] = 78,
	[439][32] = 78,
	[439][33] = 78,
	[440][2] = 79,
	[440][3] = 79,
	[440][4] = 79,
	[440][5] = 79,
	[440][7] = 79,
	[440][8] = 79,
	[440][9] = 79,
	[440][32] = 79,
	[440][33] = 79,
	[443][2] = 81,
	[443][3] = 81,
	[443][4] = 81,
	[443][5] = 81,
	[443][6] = 81,
	[443][7] = 81,
	[443][8] = 81,
	[443][9] = 81,
	[443][30] = 81,
	[443][32] = 81,
	[443][33] = 81,
	[445][2] = 82,
	[445][3] = 82,
	[445][4] = 82,
	[445][5] = 82,
	[445][6] = 82,
	[445][7] = 82,
	[445][8] = 82,
	[445][9] = 82,
	[445][30] = 82,
	[445][32] = 82,
	[445][33] = 82,
	[447][2] = 53,
	[447][3] = 53,
	[447][4] = 53,
	[447][5] = 53,
	[447][7] = 53,
	[447][8] = 53,
	[447][9] = 53,
	[447][33] = 53,
	[450][2] = 54,
	[450][3] = 54,
	[450][4] = 54,
	[450][5] = 54,
	[450][7] = 54,
	[450][8] = 54,
	[450][9] = 54,
	[450][33] = 54,
	[451][2] = 55,
	[451][3] = 55,
	[451][4] = 55,
	[451][5] = 55,
	[451][7] = 55,
	[451][8] = 55,
	[451][9] = 55,
	[451][33] = 55,
	[453][2] = 57,
	[453][3] = 57,
	[453][4] = 57,
	[453][5] = 57,
	[453][7] = 57,
	[453][8] = 57,
	[453][9] = 57,
	[453][33] = 57,
	[454][2] = 58,
	[454][3] = 58,
	[454][4] = 58,
	[454][5] = 58,
	[454][7] = 58,
	[454][8] = 58,
	[454][9] = 58,
	[454][33] = 58,
	[455][2] = 59,
	[455][3] = 59,
	[455][4] = 59,
	[455][5] = 59,
	[455][7] = 59,
	[455][8] = 59,
	[455][9] = 59,
	[455][33] = 59,
	[456][2] = 60,
	[456][3] = 60,
	[456][4] = 60,
	[456][5] = 60,
	[456][6] = 60,
	[456][7] = 60,
	[456][8] = 60,
	[456][9] = 60,
	[456][33] = 60,
	[457][2] = 61,
	[457][3] = 61,
	[457][4] = 61,
	[457][5] = 61,
	[457][6] = 61,
	[457][7] = 61,
	[457][8] = 61,
	[457][9] = 61,
	[457][33] = 61,
	[458][2] = 62,
	[458][3] = 62,
	[458][4] = 62,
	[458][5] = 62,
	[458][7] = 62,
	[458][8] = 62,
	[458][9] = 62,
	[458][33] = 62,
	[459][2] = 63,
	[459][3] = 63,
	[459][4] = 63,
	[459][5] = 63,
	[459][7] = 63,
	[459][8] = 63,
	[459][9] = 63,
	[459][33] = 63,
	[460][2] = 28,
	[460][3] = 28,
	[460][4] = 28,
	[460][5] = 28,
	[460][7] = 28,
	[460][8] = 28,
	[460][9] = 28,
	[460][35] = 28,
	[462][2] = 29,
	[462][3] = 29,
	[462][4] = 29,
	[462][5] = 29,
	[462][7] = 29,
	[462][8] = 29,
	[462][9] = 29,
	[462][35] = 29,
	[465][2] = 30,
	[465][3] = 30,
	[465][4] = 30,
	[465][5] = 30,
	[465][7] = 30,
	[465][8] = 30,
	[465][9] = 30,
	[465][35] = 30,
	[467][2] = 31,
	[467][3] = 31,
	[467][4] = 31,
	[467][5] = 31,
	[467][7] = 31,
	[467][8] = 31,
	[467][9] = 31,
	[467][35] = 31,
	[468][2] = 32,
	[468][3] = 32,
	[468][4] = 32,
	[468][5] = 32,
	[468][7] = 32,
	[468][8] = 32,
	[468][9] = 32,
	[468][35] = 32,
	[470][2] = 33,
	[470][3] = 33,
	[470][4] = 33,
	[470][5] = 33,
	[470][6] = 33,
	[470][7] = 33,
	[470][8] = 33,
	[470][9] = 33,
	[470][35] = 33,
	[471][2] = 34,
	[471][3] = 34,
	[471][4] = 34,
	[471][5] = 34,
	[471][7] = 34,
	[471][8] = 34,
	[471][9] = 34,
	[471][35] = 34,
	[472][2] = 96,
	[472][3] = 96,
	[472][4] = 96,
	[472][5] = 96,
	[472][7] = 96,
	[472][8] = 96,
	[472][9] = 96,
	[472][18] = 96,
	[473][2] = 97,
	[473][3] = 97,
	[473][4] = 97,
	[473][5] = 97,
	[473][7] = 97,
	[473][8] = 97,
	[473][9] = 97,
	[473][18] = 97,
	[475][2] = 83,
	[475][3] = 83,
	[475][4] = 83,
	[475][5] = 83,
	[475][7] = 83,
	[475][8] = 83,
	[475][9] = 83,
	[475][32] = 83,
	[475][33] = 83,
	[477][2] = 84,
	[477][3] = 84,
	[477][4] = 84,
	[477][5] = 84,
	[477][7] = 84,
	[477][8] = 84,
	[477][9] = 84,
	[477][32] = 84,
	[477][33] = 84,
	[478][2] = 85,
	[478][3] = 85,
	[478][4] = 85,
	[478][5] = 85,
	[478][7] = 85,
	[478][8] = 85,
	[478][9] = 85,
	[478][32] = 85,
	[478][33] = 85,
	[482][2] = 86,
	[482][3] = 86,
	[482][4] = 86,
	[482][5] = 86,
	[482][6] = 86,
	[482][7] = 86,
	[482][8] = 86,
	[482][9] = 86,
	[482][30] = 86,
	[482][32] = 86,
	[482][33] = 86,
	[483][2] = 87,
	[483][3] = 87,
	[483][4] = 87,
	[483][5] = 87,
	[483][6] = 87,
	[483][7] = 87,
	[483][8] = 87,
	[483][9] = 87,
	[483][30] = 87,
	[483][32] = 87,
	[483][33] = 87,
	[484][2] = 88,
	[484][3] = 88,
	[484][4] = 88,
	[484][5] = 88,
	[484][6] = 88,
	[484][7] = 88,
	[484][8] = 88,
	[484][9] = 88,
	[484][30] = 88,
	[484][32] = 88,
	[484][33] = 88,
	[485][2] = 89,
	[485][3] = 89,
	[485][4] = 89,
	[485][5] = 89,
	[485][6] = 89,
	[485][7] = 89,
	[485][8] = 89,
	[485][9] = 89,
	[485][30] = 89,
	[485][32] = 89,
	[485][33] = 89,
	[486][2] = 64,
	[486][3] = 64,
	[486][4] = 64,
	[486][5] = 64,
	[486][7] = 64,
	[486][8] = 64,
	[486][9] = 64,
	[486][33] = 64,
	[487][2] = 65,
	[487][3] = 65,
	[487][4] = 65,
	[487][5] = 65,
	[487][7] = 65,
	[487][8] = 65,
	[487][9] = 65,
	[487][33] = 65,
	[490][2] = 66,
	[490][3] = 66,
	[490][4] = 66,
	[490][5] = 66,
	[490][7] = 66,
	[490][8] = 66,
	[490][9] = 66,
	[490][33] = 66,
	[493][2] = 67,
	[493][3] = 67,
	[493][4] = 67,
	[493][5] = 67,
	[493][7] = 67,
	[493][8] = 67,
	[493][9] = 67,
	[493][33] = 67,
	[497][2] = 70,
	[497][3] = 70,
	[497][4] = 70,
	[497][5] = 70,
	[497][6] = 70,
	[497][7] = 70,
	[497][8] = 70,
	[497][9] = 70,
	[497][30] = 70,
	[497][33] = 70,
	[498][2] = 71,
	[498][3] = 71,
	[498][4] = 71,
	[498][5] = 71,
	[498][7] = 71,
	[498][8] = 71,
	[498][9] = 71,
	[498][33] = 71,
	[499][2] = 72,
	[499][3] = 72,
	[499][4] = 72,
	[499][5] = 72,
	[499][7] = 72,
	[499][8] = 72,
	[499][9] = 72,
	[499][33] = 72,
	[500][2] = 73,
	[500][3] = 73,
	[500][4] = 73,
	[500][5] = 73,
	[500][6] = 73,
	[500][7] = 73,
	[500][8] = 73,
	[500][9] = 73,
	[500][33] = 73,
	[501][2] = 74,
	[501][3] = 74,
	[501][4] = 74,
	[501][5] = 74,
	[501][7] = 74,
	[501][8] = 74,
	[501][9] = 74,
	[501][33] = 74,
	[502][2] = 53,
	[502][3] = 53,
	[502][4] = 53,
	[502][5] = 53,
	[502][7] = 53,
	[502][8] = 53,
	[502][9] = 53,
	[502][35] = 53,
	[505][2] = 54,
	[505][3] = 54,
	[505][4] = 54,
	[505][5] = 54,
	[505][7] = 54,
	[505][8] = 54,
	[505][9] = 54,
	[505][35] = 54,
	[506][2] = 55,
	[506][3] = 55,
	[506][4] = 55,
	[506][5] = 55,
	[506][7] = 55,
	[506][8] = 55,
	[506][9] = 55,
	[506][35] = 55,
	[508][2] = 57,
	[508][3] = 57,
	[508][4] = 57,
	[508][5] = 57,
	[508][7] = 57,
	[508][8] = 57,
	[508][9] = 57,
	[508][35] = 57,
	[509][2] = 58,
	[509][3] = 58,
	[509][4] = 58,
	[509][5] = 58,
	[509][7] = 58,
	[509][8] = 58,
	[509][9] = 58,
	[509][35] = 58,
	[510][2] = 59,
	[510][3] = 59,
	[510][4] = 59,
	[510][5] = 59,
	[510][7] = 59,
	[510][8] = 59,
	[510][9] = 59,
	[510][35] = 59,
	[511][2] = 60,
	[511][3] = 60,
	[511][4] = 60,
	[511][5] = 60,
	[511][6] = 60,
	[511][7] = 60,
	[511][8] = 60,
	[511][9] = 60,
	[511][35] = 60,
	[512][2] = 61,
	[512][3] = 61,
	[512][4] = 61,
	[512][5] = 61,
	[512][6] = 61,
	[512][7] = 61,
	[512][8] = 61,
	[512][9] = 61,
	[512][35] = 61,
	[513][2] = 62,
	[513][3] = 62,
	[513][4] = 62,
	[513][5] = 62,
	[513][7] = 62,
	[513][8] = 62,
	[513][9] = 62,
	[513][35] = 62,
	[514][2] = 63,
	[514][3] = 63,
	[514][4] = 63,
	[514][5] = 63,
	[514][7] = 63,
	[514][8] = 63,
	[514][9] = 63,
	[514][35] = 63,
	[515][2] = 98,
	[515][3] = 98,
	[515][4] = 98,
	[515][5] = 98,
	[515][7] = 98,
	[515][8] = 98,
	[515][9] = 98,
	[515][18] = 98,
	[516][2] = 99,
	[516][3] = 99,
	[516][4] = 99,
	[516][5] = 99,
	[516][7] = 99,
	[516][8] = 99,
	[516][9] = 99,
	[516][18] = 99,
	[517][2] = 90,
	[517][3] = 90,
	[517][4] = 90,
	[517][5] = 90,
	[517][7] = 90,
	[517][8] = 90,
	[517][9] = 90,
	[517][32] = 90,
	[517][33] = 90,
	[518][2] = 91,
	[518][3] = 91,
	[518][4] = 91,
	[518][5] = 91,
	[518][7] = 91,
	[518][8] = 91,
	[518][9] = 91,
	[518][32] = 91,
	[518][33] = 91,
	[519][2] = 92,
	[519][3] = 92,
	[519][4] = 92,
	[519][5] = 92,
	[519][7] = 92,
	[519][8] = 92,
	[519][9] = 92,
	[519][32] = 92,
	[519][33] = 92,
	[521][2] = 93,
	[521][3] = 93,
	[521][4] = 93,
	[521][5] = 93,
	[521][7] = 93,
	[521][8] = 93,
	[521][9] = 93,
	[521][32] = 93,
	[521][33] = 93,
	[523][2] = 94,
	[523][3] = 94,
	[523][4] = 94,
	[523][5] = 94,
	[523][6] = 94,
	[523][7] = 94,
	[523][8] = 94,
	[523][9] = 94,
	[523][30] = 94,
	[523][32] = 94,
	[523][33] = 94,
	[524][2] = 95,
	[524][3] = 95,
	[524][4] = 95,
	[524][5] = 95,
	[524][6] = 95,
	[524][7] = 95,
	[524][8] = 95,
	[524][9] = 95,
	[524][30] = 95,
	[524][32] = 95,
	[524][33] = 95,
	[525][2] = 76,
	[525][3] = 76,
	[525][4] = 76,
	[525][5] = 76,
	[525][7] = 76,
	[525][8] = 76,
	[525][9] = 76,
	[525][33] = 76,
	[527][2] = 77,
	[527][3] = 77,
	[527][4] = 77,
	[527][5] = 77,
	[527][7] = 77,
	[527][8] = 77,
	[527][9] = 77,
	[527][33] = 77,
	[528][2] = 78,
	[528][3] = 78,
	[528][4] = 78,
	[528][5] = 78,
	[528][7] = 78,
	[528][8] = 78,
	[528][9] = 78,
	[528][33] = 78,
	[529][2] = 79,
	[529][3] = 79,
	[529][4] = 79,
	[529][5] = 79,
	[529][7] = 79,
	[529][8] = 79,
	[529][9] = 79,
	[529][33] = 79,
	[532][2] = 81,
	[532][3] = 81,
	[532][4] = 81,
	[532][5] = 81,
	[532][6] = 81,
	[532][7] = 81,
	[532][8] = 81,
	[532][9] = 81,
	[532][30] = 81,
	[532][33] = 81,
	[534][2] = 82,
	[534][3] = 82,
	[534][4] = 82,
	[534][5] = 82,
	[534][6] = 82,
	[534][7] = 82,
	[534][8] = 82,
	[534][9] = 82,
	[534][30] = 82,
	[534][33] = 82,
	[536][2] = 64,
	[536][3] = 64,
	[536][4] = 64,
	[536][5] = 64,
	[536][7] = 64,
	[536][8] = 64,
	[536][9] = 64,
	[536][35] = 64,
	[537][2] = 65,
	[537][3] = 65,
	[537][4] = 65,
	[537][5] = 65,
	[537][7] = 65,
	[537][8] = 65,
	[537][9] = 65,
	[537][35] = 65,
	[540][2] = 66,
	[540][3] = 66,
	[540][4] = 66,
	[540][5] = 66,
	[540][7] = 66,
	[540][8] = 66,
	[540][9] = 66,
	[540][35] = 66,
	[543][2] = 67,
	[543][3] = 67,
	[543][4] = 67,
	[543][5] = 67,
	[543][7] = 67,
	[543][8] = 67,
	[543][9] = 67,
	[543][35] = 67,
	[547][2] = 70,
	[547][3] = 70,
	[547][4] = 70,
	[547][5] = 70,
	[547][6] = 70,
	[547][7] = 70,
	[547][8] = 70,
	[547][9] = 70,
	[547][30] = 70,
	[547][35] = 70,
	[548][2] = 71,
	[548][3] = 71,
	[548][4] = 71,
	[548][5] = 71,
	[548][7] = 71,
	[548][8] = 71,
	[548][9] = 71,
	[548][35] = 71,
	[549][2] = 72,
	[549][3] = 72,
	[549][4] = 72,
	[549][5] = 72,
	[549][7] = 72,
	[549][8] = 72,
	[549][9] = 72,
	[549][35] = 72,
	[550][2] = 73,
	[550][3] = 73,
	[550][4] = 73,
	[550][5] = 73,
	[550][6] = 73,
	[550][7] = 73,
	[550][8] = 73,
	[550][9] = 73,
	[550][35] = 73,
	[551][2] = 74,
	[551][3] = 74,
	[551][4] = 74,
	[551][5] = 74,
	[551][7] = 74,
	[551][8] = 74,
	[551][9] = 74,
	[551][35] = 74,
	[552][2] = 100,
	[552][3] = 100,
	[552][4] = 100,
	[552][5] = 100,
	[552][7] = 100,
	[552][8] = 100,
	[552][9] = 100,
	[552][18] = 100,
	[553][2] = 96,
	[553][3] = 96,
	[553][4] = 96,
	[553][5] = 96,
	[553][7] = 96,
	[553][8] = 96,
	[553][9] = 96,
	[553][32] = 96,
	[553][33] = 96,
	[554][2] = 97,
	[554][3] = 97,
	[554][4] = 97,
	[554][5] = 97,
	[554][7] = 97,
	[554][8] = 97,
	[554][9] = 97,
	[554][32] = 97,
	[554][33] = 97,
	[556][2] = 83,
	[556][3] = 83,
	[556][4] = 83,
	[556][5] = 83,
	[556][7] = 83,
	[556][8] = 83,
	[556][9] = 83,
	[556][33] = 83,
	[558][2] = 84,
	[558][3] = 84,
	[558][4] = 84,
	[558][5] = 84,
	[558][7] = 84,
	[558][8] = 84,
	[558][9] = 84,
	[558][33] = 84,
	[559][2] = 85,
	[559][3] = 85,
	[559][4] = 85,
	[559][5] = 85,
	[559][7] = 85,
	[559][8] = 85,
	[559][9] = 85,
	[559][33] = 85,
	[563][2] = 86,
	[563][3] = 86,
	[563][4] = 86,
	[563][5] = 86,
	[563][6] = 86,
	[563][7] = 86,
	[563][8] = 86,
	[563][9] = 86,
	[563][30] = 86,
	[563][33] = 86,
	[564][2] = 87,
	[564][3] = 87,
	[564][4] = 87,
	[564][5] = 87,
	[564][6] = 87,
	[564][7] = 87,
	[564][8] = 87,
	[564][9] = 87,
	[564][30] = 87,
	[564][33] = 87,
	[565][2] = 88,
	[565][3] = 88,
	[565][4] = 88,
	[565][5] = 88,
	[565][6] = 88,
	[565][7] = 88,
	[565][8] = 88,
	[565][9] = 88,
	[565][30] = 88,
	[565][33] = 88,
	[566][2] = 89,
	[566][3] = 89,
	[566][4] = 89,
	[566][5] = 89,
	[566][6] = 89,
	[566][7] = 89,
	[566][8] = 89,
	[566][9] = 89,
	[566][30] = 89,
	[566][33] = 89,
	[567][2] = 76,
	[567][3] = 76,
	[567][4] = 76,
	[567][5] = 76,
	[567][7] = 76,
	[567][8] = 76,
	[567][9] = 76,
	[567][35] = 76,
	[569][2] = 77,
	[569][3] = 77,
	[569][4] = 77,
	[569][5] = 77,
	[569][7] = 77,
	[569][8] = 77,
	[569][9] = 77,
	[569][35] = 77,
	[570][2] = 78,
	[570][3] = 78,
	[570][4] = 78,
	[570][5] = 78,
	[570][7] = 78,
	[570][8] = 78,
	[570][9] = 78,
	[570][35] = 78,
	[571][2] = 79,
	[571][3] = 79,
	[571][4] = 79,
	[571][5] = 79,
	[571][7] = 79,
	[571][8] = 79,
	[571][9] = 79,
	[571][35] = 79,
	[574][2] = 81,
	[574][3] = 81,
	[574][4] = 81,
	[574][5] = 81,
	[574][6] = 81,
	[574][7] = 81,
	[574][8] = 81,
	[574][9] = 81,
	[574][30] = 81,
	[574][35] = 81,
	[576][2] = 82,
	[576][3] = 82,
	[576][4] = 82,
	[576][5] = 82,
	[576][6] = 82,
	[576][7] = 82,
	[576][8] = 82,
	[576][9] = 82,
	[576][30] = 82,
	[576][35] = 82,
	[578][2] = 98,
	[578][3] = 98,
	[578][4] = 98,
	[578][5] = 98,
	[578][7] = 98,
	[578][8] = 98,
	[578][9] = 98,
	[578][32] = 98,
	[578][33] = 98,
	[579][2] = 99,
	[579][3] = 99,
	[579][4] = 99,
	[579][5] = 99,
	[579][7] = 99,
	[579][8] = 99,
	[579][9] = 99,
	[579][32] = 99,
	[579][33] = 99,
	[580][2] = 90,
	[580][3] = 90,
	[580][4] = 90,
	[580][5] = 90,
	[580][7] = 90,
	[580][8] = 90,
	[580][9] = 90,
	[580][33] = 90,
	[581][2] = 91,
	[581][3] = 91,
	[581][4] = 91,
	[581][5] = 91,
	[581][7] = 91,
	[581][8] = 91,
	[581][9] = 91,
	[581][33] = 91,
	[582][2] = 92,
	[582][3] = 92,
	[582][4] = 92,
	[582][5] = 92,
	[582][7] = 92,
	[582][8] = 92,
	[582][9] = 92,
	[582][33] = 92,
	[584][2] = 93,
	[584][3] = 93,
	[584][4] = 93,
	[584][5] = 93,
	[584][7] = 93,
	[584][8] = 93,
	[584][9] = 93,
	[584][33] = 93,
	[586][2] = 94,
	[586][3] = 94,
	[586][4] = 94,
	[586][5] = 94,
	[586][6] = 94,
	[586][7] = 94,
	[586][8] = 94,
	[586][9] = 94,
	[586][30] = 94,
	[586][33] = 94,
	[587][2] = 95,
	[587][3] = 95,
	[587][4] = 95,
	[587][5] = 95,
	[587][6] = 95,
	[587][7] = 95,
	[587][8] = 95,
	[587][9] = 95,
	[587][30] = 95,
	[587][33] = 95,
	[589][2] = 83,
	[589][3] = 83,
	[589][4] = 83,
	[589][5] = 83,
	[589][7] = 83,
	[589][8] = 83,
	[589][9] = 83,
	[589][35] = 83,
	[591][2] = 84,
	[591][3] = 84,
	[591][4] = 84,
	[591][5] = 84,
	[591][7] = 84,
	[591][8] = 84,
	[591][9] = 84,
	[591][35] = 84,
	[592][2] = 85,
	[592][3] = 85,
	[592][4] = 85,
	[592][5] = 85,
	[592][7] = 85,
	[592][8] = 85,
	[592][9] = 85,
	[592][35] = 85,
	[596][2] = 86,
	[596][3] = 86,
	[596][4] = 86,
	[596][5] = 86,
	[596][6] = 86,
	[596][7] = 86,
	[596][8] = 86,
	[596][9] = 86,
	[596][30] = 86,
	[596][35] = 86,
	[597][2] = 87,
	[597][3] = 87,
	[597][4] = 87,
	[597][5] = 87,
	[597][6] = 87,
	[597][7] = 87,
	[597][8] = 87,
	[597][9] = 87,
	[597][30] = 87,
	[597][35] = 87,
	[598][2] = 88,
	[598][3] = 88,
	[598][4] = 88,
	[598][5] = 88,
	[598][6] = 88,
	[598][7] = 88,
	[598][8] = 88,
	[598][9] = 88,
	[598][30] = 88,
	[598][35] = 88,
	[599][2] = 89,
	[599][3] = 89,
	[599][4] = 89,
	[599][5] = 89,
	[599][6] = 89,
	[599][7] = 89,
	[599][8] = 89,
	[599][9] = 89,
	[599][30] = 89,
	[599][35] = 89,
	[600][2] = 100,
	[600][3] = 100,
	[600][4] = 100,
	[600][5] = 100,
	[600][7] = 100,
	[600][8] = 100,
	[600][9] = 100,
	[600][32] = 100,
	[600][33] = 100,
	[601][2] = 96,
	[601][3] = 96,
	[601][4] = 96,
	[601][5] = 96,
	[601][7] = 96,
	[601][8] = 96,
	[601][9] = 96,
	[601][33] = 96,
	[602][2] = 97,
	[602][3] = 97,
	[602][4] = 97,
	[602][5] = 97,
	[602][7] = 97,
	[602][8] = 97,
	[602][9] = 97,
	[602][33] = 97,
	[603][2] = 90,
	[603][3] = 90,
	[603][4] = 90,
	[603][5] = 90,
	[603][7] = 90,
	[603][8] = 90,
	[603][9] = 90,
	[603][35] = 90,
	[604][2] = 91,
	[604][3] = 91,
	[604][4] = 91,
	[604][5] = 91,
	[604][7] = 91,
	[604][8] = 91,
	[604][9] = 91,
	[604][35] = 91,
	[605][2] = 92,
	[605][3] = 92,
	[605][4] = 92,
	[605][5] = 92,
	[605][7] = 92,
	[605][8] = 92,
	[605][9] = 92,
	[605][35] = 92,
	[607][2] = 93,
	[607][3] = 93,
	[607][4] = 93,
	[607][5] = 93,
	[607][7] = 93,
	[607][8] = 93,
	[607][9] = 93,
	[607][35] = 93,
	[609][2] = 94,
	[609][3] = 94,
	[609][4] = 94,
	[609][5] = 94,
	[609][6] = 94,
	[609][7] = 94,
	[609][8] = 94,
	[609][9] = 94,
	[609][30] = 94,
	[609][35] = 94,
	[610][2] = 95,
	[610][3] = 95,
	[610][4] = 95,
	[610][5] = 95,
	[610][6] = 95,
	[610][7] = 95,
	[610][8] = 95,
	[610][9] = 95,
	[610][30] = 95,
	[610][35] = 95,
	[611][2] = 98,
	[611][3] = 98,
	[611][4] = 98,
	[611][5] = 98,
	[611][7] = 98,
	[611][8] = 98,
	[611][9] = 98,
	[611][33] = 98,
	[612][2] = 99,
	[612][3] = 99,
	[612][4] = 99,
	[612][5] = 99,
	[612][7] = 99,
	[612][8] = 99,
	[612][9] = 99,
	[612][33] = 99,
	[613][2] = 96,
	[613][3] = 96,
	[613][4] = 96,
	[613][5] = 96,
	[613][7] = 96,
	[613][8] = 96,
	[613][9] = 96,
	[613][35] = 96,
	[614][2] = 97,
	[614][3] = 97,
	[614][4] = 97,
	[614][5] = 97,
	[614][7] = 97,
	[614][8] = 97,
	[614][9] = 97,
	[614][35] = 97,
	[615][2] = 100,
	[615][3] = 100,
	[615][4] = 100,
	[615][5] = 100,
	[615][7] = 100,
	[615][8] = 100,
	[615][9] = 100,
	[615][33] = 100,
	[616][2] = 98,
	[616][3] = 98,
	[616][4] = 98,
	[616][5] = 98,
	[616][7] = 98,
	[616][8] = 98,
	[616][9] = 98,
	[616][35] = 98,
	[617][2] = 99,
	[617][3] = 99,
	[617][4] = 99,
	[617][5] = 99,
	[617][7] = 99,
	[617][8] = 99,
	[617][9] = 99,
	[617][35] = 99,
	[618][2] = 100,
	[618][3] = 100,
	[618][4] = 100,
	[618][5] = 100,
	[618][7] = 100,
	[618][8] = 100,
	[618][9] = 100,
	[618][35] = 100,
};


const unsigned zebu_gotos[617][43] = {
	[1][1] = 10,
	[1][2] = 11,
	[1][3] = 12,
	[1][4] = 13,
	[1][5] = 14,
	[1][6] = 15,
	[1][7] = 16,
	[1][8] = 17,
	[2][9] = 25,
	[2][10] = 26,
	[2][11] = 27,
	[2][12] = 28,
	[2][13] = 29,
	[2][14] = 30,
	[2][15] = 31,
	[2][16] = 32,
	[6][1] = 10,
	[6][2] = 11,
	[6][3] = 12,
	[6][4] = 13,
	[6][5] = 14,
	[6][6] = 15,
	[6][7] = 35,
	[6][8] = 17,
	[7][9] = 43,
	[7][10] = 44,
	[7][11] = 45,
	[7][12] = 46,
	[7][13] = 47,
	[7][14] = 48,
	[7][15] = 49,
	[7][16] = 50,
	[9][1] = 55,
	[17][1] = 10,
	[17][2] = 11,
	[17][3] = 12,
	[17][4] = 13,
	[17][5] = 14,
	[17][6] = 15,
	[17][8] = 58,
	[17][17] = 57,
	[18][9] = 25,
	[18][10] = 26,
	[18][11] = 59,
	[18][12] = 28,
	[18][13] = 29,
	[18][14] = 30,
	[18][15] = 31,
	[18][16] = 32,
	[20][9] = 68,
	[20][10] = 69,
	[20][11] = 70,
	[20][12] = 71,
	[20][13] = 72,
	[20][14] = 73,
	[20][15] = 74,
	[20][16] = 75,
	[23][13] = 29,
	[23][14] = 77,
	[23][15] = 31,
	[23][18] = 76,
	[24][13] = 29,
	[24][14] = 77,
	[24][15] = 31,
	[24][18] = 78,
	[33][9] = 98,
	[33][10] = 99,
	[33][11] = 100,
	[33][12] = 101,
	[33][13] = 102,
	[33][14] = 103,
	[33][15] = 104,
	[33][16] = 105,
	[33][19] = 97,
	[34][9] = 98,
	[34][10] = 99,
	[34][11] = 100,
	[34][12] = 101,
	[34][13] = 102,
	[34][14] = 103,
	[34][15] = 104,
	[34][16] = 105,
	[34][19] = 106,
	[36][9] = 25,
	[36][10] = 26,
	[36][11] = 107,
	[36][12] = 28,
	[36][13] = 29,
	[36][14] = 30,
	[36][15] = 31,
	[36][16] = 32,
	[38][9] = 68,
	[38][10] = 69,
	[38][11] = 109,
	[38][12] = 71,
	[38][13] = 72,
	[38][14] = 73,
	[38][15] = 74,
	[38][16] = 75,
	[41][13] = 47,
	[41][14] = 111,
	[41][15] = 49,
	[41][18] = 110,
	[42][13] = 47,
	[42][14] = 111,
	[42][15] = 49,
	[42][18] = 112,
	[52][9] = 25,
	[52][10] = 26,
	[52][11] = 125,
	[52][12] = 28,
	[52][13] = 29,
	[52][14] = 30,
	[52][15] = 31,
	[52][16] = 32,
	[56][1] = 133,
	[56][20] = 132,
	[56][21] = 134,
	[56][22] = 135,
	[58][1] = 10,
	[58][2] = 11,
	[58][3] = 12,
	[58][4] = 13,
	[58][5] = 14,
	[58][6] = 15,
	[58][8] = 58,
	[58][17] = 136,
	[60][9] = 25,
	[60][10] = 26,
	[60][11] = 138,
	[60][12] = 28,
	[60][13] = 29,
	[60][14] = 30,
	[60][15] = 31,
	[60][16] = 32,
	[62][9] = 68,
	[62][10] = 69,
	[62][11] = 140,
	[62][12] = 71,
	[62][13] = 72,
	[62][14] = 73,
	[62][15] = 74,
	[62][16] = 75,
	[66][13] = 72,
	[66][14] = 142,
	[66][15] = 74,
	[66][18] = 141,
	[67][13] = 72,
	[67][14] = 142,
	[67][15] = 74,
	[67][18] = 143,
	[70][23] = 150,
	[79][12] = 158,
	[79][13] = 29,
	[79][14] = 30,
	[79][15] = 31,
	[79][24] = 157,
	[80][12] = 158,
	[80][13] = 29,
	[80][14] = 30,
	[80][15] = 31,
	[80][24] = 159,
	[81][9] = 25,
	[81][12] = 28,
	[81][13] = 29,
	[81][14] = 30,
	[81][15] = 31,
	[81][16] = 161,
	[81][25] = 160,
	[82][9] = 25,
	[82][12] = 28,
	[82][13] = 29,
	[82][14] = 30,
	[82][15] = 31,
	[82][16] = 161,
	[82][25] = 162,
	[84][13] = 29,
	[84][14] = 164,
	[84][15] = 31,
	[84][26] = 163,
	[85][13] = 29,
	[85][14] = 164,
	[85][15] = 31,
	[85][26] = 165,
	[86][9] = 167,
	[86][12] = 28,
	[86][13] = 29,
	[86][14] = 30,
	[86][15] = 31,
	[86][27] = 166,
	[87][9] = 167,
	[87][12] = 28,
	[87][13] = 29,
	[87][14] = 30,
	[87][15] = 31,
	[87][27] = 168,
	[88][9] = 167,
	[88][12] = 28,
	[88][13] = 29,
	[88][14] = 30,
	[88][15] = 31,
	[88][27] = 169,
	[89][9] = 167,
	[89][12] = 28,
	[89][13] = 29,
	[89][14] = 30,
	[89][15] = 31,
	[89][27] = 170,
	[90][9] = 25,
	[90][10] = 26,
	[90][11] = 171,
	[90][12] = 28,
	[90][13] = 29,
	[90][14] = 30,
	[90][15] = 31,
	[90][16] = 32,
	[92][9] = 68,
	[92][10] = 69,
	[92][11] = 173,
	[92][12] = 71,
	[92][13] = 72,
	[92][14] = 73,
	[92][15] = 74,
	[92][16] = 75,
	[95][13] = 102,
	[95][14] = 175,
	[95][15] = 104,
	[95][18] = 174,
	[96][13] = 102,
	[96][14] = 175,
	[96][15] = 104,
	[96][18] = 176,
	[109][23] = 191,
	[113][12] = 193,
	[113][13] = 47,
	[113][14] = 48,
	[113][15] = 49,
	[113][24] = 192,
	[114][12] = 193,
	[114][13] = 47,
	[114][14] = 48,
	[114][15] = 49,
	[114][24] = 194,
	[115][9] = 43,
	[115][12] = 46,
	[115][13] = 47,
	[115][14] = 48,
	[115][15] = 49,
	[115][16] = 196,
	[115][25] = 195,
	[116][9] = 43,
	[116][12] = 46,
	[116][13] = 47,
	[116][14] = 48,
	[116][15] = 49,
	[116][16] = 196,
	[116][25] = 197,
	[117][1] = 202,
	[117][2] = 203,
	[117][3] = 204,
	[117][4] = 205,
	[117][5] = 206,
	[117][6] = 207,
	[117][8] = 208,
	[118][13] = 47,
	[118][14] = 210,
	[118][15] = 49,
	[118][26] = 209,
	[119][13] = 47,
	[119][14] = 210,
	[119][15] = 49,
	[119][26] = 211,
	[120][9] = 213,
	[120][12] = 46,
	[120][13] = 47,
	[120][14] = 48,
	[120][15] = 49,
	[120][27] = 212,
	[121][9] = 213,
	[121][12] = 46,
	[121][13] = 47,
	[121][14] = 48,
	[121][15] = 49,
	[121][27] = 214,
	[122][9] = 213,
	[122][12] = 46,
	[122][13] = 47,
	[122][14] = 48,
	[122][15] = 49,
	[122][27] = 215,
	[123][9] = 213,
	[123][12] = 46,
	[123][13] = 47,
	[123][14] = 48,
	[123][15] = 49,
	[123][27] = 216,
	[124][9] = 43,
	[124][10] = 44,
	[124][11] = 217,
	[124][12] = 46,
	[124][13] = 47,
	[124][14] = 48,
	[124][15] = 49,
	[124][16] = 50,
	[126][28] = 220,
	[127][9] = 25,
	[127][10] = 26,
	[127][11] = 221,
	[127][12] = 28,
	[127][13] = 29,
	[127][14] = 30,
	[127][15] = 31,
	[127][16] = 32,
	[130][1] = 225,
	[130][29] = 226,
	[131][21] = 134,
	[131][22] = 228,
	[133][1] = 133,
	[133][20] = 229,
	[133][21] = 134,
	[133][22] = 135,
	[134][21] = 231,
	[134][30] = 230,
	[135][31] = 233,
	[140][23] = 237,
	[144][12] = 239,
	[144][13] = 72,
	[144][14] = 73,
	[144][15] = 74,
	[144][24] = 238,
	[145][12] = 239,
	[145][13] = 72,
	[145][14] = 73,
	[145][15] = 74,
	[145][24] = 240,
	[146][9] = 68,
	[146][12] = 71,
	[146][13] = 72,
	[146][14] = 73,
	[146][15] = 74,
	[146][16] = 242,
	[146][25] = 241,
	[147][9] = 68,
	[147][12] = 71,
	[147][13] = 72,
	[147][14] = 73,
	[147][15] = 74,
	[147][16] = 242,
	[147][25] = 243,
	[148][9] = 68,
	[148][10] = 69,
	[148][11] = 244,
	[148][12] = 71,
	[148][13] = 72,
	[148][14] = 73,
	[148][15] = 74,
	[148][16] = 75,
	[151][13] = 72,
	[151][14] = 246,
	[151][15] = 74,
	[151][26] = 245,
	[152][13] = 72,
	[152][14] = 246,
	[152][15] = 74,
	[152][26] = 247,
	[153][9] = 249,
	[153][12] = 71,
	[153][13] = 72,
	[153][14] = 73,
	[153][15] = 74,
	[153][27] = 248,
	[154][9] = 249,
	[154][12] = 71,
	[154][13] = 72,
	[154][14] = 73,
	[154][15] = 74,
	[154][27] = 250,
	[155][9] = 249,
	[155][12] = 71,
	[155][13] = 72,
	[155][14] = 73,
	[155][15] = 74,
	[155][27] = 251,
	[156][9] = 249,
	[156][12] = 71,
	[156][13] = 72,
	[156][14] = 73,
	[156][15] = 74,
	[156][27] = 252,
	[173][23] = 256,
	[177][12] = 258,
	[177][13] = 102,
	[177][14] = 103,
	[177][15] = 104,
	[177][24] = 257,
	[178][12] = 258,
	[178][13] = 102,
	[178][14] = 103,
	[178][15] = 104,
	[178][24] = 259,
	[179][9] = 98,
	[179][12] = 101,
	[179][13] = 102,
	[179][14] = 103,
	[179][15] = 104,
	[179][16] = 261,
	[179][25] = 260,
	[180][9] = 98,
	[180][12] = 101,
	[180][13] = 102,
	[180][14] = 103,
	[180][15] = 104,
	[180][16] = 261,
	[180][25] = 262,
	[181][32] = 264,
	[182][13] = 102,
	[182][14] = 266,
	[182][15] = 104,
	[182][26] = 265,
	[183][13] = 102,
	[183][14] = 266,
	[183][15] = 104,
	[183][26] = 267,
	[184][9] = 269,
	[184][12] = 101,
	[184][13] = 102,
	[184][14] = 103,
	[184][15] = 104,
	[184][27] = 268,
	[185][9] = 269,
	[185][12] = 101,
	[185][13] = 102,
	[185][14] = 103,
	[185][15] = 104,
	[185][27] = 270,
	[186][9] = 269,
	[186][12] = 101,
	[186][13] = 102,
	[186][14] = 103,
	[186][15] = 104,
	[186][27] = 271,
	[187][9] = 269,
	[187][12] = 101,
	[187][13] = 102,
	[187][14] = 103,
	[187][15] = 104,
	[187][27] = 272,
	[189][9] = 68,
	[189][10] = 69,
	[189][11] = 273,
	[189][12] = 71,
	[189][13] = 72,
	[189][14] = 73,
	[189][15] = 74,
	[189][16] = 75,
	[199][9] = 43,
	[199][10] = 44,
	[199][11] = 276,
	[199][12] = 46,
	[199][13] = 47,
	[199][14] = 48,
	[199][15] = 49,
	[199][16] = 50,
	[201][1] = 278,
	[208][1] = 202,
	[208][2] = 203,
	[208][3] = 204,
	[208][4] = 205,
	[208][5] = 206,
	[208][6] = 207,
	[208][8] = 283,
	[208][33] = 282,
	[219][28] = 285,
	[222][9] = 25,
	[222][10] = 26,
	[222][11] = 287,
	[222][12] = 28,
	[222][13] = 29,
	[222][14] = 30,
	[222][15] = 31,
	[222][16] = 32,
	[225][1] = 289,
	[225][34] = 288,
	[227][31] = 294,
	[228][31] = 295,
	[231][21] = 231,
	[231][30] = 296,
	[232][31] = 297,
	[235][9] = 68,
	[235][10] = 69,
	[235][11] = 298,
	[235][12] = 71,
	[235][13] = 72,
	[235][14] = 73,
	[235][15] = 74,
	[235][16] = 75,
	[244][23] = 299,
	[254][9] = 68,
	[254][10] = 69,
	[254][11] = 300,
	[254][12] = 71,
	[254][13] = 72,
	[254][14] = 73,
	[254][15] = 74,
	[254][16] = 75,
	[263][32] = 301,
	[273][23] = 302,
	[274][9] = 98,
	[274][10] = 99,
	[274][11] = 304,
	[274][12] = 101,
	[274][13] = 102,
	[274][14] = 103,
	[274][15] = 104,
	[274][16] = 105,
	[274][19] = 303,
	[275][9] = 98,
	[275][10] = 99,
	[275][11] = 304,
	[275][12] = 101,
	[275][13] = 102,
	[275][14] = 103,
	[275][15] = 104,
	[275][16] = 105,
	[275][19] = 305,
	[279][1] = 312,
	[279][20] = 311,
	[279][21] = 313,
	[279][22] = 314,
	[280][1] = 319,
	[280][2] = 320,
	[280][3] = 321,
	[280][4] = 322,
	[280][5] = 323,
	[280][6] = 324,
	[280][8] = 325,
	[281][35] = 327,
	[283][1] = 202,
	[283][2] = 203,
	[283][3] = 204,
	[283][4] = 205,
	[283][5] = 206,
	[283][6] = 207,
	[283][8] = 283,
	[283][33] = 328,
	[289][1] = 289,
	[289][34] = 331,
	[290][1] = 335,
	[291][1] = 340,
	[291][29] = 341,
	[291][36] = 339,
	[292][1] = 343,
	[292][37] = 342,
	[298][23] = 344,
	[300][23] = 345,
	[306][1] = 202,
	[306][2] = 203,
	[306][3] = 204,
	[306][4] = 205,
	[306][5] = 206,
	[306][6] = 207,
	[306][8] = 347,
	[307][9] = 43,
	[307][10] = 44,
	[307][11] = 348,
	[307][12] = 46,
	[307][13] = 47,
	[307][14] = 48,
	[307][15] = 49,
	[307][16] = 50,
	[308][28] = 350,
	[309][1] = 225,
	[309][29] = 351,
	[310][21] = 313,
	[310][22] = 353,
	[312][1] = 312,
	[312][20] = 354,
	[312][21] = 313,
	[312][22] = 314,
	[313][21] = 356,
	[313][30] = 355,
	[314][31] = 358,
	[316][9] = 43,
	[316][10] = 44,
	[316][11] = 361,
	[316][12] = 46,
	[316][13] = 47,
	[316][14] = 48,
	[316][15] = 49,
	[316][16] = 50,
	[318][1] = 363,
	[325][1] = 319,
	[325][2] = 320,
	[325][3] = 321,
	[325][4] = 322,
	[325][5] = 323,
	[325][6] = 324,
	[325][8] = 367,
	[325][38] = 366,
	[326][39] = 369,
	[329][1] = 374,
	[329][2] = 375,
	[329][3] = 376,
	[329][4] = 377,
	[329][5] = 378,
	[329][6] = 379,
	[329][8] = 380,
	[332][9] = 25,
	[332][10] = 26,
	[332][11] = 381,
	[332][12] = 28,
	[332][13] = 29,
	[332][14] = 30,
	[332][15] = 31,
	[332][16] = 32,
	[335][40] = 385,
	[336][9] = 25,
	[336][10] = 26,
	[336][11] = 386,
	[336][12] = 28,
	[336][13] = 29,
	[336][14] = 30,
	[336][15] = 31,
	[336][16] = 32,
	[340][1] = 388,
	[340][34] = 387,
	[341][40] = 389,
	[346][32] = 392,
	[347][1] = 202,
	[347][2] = 203,
	[347][3] = 204,
	[347][4] = 205,
	[347][5] = 206,
	[347][6] = 207,
	[347][8] = 396,
	[347][33] = 395,
	[349][28] = 398,
	[352][31] = 403,
	[353][31] = 404,
	[356][21] = 356,
	[356][30] = 405,
	[357][31] = 406,
	[359][9] = 98,
	[359][10] = 99,
	[359][11] = 408,
	[359][12] = 101,
	[359][13] = 102,
	[359][14] = 103,
	[359][15] = 104,
	[359][16] = 105,
	[359][19] = 407,
	[360][9] = 98,
	[360][10] = 99,
	[360][11] = 408,
	[360][12] = 101,
	[360][13] = 102,
	[360][14] = 103,
	[360][15] = 104,
	[360][16] = 105,
	[360][19] = 409,
	[364][1] = 416,
	[364][20] = 415,
	[364][21] = 417,
	[364][22] = 418,
	[365][35] = 419,
	[367][1] = 319,
	[367][2] = 320,
	[367][3] = 321,
	[367][4] = 322,
	[367][5] = 323,
	[367][6] = 324,
	[367][8] = 367,
	[367][38] = 420,
	[368][39] = 421,
	[371][9] = 43,
	[371][10] = 44,
	[371][11] = 424,
	[371][12] = 46,
	[371][13] = 47,
	[371][14] = 48,
	[371][15] = 49,
	[371][16] = 50,
	[373][1] = 426,
	[380][1] = 374,
	[380][2] = 375,
	[380][3] = 376,
	[380][4] = 377,
	[380][5] = 378,
	[380][6] = 379,
	[380][8] = 430,
	[380][41] = 429,
	[382][1] = 340,
	[382][29] = 341,
	[382][36] = 432,
	[383][1] = 343,
	[383][37] = 433,
	[388][1] = 388,
	[388][34] = 435,
	[391][32] = 436,
	[393][1] = 319,
	[393][2] = 320,
	[393][3] = 321,
	[393][4] = 322,
	[393][5] = 323,
	[393][6] = 324,
	[393][8] = 437,
	[394][35] = 439,
	[396][1] = 202,
	[396][2] = 203,
	[396][3] = 204,
	[396][4] = 205,
	[396][5] = 206,
	[396][6] = 207,
	[396][8] = 396,
	[396][33] = 440,
	[399][1] = 442,
	[400][1] = 340,
	[400][29] = 444,
	[400][36] = 443,
	[401][1] = 446,
	[401][37] = 445,
	[410][1] = 202,
	[410][2] = 203,
	[410][3] = 204,
	[410][4] = 205,
	[410][5] = 206,
	[410][6] = 207,
	[410][8] = 448,
	[411][9] = 43,
	[411][10] = 44,
	[411][11] = 449,
	[411][12] = 46,
	[411][13] = 47,
	[411][14] = 48,
	[411][15] = 49,
	[411][16] = 50,
	[412][28] = 451,
	[413][1] = 225,
	[413][29] = 452,
	[414][21] = 417,
	[414][22] = 454,
	[416][1] = 416,
	[416][20] = 455,
	[416][21] = 417,
	[416][22] = 418,
	[417][21] = 457,
	[417][30] = 456,
	[418][31] = 459,
	[422][9] = 98,
	[422][10] = 99,
	[422][11] = 461,
	[422][12] = 101,
	[422][13] = 102,
	[422][14] = 103,
	[422][15] = 104,
	[422][16] = 105,
	[422][19] = 460,
	[423][9] = 98,
	[423][10] = 99,
	[423][11] = 461,
	[423][12] = 101,
	[423][13] = 102,
	[423][14] = 103,
	[423][15] = 104,
	[423][16] = 105,
	[423][19] = 462,
	[427][1] = 469,
	[427][20] = 468,
	[427][21] = 470,
	[427][22] = 471,
	[430][1] = 374,
	[430][2] = 375,
	[430][3] = 376,
	[430][4] = 377,
	[430][5] = 378,
	[430][6] = 379,
	[430][8] = 430,
	[430][41] = 473,
	[437][1] = 319,
	[437][2] = 320,
	[437][3] = 321,
	[437][4] = 322,
	[437][5] = 323,
	[437][6] = 324,
	[437][8] = 476,
	[437][38] = 475,
	[438][39] = 478,
	[441][1] = 374,
	[441][2] = 375,
	[441][3] = 376,
	[441][4] = 377,
	[441][5] = 378,
	[441][6] = 379,
	[441][8] = 479,
	[442][40] = 483,
	[444][40] = 484,
	[447][32] = 487,
	[448][1] = 202,
	[448][2] = 203,
	[448][3] = 204,
	[448][4] = 205,
	[448][5] = 206,
	[448][6] = 207,
	[448][8] = 491,
	[448][33] = 490,
	[450][28] = 493,
	[453][31] = 498,
	[454][31] = 499,
	[457][21] = 457,
	[457][30] = 500,
	[458][31] = 501,
	[463][1] = 202,
	[463][2] = 203,
	[463][3] = 204,
	[463][4] = 205,
	[463][5] = 206,
	[463][6] = 207,
	[463][8] = 503,
	[464][9] = 43,
	[464][10] = 44,
	[464][11] = 504,
	[464][12] = 46,
	[464][13] = 47,
	[464][14] = 48,
	[464][15] = 49,
	[464][16] = 50,
	[465][28] = 506,
	[466][1] = 225,
	[466][29] = 507,
	[467][21] = 470,
	[467][22] = 509,
	[469][1] = 469,
	[469][20] = 510,
	[469][21] = 470,
	[469][22] = 471,
	[470][21] = 512,
	[470][30] = 511,
	[471][31] = 514,
	[472][42] = 516,
	[474][35] = 517,
	[476][1] = 319,
	[476][2] = 320,
	[476][3] = 321,
	[476][4] = 322,
	[476][5] = 323,
	[476][6] = 324,
	[476][8] = 476,
	[476][38] = 518,
	[477][39] = 519,
	[479][1] = 374,
	[479][2] = 375,
	[479][3] = 376,
	[479][4] = 377,
	[479][5] = 378,
	[479][6] = 379,
	[479][8] = 522,
	[479][41] = 521,
	[480][1] = 340,
	[480][29] = 444,
	[480][36] = 523,
	[481][1] = 446,
	[481][37] = 524,
	[486][32] = 525,
	[488][1] = 319,
	[488][2] = 320,
	[488][3] = 321,
	[488][4] = 322,
	[488][5] = 323,
	[488][6] = 324,
	[488][8] = 526,
	[489][35] = 528,
	[491][1] = 202,
	[491][2] = 203,
	[491][3] = 204,
	[491][4] = 205,
	[491][5] = 206,
	[491][6] = 207,
	[491][8] = 491,
	[491][33] = 529,
	[494][1] = 531,
	[495][1] = 340,
	[495][29] = 533,
	[495][36] = 532,
	[496][1] = 535,
	[496][37] = 534,
	[502][32] = 537,
	[503][1] = 202,
	[503][2] = 203,
	[503][3] = 204,
	[503][4] = 205,
	[503][5] = 206,
	[503][6] = 207,
	[503][8] = 541,
	[503][33] = 540,
	[505][28] = 543,
	[508][31] = 548,
	[509][31] = 549,
	[512][21] = 512,
	[512][30] = 550,
	[513][31] = 551,
	[515][42] = 552,
	[522][1] = 374,
	[522][2] = 375,
	[522][3] = 376,
	[522][4] = 377,
	[522][5] = 378,
	[522][6] = 379,
	[522][8] = 522,
	[522][41] = 554,
	[526][1] = 319,
	[526][2] = 320,
	[526][3] = 321,
	[526][4] = 322,
	[526][5] = 323,
	[526][6] = 324,
	[526][8] = 557,
	[526][38] = 556,
	[527][39] = 559,
	[530][1] = 374,
	[530][2] = 375,
	[530][3] = 376,
	[530][4] = 377,
	[530][5] = 378,
	[530][6] = 379,
	[530][8] = 560,
	[531][40] = 564,
	[533][40] = 565,
	[536][32] = 567,
	[538][1] = 319,
	[538][2] = 320,
	[538][3] = 321,
	[538][4] = 322,
	[538][5] = 323,
	[538][6] = 324,
	[538][8] = 568,
	[539][35] = 570,
	[541][1] = 202,
	[541][2] = 203,
	[541][3] = 204,
	[541][4] = 205,
	[541][5] = 206,
	[541][6] = 207,
	[541][8] = 541,
	[541][33] = 571,
	[544][1] = 573,
	[545][1] = 340,
	[545][29] = 575,
	[545][36] = 574,
	[546][1] = 577,
	[546][37] = 576,
	[553][42] = 579,
	[555][35] = 580,
	[557][1] = 319,
	[557][2] = 320,
	[557][3] = 321,
	[557][4] = 322,
	[557][5] = 323,
	[557][6] = 324,
	[557][8] = 557,
	[557][38] = 581,
	[558][39] = 582,
	[560][1] = 374,
	[560][2] = 375,
	[560][3] = 376,
	[560][4] = 377,
	[560][5] = 378,
	[560][6] = 379,
	[560][8] = 585,
	[560][41] = 584,
	[561][1] = 340,
	[561][29] = 533,
	[561][36] = 586,
	[562][1] = 535,
	[562][37] = 587,
	[568][1] = 319,
	[568][2] = 320,
	[568][3] = 321,
	[568][4] = 322,
	[568][5] = 323,
	[568][6] = 324,
	[568][8] = 590,
	[568][38] = 589,
	[569][39] = 592,
	[572][1] = 374,
	[572][2] = 375,
	[572][3] = 376,
	[572][4] = 377,
	[572][5] = 378,
	[572][6] = 379,
	[572][8] = 593,
	[573][40] = 597,
	[575][40] = 598,
	[578][42] = 600,
	[585][1] = 374,
	[585][2] = 375,
	[585][3] = 376,
	[585][4] = 377,
	[585][5] = 378,
	[585][6] = 379,
	[585][8] = 585,
	[585][41] = 602,
	[588][35] = 603,
	[590][1] = 319,
	[590][2] = 320,
	[590][3] = 321,
	[590][4] = 322,
	[590][5] = 323,
	[590][6] = 324,
	[590][8] = 590,
	[590][38] = 604,
	[591][39] = 605,
	[593][1] = 374,
	[593][2] = 375,
	[593][3] = 376,
	[593][4] = 377,
	[593][5] = 378,
	[593][6] = 379,
	[593][8] = 608,
	[593][41] = 607,
	[594][1] = 340,
	[594][29] = 575,
	[594][36] = 609,
	[595][1] = 577,
	[595][37] = 610,
	[601][42] = 612,
	[608][1] = 374,
	[608][2] = 375,
	[608][3] = 376,
	[608][4] = 377,
	[608][5] = 378,
	[608][6] = 379,
	[608][8] = 608,
	[608][41] = 614,
	[611][42] = 615,
	[613][42] = 617,
	[616][42] = 618,
};


const unsigned zebu_lexer_starts[619] = {
	[1] = 1,
	[2] = 2,
	[3] = 3,
	[4] = 3,
	[5] = 4,
	[6] = 1,
	[7] = 2,
	[8] = 5,
	[9] = 6,
	[10] = 3,
	[11] = 7,
	[12] = 7,
	[13] = 7,
	[14] = 7,
	[15] = 7,
	[16] = 8,
	[17] = 7,
	[18] = 2,
	[19] = 9,
	[20] = 10,
	[21] = 9,
	[22] = 9,
	[23] = 2,
	[24] = 2,
	[25] = 11,
	[26] = 12,
	[27] = 13,
	[28] = 9,
	[29] = 9,
	[30] = 9,
	[31] = 9,
	[32] = 14,
	[33] = 2,
	[34] = 2,
	[35] = 8,
	[36] = 2,
	[37] = 15,
	[38] = 10,
	[39] = 15,
	[40] = 15,
	[41] = 2,
	[42] = 2,
	[43] = 16,
	[44] = 17,
	[45] = 3,
	[46] = 15,
	[47] = 15,
	[48] = 15,
	[49] = 15,
	[50] = 18,
	[51] = 19,
	[52] = 2,
	[53] = 20,
	[54] = 20,
	[55] = 20,
	[56] = 21,
	[57] = 8,
	[58] = 7,
	[59] = 13,
	[60] = 2,
	[61] = 22,
	[62] = 10,
	[63] = 9,
	[64] = 22,
	[65] = 22,
	[66] = 2,
	[67] = 2,
	[68] = 23,
	[69] = 24,
	[70] = 25,
	[71] = 22,
	[72] = 22,
	[73] = 22,
	[74] = 22,
	[75] = 26,
	[76] = 9,
	[77] = 9,
	[78] = 9,
	[79] = 2,
	[80] = 2,
	[81] = 2,
	[82] = 2,
	[83] = 3,
	[84] = 2,
	[85] = 2,
	[86] = 2,
	[87] = 2,
	[88] = 2,
	[89] = 2,
	[90] = 2,
	[91] = 27,
	[92] = 10,
	[93] = 27,
	[94] = 27,
	[95] = 2,
	[96] = 2,
	[97] = 7,
	[98] = 28,
	[99] = 29,
	[100] = 20,
	[101] = 27,
	[102] = 27,
	[103] = 27,
	[104] = 27,
	[105] = 30,
	[106] = 7,
	[107] = 13,
	[108] = 15,
	[109] = 25,
	[110] = 15,
	[111] = 15,
	[112] = 15,
	[113] = 2,
	[114] = 2,
	[115] = 2,
	[116] = 2,
	[117] = 31,
	[118] = 2,
	[119] = 2,
	[120] = 2,
	[121] = 2,
	[122] = 2,
	[123] = 2,
	[124] = 2,
	[125] = 13,
	[126] = 32,
	[127] = 2,
	[128] = 21,
	[129] = 21,
	[130] = 6,
	[131] = 33,
	[132] = 7,
	[133] = 21,
	[134] = 33,
	[135] = 32,
	[136] = 8,
	[137] = 9,
	[138] = 13,
	[139] = 22,
	[140] = 25,
	[141] = 22,
	[142] = 22,
	[143] = 22,
	[144] = 2,
	[145] = 2,
	[146] = 2,
	[147] = 2,
	[148] = 2,
	[149] = 9,
	[150] = 9,
	[151] = 2,
	[152] = 2,
	[153] = 2,
	[154] = 2,
	[155] = 2,
	[156] = 2,
	[157] = 11,
	[158] = 9,
	[159] = 11,
	[160] = 12,
	[161] = 14,
	[162] = 12,
	[163] = 9,
	[164] = 9,
	[165] = 9,
	[166] = 14,
	[167] = 11,
	[168] = 14,
	[169] = 14,
	[170] = 14,
	[171] = 13,
	[172] = 27,
	[173] = 25,
	[174] = 27,
	[175] = 27,
	[176] = 27,
	[177] = 2,
	[178] = 2,
	[179] = 2,
	[180] = 2,
	[181] = 32,
	[182] = 2,
	[183] = 2,
	[184] = 2,
	[185] = 2,
	[186] = 2,
	[187] = 2,
	[188] = 15,
	[189] = 2,
	[190] = 15,
	[191] = 15,
	[192] = 16,
	[193] = 15,
	[194] = 16,
	[195] = 17,
	[196] = 18,
	[197] = 17,
	[198] = 4,
	[199] = 2,
	[200] = 5,
	[201] = 6,
	[202] = 3,
	[203] = 34,
	[204] = 34,
	[205] = 34,
	[206] = 34,
	[207] = 34,
	[208] = 34,
	[209] = 15,
	[210] = 15,
	[211] = 15,
	[212] = 18,
	[213] = 16,
	[214] = 18,
	[215] = 18,
	[216] = 18,
	[217] = 3,
	[218] = 20,
	[219] = 32,
	[220] = 7,
	[221] = 13,
	[222] = 2,
	[223] = 35,
	[224] = 35,
	[225] = 35,
	[226] = 36,
	[227] = 32,
	[228] = 32,
	[229] = 7,
	[230] = 32,
	[231] = 33,
	[232] = 32,
	[233] = 7,
	[234] = 22,
	[235] = 2,
	[236] = 22,
	[237] = 22,
	[238] = 23,
	[239] = 22,
	[240] = 23,
	[241] = 24,
	[242] = 26,
	[243] = 24,
	[244] = 25,
	[245] = 22,
	[246] = 22,
	[247] = 22,
	[248] = 26,
	[249] = 23,
	[250] = 26,
	[251] = 26,
	[252] = 26,
	[253] = 27,
	[254] = 2,
	[255] = 27,
	[256] = 27,
	[257] = 28,
	[258] = 27,
	[259] = 28,
	[260] = 29,
	[261] = 30,
	[262] = 29,
	[263] = 32,
	[264] = 7,
	[265] = 27,
	[266] = 27,
	[267] = 27,
	[268] = 30,
	[269] = 28,
	[270] = 30,
	[271] = 30,
	[272] = 30,
	[273] = 25,
	[274] = 2,
	[275] = 2,
	[276] = 3,
	[277] = 19,
	[278] = 20,
	[279] = 21,
	[280] = 31,
	[281] = 20,
	[282] = 7,
	[283] = 34,
	[284] = 20,
	[285] = 7,
	[286] = 21,
	[287] = 13,
	[288] = 36,
	[289] = 35,
	[290] = 6,
	[291] = 6,
	[292] = 6,
	[293] = 33,
	[294] = 7,
	[295] = 7,
	[296] = 32,
	[297] = 7,
	[298] = 25,
	[299] = 9,
	[300] = 25,
	[301] = 7,
	[302] = 15,
	[303] = 34,
	[304] = 20,
	[305] = 34,
	[306] = 31,
	[307] = 2,
	[308] = 37,
	[309] = 6,
	[310] = 38,
	[311] = 34,
	[312] = 21,
	[313] = 38,
	[314] = 37,
	[315] = 4,
	[316] = 2,
	[317] = 5,
	[318] = 6,
	[319] = 3,
	[320] = 39,
	[321] = 39,
	[322] = 39,
	[323] = 39,
	[324] = 39,
	[325] = 39,
	[326] = 32,
	[327] = 7,
	[328] = 7,
	[329] = 31,
	[330] = 35,
	[331] = 36,
	[332] = 2,
	[333] = 40,
	[334] = 40,
	[335] = 40,
	[336] = 2,
	[337] = 41,
	[338] = 41,
	[339] = 33,
	[340] = 41,
	[341] = 40,
	[342] = 33,
	[343] = 20,
	[344] = 22,
	[345] = 27,
	[346] = 37,
	[347] = 34,
	[348] = 3,
	[349] = 37,
	[350] = 34,
	[351] = 36,
	[352] = 37,
	[353] = 37,
	[354] = 34,
	[355] = 37,
	[356] = 38,
	[357] = 37,
	[358] = 34,
	[359] = 2,
	[360] = 2,
	[361] = 3,
	[362] = 19,
	[363] = 20,
	[364] = 21,
	[365] = 20,
	[366] = 7,
	[367] = 39,
	[368] = 32,
	[369] = 7,
	[370] = 4,
	[371] = 2,
	[372] = 5,
	[373] = 6,
	[374] = 3,
	[375] = 42,
	[376] = 42,
	[377] = 42,
	[378] = 42,
	[379] = 42,
	[380] = 42,
	[381] = 13,
	[382] = 6,
	[383] = 6,
	[384] = 33,
	[385] = 33,
	[386] = 13,
	[387] = 40,
	[388] = 41,
	[389] = 33,
	[390] = 33,
	[391] = 37,
	[392] = 34,
	[393] = 31,
	[394] = 20,
	[395] = 34,
	[396] = 34,
	[397] = 20,
	[398] = 34,
	[399] = 6,
	[400] = 6,
	[401] = 6,
	[402] = 38,
	[403] = 34,
	[404] = 34,
	[405] = 37,
	[406] = 34,
	[407] = 39,
	[408] = 20,
	[409] = 39,
	[410] = 31,
	[411] = 2,
	[412] = 43,
	[413] = 6,
	[414] = 44,
	[415] = 39,
	[416] = 21,
	[417] = 44,
	[418] = 43,
	[419] = 7,
	[420] = 7,
	[421] = 7,
	[422] = 2,
	[423] = 2,
	[424] = 3,
	[425] = 19,
	[426] = 20,
	[427] = 21,
	[428] = 20,
	[429] = 7,
	[430] = 42,
	[431] = 40,
	[432] = 33,
	[433] = 33,
	[434] = 41,
	[435] = 40,
	[436] = 34,
	[437] = 39,
	[438] = 37,
	[439] = 34,
	[440] = 34,
	[441] = 31,
	[442] = 40,
	[443] = 38,
	[444] = 40,
	[445] = 38,
	[446] = 20,
	[447] = 43,
	[448] = 34,
	[449] = 3,
	[450] = 43,
	[451] = 39,
	[452] = 36,
	[453] = 43,
	[454] = 43,
	[455] = 39,
	[456] = 43,
	[457] = 44,
	[458] = 43,
	[459] = 39,
	[460] = 42,
	[461] = 20,
	[462] = 42,
	[463] = 31,
	[464] = 2,
	[465] = 45,
	[466] = 6,
	[467] = 46,
	[468] = 42,
	[469] = 21,
	[470] = 46,
	[471] = 45,
	[472] = 32,
	[473] = 7,
	[474] = 20,
	[475] = 34,
	[476] = 39,
	[477] = 37,
	[478] = 34,
	[479] = 42,
	[480] = 6,
	[481] = 6,
	[482] = 38,
	[483] = 38,
	[484] = 38,
	[485] = 38,
	[486] = 43,
	[487] = 39,
	[488] = 31,
	[489] = 20,
	[490] = 39,
	[491] = 34,
	[492] = 20,
	[493] = 39,
	[494] = 6,
	[495] = 6,
	[496] = 6,
	[497] = 44,
	[498] = 39,
	[499] = 39,
	[500] = 43,
	[501] = 39,
	[502] = 45,
	[503] = 34,
	[504] = 3,
	[505] = 45,
	[506] = 42,
	[507] = 36,
	[508] = 45,
	[509] = 45,
	[510] = 42,
	[511] = 45,
	[512] = 46,
	[513] = 45,
	[514] = 42,
	[515] = 32,
	[516] = 7,
	[517] = 34,
	[518] = 34,
	[519] = 34,
	[520] = 20,
	[521] = 34,
	[522] = 42,
	[523] = 38,
	[524] = 38,
	[525] = 39,
	[526] = 39,
	[527] = 43,
	[528] = 39,
	[529] = 39,
	[530] = 31,
	[531] = 40,
	[532] = 44,
	[533] = 40,
	[534] = 44,
	[535] = 20,
	[536] = 45,
	[537] = 42,
	[538] = 31,
	[539] = 20,
	[540] = 42,
	[541] = 34,
	[542] = 20,
	[543] = 42,
	[544] = 6,
	[545] = 6,
	[546] = 6,
	[547] = 46,
	[548] = 42,
	[549] = 42,
	[550] = 45,
	[551] = 42,
	[552] = 7,
	[553] = 37,
	[554] = 34,
	[555] = 20,
	[556] = 39,
	[557] = 39,
	[558] = 43,
	[559] = 39,
	[560] = 42,
	[561] = 6,
	[562] = 6,
	[563] = 44,
	[564] = 44,
	[565] = 44,
	[566] = 44,
	[567] = 42,
	[568] = 39,
	[569] = 45,
	[570] = 42,
	[571] = 42,
	[572] = 31,
	[573] = 40,
	[574] = 46,
	[575] = 40,
	[576] = 46,
	[577] = 20,
	[578] = 37,
	[579] = 34,
	[580] = 39,
	[581] = 39,
	[582] = 39,
	[583] = 20,
	[584] = 39,
	[585] = 42,
	[586] = 44,
	[587] = 44,
	[588] = 20,
	[589] = 42,
	[590] = 39,
	[591] = 45,
	[592] = 42,
	[593] = 42,
	[594] = 6,
	[595] = 6,
	[596] = 46,
	[597] = 46,
	[598] = 46,
	[599] = 46,
	[600] = 34,
	[601] = 43,
	[602] = 39,
	[603] = 42,
	[604] = 42,
	[605] = 42,
	[606] = 20,
	[607] = 42,
	[608] = 42,
	[609] = 46,
	[610] = 46,
	[611] = 43,
	[612] = 39,
	[613] = 45,
	[614] = 42,
	[615] = 39,
	[616] = 45,
	[617] = 42,
	[618] = 42,
};


const unsigned zebu_lexer[110][256] = {
	[1][9] = 47,
	[1][10] = 48,
	[1][32] = 47,
	[1][34] = 49,
	[1][39] = 50,
	[1][40] = 51,
	[1][45] = 52,
	[1][46] = 52,
	[1][47] = 52,
	[1][48] = 52,
	[1][49] = 52,
	[1][50] = 52,
	[1][51] = 52,
	[1][52] = 52,
	[1][53] = 52,
	[1][54] = 52,
	[1][55] = 52,
	[1][56] = 52,
	[1][57] = 52,
	[1][95] = 53,
	[1][97] = 53,
	[1][98] = 53,
	[1][99] = 53,
	[1][100] = 53,
	[1][101] = 53,
	[1][102] = 54,
	[1][103] = 53,
	[1][104] = 53,
	[1][105] = 55,
	[1][106] = 53,
	[1][107] = 53,
	[1][108] = 53,
	[1][109] = 53,
	[1][110] = 53,
	[1][111] = 53,
	[1][112] = 53,
	[1][113] = 53,
	[1][114] = 53,
	[1][115] = 53,
	[1][116] = 53,
	[1][117] = 53,
	[1][118] = 53,
	[1][119] = 53,
	[1][120] = 53,
	[1][121] = 53,
	[1][122] = 53,
	[2][9] = 47,
	[2][32] = 47,
	[2][34] = 49,
	[2][39] = 50,
	[2][40] = 51,
	[2][43] = 56,
	[2][45] = 57,
	[2][48] = 58,
	[2][49] = 58,
	[2][50] = 58,
	[2][51] = 58,
	[2][52] = 58,
	[2][53] = 58,
	[2][54] = 58,
	[2][55] = 58,
	[2][56] = 58,
	[2][57] = 58,
	[2][91] = 59,
	[2][95] = 60,
	[2][97] = 60,
	[2][98] = 60,
	[2][99] = 60,
	[2][100] = 60,
	[2][101] = 60,
	[2][102] = 60,
	[2][103] = 60,
	[2][104] = 60,
	[2][105] = 60,
	[2][106] = 60,
	[2][107] = 60,
	[2][108] = 60,
	[2][109] = 60,
	[2][110] = 60,
	[2][111] = 60,
	[2][112] = 60,
	[2][113] = 60,
	[2][114] = 60,
	[2][115] = 60,
	[2][116] = 60,
	[2][117] = 60,
	[2][118] = 60,
	[2][119] = 60,
	[2][120] = 60,
	[2][121] = 60,
	[2][122] = 60,
	[3][9] = 47,
	[3][32] = 47,
	[3][58] = 61,
	[4][9] = 47,
	[4][32] = 47,
	[4][43] = 62,
	[4][58] = 61,
	[4][61] = 63,
	[5][9] = 47,
	[5][32] = 47,
	[5][95] = 60,
	[5][97] = 60,
	[5][98] = 60,
	[5][99] = 60,
	[5][100] = 60,
	[5][101] = 60,
	[5][102] = 60,
	[5][103] = 60,
	[5][104] = 60,
	[5][105] = 60,
	[5][106] = 60,
	[5][107] = 60,
	[5][108] = 60,
	[5][109] = 60,
	[5][110] = 60,
	[5][111] = 60,
	[5][112] = 60,
	[5][113] = 60,
	[5][114] = 60,
	[5][115] = 60,
	[5][116] = 60,
	[5][117] = 60,
	[5][118] = 60,
	[5][119] = 60,
	[5][120] = 60,
	[5][121] = 60,
	[5][122] = 60,
	[6][9] = 47,
	[6][32] = 47,
	[6][34] = 49,
	[6][39] = 50,
	[6][40] = 51,
	[6][45] = 52,
	[6][46] = 52,
	[6][47] = 52,
	[6][48] = 52,
	[6][49] = 52,
	[6][50] = 52,
	[6][51] = 52,
	[6][52] = 52,
	[6][53] = 52,
	[6][54] = 52,
	[6][55] = 52,
	[6][56] = 52,
	[6][57] = 52,
	[6][95] = 52,
	[6][97] = 52,
	[6][98] = 52,
	[6][99] = 52,
	[6][100] = 52,
	[6][101] = 52,
	[6][102] = 52,
	[6][103] = 52,
	[6][104] = 52,
	[6][105] = 52,
	[6][106] = 52,
	[6][107] = 52,
	[6][108] = 52,
	[6][109] = 52,
	[6][110] = 52,
	[6][111] = 52,
	[6][112] = 52,
	[6][113] = 52,
	[6][114] = 52,
	[6][115] = 52,
	[6][116] = 52,
	[6][117] = 52,
	[6][118] = 52,
	[6][119] = 52,
	[6][120] = 52,
	[6][121] = 52,
	[6][122] = 52,
	[7][9] = 47,
	[7][32] = 47,
	[7][34] = 49,
	[7][39] = 50,
	[7][40] = 51,
	[7][45] = 52,
	[7][46] = 52,
	[7][47] = 52,
	[7][48] = 52,
	[7][49] = 52,
	[7][50] = 52,
	[7][51] = 52,
	[7][52] = 52,
	[7][53] = 52,
	[7][54] = 52,
	[7][55] = 52,
	[7][56] = 52,
	[7][57] = 52,
	[7][95] = 53,
	[7][97] = 53,
	[7][98] = 53,
	[7][99] = 53,
	[7][100] = 53,
	[7][101] = 53,
	[7][102] = 54,
	[7][103] = 53,
	[7][104] = 53,
	[7][105] = 55,
	[7][106] = 53,
	[7][107] = 53,
	[7][108] = 53,
	[7][109] = 53,
	[7][110] = 53,
	[7][111] = 53,
	[7][112] = 53,
	[7][113] = 53,
	[7][114] = 53,
	[7][115] = 53,
	[7][116] = 53,
	[7][117] = 53,
	[7][118] = 53,
	[7][119] = 53,
	[7][120] = 53,
	[7][121] = 53,
	[7][122] = 53,
	[8][9] = 47,
	[8][32] = 47,
	[9][9] = 47,
	[9][32] = 47,
	[9][33] = 65,
	[9][41] = 66,
	[9][42] = 67,
	[9][43] = 56,
	[9][45] = 57,
	[9][47] = 68,
	[9][60] = 69,
	[9][61] = 70,
	[9][62] = 71,
	[10][9] = 47,
	[10][32] = 47,
	[10][34] = 49,
	[10][39] = 50,
	[10][40] = 51,
	[10][43] = 56,
	[10][45] = 57,
	[10][48] = 58,
	[10][49] = 58,
	[10][50] = 58,
	[10][51] = 58,
	[10][52] = 58,
	[10][53] = 58,
	[10][54] = 58,
	[10][55] = 58,
	[10][56] = 58,
	[10][57] = 58,
	[10][91] = 59,
	[10][93] = 72,
	[10][95] = 60,
	[10][97] = 60,
	[10][98] = 60,
	[10][99] = 60,
	[10][100] = 60,
	[10][101] = 60,
	[10][102] = 60,
	[10][103] = 60,
	[10][104] = 60,
	[10][105] = 60,
	[10][106] = 60,
	[10][107] = 60,
	[10][108] = 60,
	[10][109] = 60,
	[10][110] = 60,
	[10][111] = 60,
	[10][112] = 60,
	[10][113] = 60,
	[10][114] = 60,
	[10][115] = 60,
	[10][116] = 60,
	[10][117] = 60,
	[10][118] = 60,
	[10][119] = 60,
	[10][120] = 60,
	[10][121] = 60,
	[10][122] = 60,
	[11][9] = 47,
	[11][32] = 47,
	[11][33] = 65,
	[11][41] = 66,
	[11][43] = 56,
	[11][45] = 57,
	[11][60] = 69,
	[11][61] = 70,
	[11][62] = 71,
	[12][9] = 47,
	[12][32] = 47,
	[12][33] = 65,
	[12][41] = 66,
	[12][61] = 70,
	[13][9] = 47,
	[13][32] = 47,
	[13][41] = 66,
	[14][9] = 47,
	[14][32] = 47,
	[14][33] = 65,
	[14][41] = 66,
	[14][60] = 69,
	[14][61] = 70,
	[14][62] = 71,
	[15][9] = 47,
	[15][32] = 47,
	[15][33] = 65,
	[15][42] = 67,
	[15][43] = 56,
	[15][45] = 57,
	[15][47] = 68,
	[15][58] = 61,
	[15][60] = 69,
	[15][61] = 70,
	[15][62] = 71,
	[16][9] = 47,
	[16][32] = 47,
	[16][33] = 65,
	[16][43] = 56,
	[16][45] = 57,
	[16][58] = 61,
	[16][60] = 69,
	[16][61] = 70,
	[16][62] = 71,
	[17][9] = 47,
	[17][32] = 47,
	[17][33] = 65,
	[17][58] = 61,
	[17][61] = 70,
	[18][9] = 47,
	[18][32] = 47,
	[18][33] = 65,
	[18][58] = 61,
	[18][60] = 69,
	[18][61] = 70,
	[18][62] = 71,
	[19][9] = 47,
	[19][32] = 47,
	[19][105] = 73,
	[20][9] = 47,
	[20][10] = 48,
	[20][32] = 47,
	[21][9] = 47,
	[21][10] = 48,
	[21][32] = 47,
	[21][34] = 49,
	[21][36] = 74,
	[21][39] = 50,
	[21][40] = 51,
	[21][45] = 52,
	[21][46] = 52,
	[21][47] = 52,
	[21][48] = 52,
	[21][49] = 52,
	[21][50] = 52,
	[21][51] = 52,
	[21][52] = 52,
	[21][53] = 52,
	[21][54] = 52,
	[21][55] = 52,
	[21][56] = 52,
	[21][57] = 52,
	[21][95] = 52,
	[21][97] = 52,
	[21][98] = 52,
	[21][99] = 52,
	[21][100] = 52,
	[21][101] = 52,
	[21][102] = 52,
	[21][103] = 52,
	[21][104] = 52,
	[21][105] = 52,
	[21][106] = 52,
	[21][107] = 52,
	[21][108] = 52,
	[21][109] = 52,
	[21][110] = 52,
	[21][111] = 52,
	[21][112] = 52,
	[21][113] = 52,
	[21][114] = 52,
	[21][115] = 52,
	[21][116] = 52,
	[21][117] = 52,
	[21][118] = 52,
	[21][119] = 52,
	[21][120] = 52,
	[21][121] = 52,
	[21][122] = 52,
	[22][9] = 47,
	[22][32] = 47,
	[22][33] = 65,
	[22][42] = 67,
	[22][43] = 56,
	[22][44] = 75,
	[22][45] = 57,
	[22][47] = 68,
	[22][60] = 69,
	[22][61] = 70,
	[22][62] = 71,
	[22][93] = 72,
	[23][9] = 47,
	[23][32] = 47,
	[23][33] = 65,
	[23][43] = 56,
	[23][44] = 75,
	[23][45] = 57,
	[23][60] = 69,
	[23][61] = 70,
	[23][62] = 71,
	[23][93] = 72,
	[24][9] = 47,
	[24][32] = 47,
	[24][33] = 65,
	[24][44] = 75,
	[24][61] = 70,
	[24][93] = 72,
	[25][9] = 47,
	[25][32] = 47,
	[25][44] = 75,
	[25][93] = 72,
	[26][9] = 47,
	[26][32] = 47,
	[26][33] = 65,
	[26][44] = 75,
	[26][60] = 69,
	[26][61] = 70,
	[26][62] = 71,
	[26][93] = 72,
	[27][9] = 47,
	[27][10] = 48,
	[27][32] = 47,
	[27][33] = 65,
	[27][42] = 67,
	[27][43] = 56,
	[27][45] = 57,
	[27][47] = 68,
	[27][60] = 69,
	[27][61] = 70,
	[27][62] = 71,
	[28][9] = 47,
	[28][10] = 48,
	[28][32] = 47,
	[28][33] = 65,
	[28][43] = 56,
	[28][45] = 57,
	[28][60] = 69,
	[28][61] = 70,
	[28][62] = 71,
	[29][9] = 47,
	[29][10] = 48,
	[29][32] = 47,
	[29][33] = 65,
	[29][61] = 70,
	[30][9] = 47,
	[30][10] = 48,
	[30][32] = 47,
	[30][33] = 65,
	[30][60] = 69,
	[30][61] = 70,
	[30][62] = 71,
	[31][9] = 47,
	[31][32] = 47,
	[31][34] = 49,
	[31][39] = 50,
	[31][40] = 51,
	[31][45] = 52,
	[31][46] = 52,
	[31][47] = 52,
	[31][48] = 52,
	[31][49] = 52,
	[31][50] = 52,
	[31][51] = 52,
	[31][52] = 52,
	[31][53] = 52,
	[31][54] = 52,
	[31][55] = 52,
	[31][56] = 52,
	[31][57] = 52,
	[31][95] = 53,
	[31][97] = 53,
	[31][98] = 53,
	[31][99] = 53,
	[31][100] = 53,
	[31][101] = 53,
	[31][102] = 54,
	[31][103] = 53,
	[31][104] = 53,
	[31][105] = 55,
	[31][106] = 53,
	[31][107] = 53,
	[31][108] = 53,
	[31][109] = 53,
	[31][110] = 53,
	[31][111] = 53,
	[31][112] = 53,
	[31][113] = 53,
	[31][114] = 53,
	[31][115] = 53,
	[31][116] = 53,
	[31][117] = 53,
	[31][118] = 53,
	[31][119] = 53,
	[31][120] = 53,
	[31][121] = 53,
	[31][122] = 53,
	[32][9] = 47,
	[32][10] = 48,
	[32][32] = 47,
	[32][34] = 49,
	[32][39] = 50,
	[32][40] = 51,
	[32][45] = 52,
	[32][46] = 52,
	[32][47] = 52,
	[32][48] = 52,
	[32][49] = 52,
	[32][50] = 52,
	[32][51] = 52,
	[32][52] = 52,
	[32][53] = 52,
	[32][54] = 52,
	[32][55] = 52,
	[32][56] = 52,
	[32][57] = 52,
	[32][95] = 53,
	[32][97] = 53,
	[32][98] = 53,
	[32][99] = 53,
	[32][100] = 53,
	[32][101] = 53,
	[32][102] = 54,
	[32][103] = 53,
	[32][104] = 53,
	[32][105] = 55,
	[32][106] = 53,
	[32][107] = 53,
	[32][108] = 53,
	[32][109] = 53,
	[32][110] = 53,
	[32][111] = 53,
	[32][112] = 53,
	[32][113] = 53,
	[32][114] = 53,
	[32][115] = 53,
	[32][116] = 53,
	[32][117] = 53,
	[32][118] = 53,
	[32][119] = 53,
	[32][120] = 53,
	[32][121] = 53,
	[32][122] = 53,
	[33][9] = 47,
	[33][10] = 48,
	[33][32] = 47,
	[33][34] = 49,
	[33][36] = 74,
	[33][39] = 50,
	[33][40] = 51,
	[33][45] = 52,
	[33][46] = 52,
	[33][47] = 52,
	[33][48] = 52,
	[33][49] = 52,
	[33][50] = 52,
	[33][51] = 52,
	[33][52] = 52,
	[33][53] = 52,
	[33][54] = 52,
	[33][55] = 52,
	[33][56] = 52,
	[33][57] = 52,
	[33][95] = 53,
	[33][97] = 53,
	[33][98] = 53,
	[33][99] = 53,
	[33][100] = 53,
	[33][101] = 53,
	[33][102] = 54,
	[33][103] = 53,
	[33][104] = 53,
	[33][105] = 55,
	[33][106] = 53,
	[33][107] = 53,
	[33][108] = 53,
	[33][109] = 53,
	[33][110] = 53,
	[33][111] = 53,
	[33][112] = 53,
	[33][113] = 53,
	[33][114] = 53,
	[33][115] = 53,
	[33][116] = 53,
	[33][117] = 53,
	[33][118] = 53,
	[33][119] = 53,
	[33][120] = 53,
	[33][121] = 53,
	[33][122] = 53,
	[34][9] = 47,
	[34][32] = 47,
	[34][34] = 49,
	[34][39] = 50,
	[34][40] = 51,
	[34][45] = 52,
	[34][46] = 52,
	[34][47] = 52,
	[34][48] = 52,
	[34][49] = 52,
	[34][50] = 52,
	[34][51] = 52,
	[34][52] = 52,
	[34][53] = 52,
	[34][54] = 52,
	[34][55] = 52,
	[34][56] = 52,
	[34][57] = 52,
	[34][95] = 53,
	[34][97] = 53,
	[34][98] = 53,
	[34][99] = 53,
	[34][100] = 53,
	[34][101] = 76,
	[34][102] = 54,
	[34][103] = 53,
	[34][104] = 53,
	[34][105] = 55,
	[34][106] = 53,
	[34][107] = 53,
	[34][108] = 53,
	[34][109] = 53,
	[34][110] = 53,
	[34][111] = 53,
	[34][112] = 53,
	[34][113] = 53,
	[34][114] = 53,
	[34][115] = 53,
	[34][116] = 53,
	[34][117] = 53,
	[34][118] = 53,
	[34][119] = 53,
	[34][120] = 53,
	[34][121] = 53,
	[34][122] = 53,
	[35][9] = 47,
	[35][10] = 48,
	[35][32] = 47,
	[35][34] = 49,
	[35][39] = 50,
	[35][40] = 51,
	[35][45] = 52,
	[35][46] = 52,
	[35][47] = 52,
	[35][48] = 52,
	[35][49] = 52,
	[35][50] = 52,
	[35][51] = 52,
	[35][52] = 52,
	[35][53] = 52,
	[35][54] = 52,
	[35][55] = 52,
	[35][56] = 52,
	[35][57] = 52,
	[35][60] = 77,
	[35][62] = 78,
	[35][95] = 52,
	[35][97] = 52,
	[35][98] = 52,
	[35][99] = 52,
	[35][100] = 52,
	[35][101] = 52,
	[35][102] = 52,
	[35][103] = 52,
	[35][104] = 52,
	[35][105] = 52,
	[35][106] = 52,
	[35][107] = 52,
	[35][108] = 52,
	[35][109] = 52,
	[35][110] = 52,
	[35][111] = 52,
	[35][112] = 52,
	[35][113] = 52,
	[35][114] = 52,
	[35][115] = 52,
	[35][116] = 52,
	[35][117] = 52,
	[35][118] = 52,
	[35][119] = 52,
	[35][120] = 52,
	[35][121] = 52,
	[35][122] = 52,
	[35][124] = 79,
	[36][9] = 47,
	[36][10] = 48,
	[36][32] = 47,
	[36][60] = 77,
	[36][62] = 78,
	[36][124] = 79,
	[37][9] = 47,
	[37][10] = 48,
	[37][32] = 47,
	[37][34] = 49,
	[37][39] = 50,
	[37][40] = 51,
	[37][45] = 52,
	[37][46] = 52,
	[37][47] = 52,
	[37][48] = 52,
	[37][49] = 52,
	[37][50] = 52,
	[37][51] = 52,
	[37][52] = 52,
	[37][53] = 52,
	[37][54] = 52,
	[37][55] = 52,
	[37][56] = 52,
	[37][57] = 52,
	[37][95] = 53,
	[37][97] = 53,
	[37][98] = 53,
	[37][99] = 53,
	[37][100] = 53,
	[37][101] = 76,
	[37][102] = 54,
	[37][103] = 53,
	[37][104] = 53,
	[37][105] = 55,
	[37][106] = 53,
	[37][107] = 53,
	[37][108] = 53,
	[37][109] = 53,
	[37][110] = 53,
	[37][111] = 53,
	[37][112] = 53,
	[37][113] = 53,
	[37][114] = 53,
	[37][115] = 53,
	[37][116] = 53,
	[37][117] = 53,
	[37][118] = 53,
	[37][119] = 53,
	[37][120] = 53,
	[37][121] = 53,
	[37][122] = 53,
	[38][9] = 47,
	[38][10] = 48,
	[38][32] = 47,
	[38][34] = 49,
	[38][36] = 74,
	[38][39] = 50,
	[38][40] = 51,
	[38][45] = 52,
	[38][46] = 52,
	[38][47] = 52,
	[38][48] = 52,
	[38][49] = 52,
	[38][50] = 52,
	[38][51] = 52,
	[38][52] = 52,
	[38][53] = 52,
	[38][54] = 52,
	[38][55] = 52,
	[38][56] = 52,
	[38][57] = 52,
	[38][95] = 53,
	[38][97] = 53,
	[38][98] = 53,
	[38][99] = 53,
	[38][100] = 53,
	[38][101] = 76,
	[38][102] = 54,
	[38][103] = 53,
	[38][104] = 53,
	[38][105] = 55,
	[38][106] = 53,
	[38][107] = 53,
	[38][108] = 53,
	[38][109] = 53,
	[38][110] = 53,
	[38][111] = 53,
	[38][112] = 53,
	[38][113] = 53,
	[38][114] = 53,
	[38][115] = 53,
	[38][116] = 53,
	[38][117] = 53,
	[38][118] = 53,
	[38][119] = 53,
	[38][120] = 53,
	[38][121] = 53,
	[38][122] = 53,
	[39][9] = 47,
	[39][32] = 47,
	[39][34] = 49,
	[39][39] = 50,
	[39][40] = 51,
	[39][45] = 52,
	[39][46] = 52,
	[39][47] = 52,
	[39][48] = 52,
	[39][49] = 52,
	[39][50] = 52,
	[39][51] = 52,
	[39][52] = 52,
	[39][53] = 52,
	[39][54] = 52,
	[39][55] = 52,
	[39][56] = 52,
	[39][57] = 52,
	[39][95] = 53,
	[39][97] = 53,
	[39][98] = 53,
	[39][99] = 53,
	[39][100] = 53,
	[39][101] = 80,
	[39][102] = 54,
	[39][103] = 53,
	[39][104] = 53,
	[39][105] = 55,
	[39][106] = 53,
	[39][107] = 53,
	[39][108] = 53,
	[39][109] = 53,
	[39][110] = 53,
	[39][111] = 53,
	[39][112] = 53,
	[39][113] = 53,
	[39][114] = 53,
	[39][115] = 53,
	[39][116] = 53,
	[39][117] = 53,
	[39][118] = 53,
	[39][119] = 53,
	[39][120] = 53,
	[39][121] = 53,
	[39][122] = 53,
	[40][9] = 47,
	[40][10] = 48,
	[40][32] = 47,
	[40][62] = 78,
	[40][124] = 79,
	[41][9] = 47,
	[41][10] = 48,
	[41][32] = 47,
	[41][34] = 49,
	[41][39] = 50,
	[41][40] = 51,
	[41][45] = 52,
	[41][46] = 52,
	[41][47] = 52,
	[41][48] = 52,
	[41][49] = 52,
	[41][50] = 52,
	[41][51] = 52,
	[41][52] = 52,
	[41][53] = 52,
	[41][54] = 52,
	[41][55] = 52,
	[41][56] = 52,
	[41][57] = 52,
	[41][62] = 78,
	[41][95] = 52,
	[41][97] = 52,
	[41][98] = 52,
	[41][99] = 52,
	[41][100] = 52,
	[41][101] = 52,
	[41][102] = 52,
	[41][103] = 52,
	[41][104] = 52,
	[41][105] = 52,
	[41][106] = 52,
	[41][107] = 52,
	[41][108] = 52,
	[41][109] = 52,
	[41][110] = 52,
	[41][111] = 52,
	[41][112] = 52,
	[41][113] = 52,
	[41][114] = 52,
	[41][115] = 52,
	[41][116] = 52,
	[41][117] = 52,
	[41][118] = 52,
	[41][119] = 52,
	[41][120] = 52,
	[41][121] = 52,
	[41][122] = 52,
	[41][124] = 79,
	[42][9] = 47,
	[42][32] = 47,
	[42][34] = 49,
	[42][39] = 50,
	[42][40] = 51,
	[42][45] = 52,
	[42][46] = 52,
	[42][47] = 52,
	[42][48] = 52,
	[42][49] = 52,
	[42][50] = 52,
	[42][51] = 52,
	[42][52] = 52,
	[42][53] = 52,
	[42][54] = 52,
	[42][55] = 52,
	[42][56] = 52,
	[42][57] = 52,
	[42][95] = 53,
	[42][97] = 53,
	[42][98] = 53,
	[42][99] = 53,
	[42][100] = 53,
	[42][101] = 81,
	[42][102] = 54,
	[42][103] = 53,
	[42][104] = 53,
	[42][105] = 55,
	[42][106] = 53,
	[42][107] = 53,
	[42][108] = 53,
	[42][109] = 53,
	[42][110] = 53,
	[42][111] = 53,
	[42][112] = 53,
	[42][113] = 53,
	[42][114] = 53,
	[42][115] = 53,
	[42][116] = 53,
	[42][117] = 53,
	[42][118] = 53,
	[42][119] = 53,
	[42][120] = 53,
	[42][121] = 53,
	[42][122] = 53,
	[43][9] = 47,
	[43][10] = 48,
	[43][32] = 47,
	[43][34] = 49,
	[43][39] = 50,
	[43][40] = 51,
	[43][45] = 52,
	[43][46] = 52,
	[43][47] = 52,
	[43][48] = 52,
	[43][49] = 52,
	[43][50] = 52,
	[43][51] = 52,
	[43][52] = 52,
	[43][53] = 52,
	[43][54] = 52,
	[43][55] = 52,
	[43][56] = 52,
	[43][57] = 52,
	[43][95] = 53,
	[43][97] = 53,
	[43][98] = 53,
	[43][99] = 53,
	[43][100] = 53,
	[43][101] = 80,
	[43][102] = 54,
	[43][103] = 53,
	[43][104] = 53,
	[43][105] = 55,
	[43][106] = 53,
	[43][107] = 53,
	[43][108] = 53,
	[43][109] = 53,
	[43][110] = 53,
	[43][111] = 53,
	[43][112] = 53,
	[43][113] = 53,
	[43][114] = 53,
	[43][115] = 53,
	[43][116] = 53,
	[43][117] = 53,
	[43][118] = 53,
	[43][119] = 53,
	[43][120] = 53,
	[43][121] = 53,
	[43][122] = 53,
	[44][9] = 47,
	[44][10] = 48,
	[44][32] = 47,
	[44][34] = 49,
	[44][36] = 74,
	[44][39] = 50,
	[44][40] = 51,
	[44][45] = 52,
	[44][46] = 52,
	[44][47] = 52,
	[44][48] = 52,
	[44][49] = 52,
	[44][50] = 52,
	[44][51] = 52,
	[44][52] = 52,
	[44][53] = 52,
	[44][54] = 52,
	[44][55] = 52,
	[44][56] = 52,
	[44][57] = 52,
	[44][95] = 53,
	[44][97] = 53,
	[44][98] = 53,
	[44][99] = 53,
	[44][100] = 53,
	[44][101] = 80,
	[44][102] = 54,
	[44][103] = 53,
	[44][104] = 53,
	[44][105] = 55,
	[44][106] = 53,
	[44][107] = 53,
	[44][108] = 53,
	[44][109] = 53,
	[44][110] = 53,
	[44][111] = 53,
	[44][112] = 53,
	[44][113] = 53,
	[44][114] = 53,
	[44][115] = 53,
	[44][116] = 53,
	[44][117] = 53,
	[44][118] = 53,
	[44][119] = 53,
	[44][120] = 53,
	[44][121] = 53,
	[44][122] = 53,
	[45][9] = 47,
	[45][10] = 48,
	[45][32] = 47,
	[45][34] = 49,
	[45][39] = 50,
	[45][40] = 51,
	[45][45] = 52,
	[45][46] = 52,
	[45][47] = 52,
	[45][48] = 52,
	[45][49] = 52,
	[45][50] = 52,
	[45][51] = 52,
	[45][52] = 52,
	[45][53] = 52,
	[45][54] = 52,
	[45][55] = 52,
	[45][56] = 52,
	[45][57] = 52,
	[45][95] = 53,
	[45][97] = 53,
	[45][98] = 53,
	[45][99] = 53,
	[45][100] = 53,
	[45][101] = 81,
	[45][102] = 54,
	[45][103] = 53,
	[45][104] = 53,
	[45][105] = 55,
	[45][106] = 53,
	[45][107] = 53,
	[45][108] = 53,
	[45][109] = 53,
	[45][110] = 53,
	[45][111] = 53,
	[45][112] = 53,
	[45][113] = 53,
	[45][114] = 53,
	[45][115] = 53,
	[45][116] = 53,
	[45][117] = 53,
	[45][118] = 53,
	[45][119] = 53,
	[45][120] = 53,
	[45][121] = 53,
	[45][122] = 53,
	[46][9] = 47,
	[46][10] = 48,
	[46][32] = 47,
	[46][34] = 49,
	[46][36] = 74,
	[46][39] = 50,
	[46][40] = 51,
	[46][45] = 52,
	[46][46] = 52,
	[46][47] = 52,
	[46][48] = 52,
	[46][49] = 52,
	[46][50] = 52,
	[46][51] = 52,
	[46][52] = 52,
	[46][53] = 52,
	[46][54] = 52,
	[46][55] = 52,
	[46][56] = 52,
	[46][57] = 52,
	[46][95] = 53,
	[46][97] = 53,
	[46][98] = 53,
	[46][99] = 53,
	[46][100] = 53,
	[46][101] = 81,
	[46][102] = 54,
	[46][103] = 53,
	[46][104] = 53,
	[46][105] = 55,
	[46][106] = 53,
	[46][107] = 53,
	[46][108] = 53,
	[46][109] = 53,
	[46][110] = 53,
	[46][111] = 53,
	[46][112] = 53,
	[46][113] = 53,
	[46][114] = 53,
	[46][115] = 53,
	[46][116] = 53,
	[46][117] = 53,
	[46][118] = 53,
	[46][119] = 53,
	[46][120] = 53,
	[46][121] = 53,
	[46][122] = 53,
	[47][9] = 47,
	[47][32] = 47,
	[49][0] = 49,
	[49][1] = 49,
	[49][2] = 49,
	[49][3] = 49,
	[49][4] = 49,
	[49][5] = 49,
	[49][6] = 49,
	[49][7] = 49,
	[49][8] = 49,
	[49][9] = 49,
	[49][10] = 49,
	[49][11] = 49,
	[49][12] = 49,
	[49][13] = 49,
	[49][14] = 49,
	[49][15] = 49,
	[49][16] = 49,
	[49][17] = 49,
	[49][18] = 49,
	[49][19] = 49,
	[49][20] = 49,
	[49][21] = 49,
	[49][22] = 49,
	[49][23] = 49,
	[49][24] = 49,
	[49][25] = 49,
	[49][26] = 49,
	[49][27] = 49,
	[49][28] = 49,
	[49][29] = 49,
	[49][30] = 49,
	[49][31] = 49,
	[49][32] = 49,
	[49][33] = 49,
	[49][34] = 82,
	[49][35] = 49,
	[49][36] = 49,
	[49][37] = 49,
	[49][38] = 49,
	[49][39] = 49,
	[49][40] = 49,
	[49][41] = 49,
	[49][42] = 49,
	[49][43] = 49,
	[49][44] = 49,
	[49][45] = 49,
	[49][46] = 49,
	[49][47] = 49,
	[49][48] = 49,
	[49][49] = 49,
	[49][50] = 49,
	[49][51] = 49,
	[49][52] = 49,
	[49][53] = 49,
	[49][54] = 49,
	[49][55] = 49,
	[49][56] = 49,
	[49][57] = 49,
	[49][58] = 49,
	[49][59] = 49,
	[49][60] = 49,
	[49][61] = 49,
	[49][62] = 49,
	[49][63] = 49,
	[49][64] = 49,
	[49][65] = 49,
	[49][66] = 49,
	[49][67] = 49,
	[49][68] = 49,
	[49][69] = 49,
	[49][70] = 49,
	[49][71] = 49,
	[49][72] = 49,
	[49][73] = 49,
	[49][74] = 49,
	[49][75] = 49,
	[49][76] = 49,
	[49][77] = 49,
	[49][78] = 49,
	[49][79] = 49,
	[49][80] = 49,
	[49][81] = 49,
	[49][82] = 49,
	[49][83] = 49,
	[49][84] = 49,
	[49][85] = 49,
	[49][86] = 49,
	[49][87] = 49,
	[49][88] = 49,
	[49][89] = 49,
	[49][90] = 49,
	[49][91] = 49,
	[49][92] = 49,
	[49][93] = 49,
	[49][94] = 49,
	[49][95] = 49,
	[49][96] = 49,
	[49][97] = 49,
	[49][98] = 49,
	[49][99] = 49,
	[49][100] = 49,
	[49][101] = 49,
	[49][102] = 49,
	[49][103] = 49,
	[49][104] = 49,
	[49][105] = 49,
	[49][106] = 49,
	[49][107] = 49,
	[49][108] = 49,
	[49][109] = 49,
	[49][110] = 49,
	[49][111] = 49,
	[49][112] = 49,
	[49][113] = 49,
	[49][114] = 49,
	[49][115] = 49,
	[49][116] = 49,
	[49][117] = 49,
	[49][118] = 49,
	[49][119] = 49,
	[49][120] = 49,
	[49][121] = 49,
	[49][122] = 49,
	[49][123] = 49,
	[49][124] = 49,
	[49][125] = 49,
	[49][126] = 49,
	[49][127] = 49,
	[49][128] = 49,
	[49][129] = 49,
	[49][130] = 49,
	[49][131] = 49,
	[49][132] = 49,
	[49][133] = 49,
	[49][134] = 49,
	[49][135] = 49,
	[49][136] = 49,
	[49][137] = 49,
	[49][138] = 49,
	[49][139] = 49,
	[49][140] = 49,
	[49][141] = 49,
	[49][142] = 49,
	[49][143] = 49,
	[49][144] = 49,
	[49][145] = 49,
	[49][146] = 49,
	[49][147] = 49,
	[49][148] = 49,
	[49][149] = 49,
	[49][150] = 49,
	[49][151] = 49,
	[49][152] = 49,
	[49][153] = 49,
	[49][154] = 49,
	[49][155] = 49,
	[49][156] = 49,
	[49][157] = 49,
	[49][158] = 49,
	[49][159] = 49,
	[49][160] = 49,
	[49][161] = 49,
	[49][162] = 49,
	[49][163] = 49,
	[49][164] = 49,
	[49][165] = 49,
	[49][166] = 49,
	[49][167] = 49,
	[49][168] = 49,
	[49][169] = 49,
	[49][170] = 49,
	[49][171] = 49,
	[49][172] = 49,
	[49][173] = 49,
	[49][174] = 49,
	[49][175] = 49,
	[49][176] = 49,
	[49][177] = 49,
	[49][178] = 49,
	[49][179] = 49,
	[49][180] = 49,
	[49][181] = 49,
	[49][182] = 49,
	[49][183] = 49,
	[49][184] = 49,
	[49][185] = 49,
	[49][186] = 49,
	[49][187] = 49,
	[49][188] = 49,
	[49][189] = 49,
	[49][190] = 49,
	[49][191] = 49,
	[49][192] = 49,
	[49][193] = 49,
	[49][194] = 49,
	[49][195] = 49,
	[49][196] = 49,
	[49][197] = 49,
	[49][198] = 49,
	[49][199] = 49,
	[49][200] = 49,
	[49][201] = 49,
	[49][202] = 49,
	[49][203] = 49,
	[49][204] = 49,
	[49][205] = 49,
	[49][206] = 49,
	[49][207] = 49,
	[49][208] = 49,
	[49][209] = 49,
	[49][210] = 49,
	[49][211] = 49,
	[49][212] = 49,
	[49][213] = 49,
	[49][214] = 49,
	[49][215] = 49,
	[49][216] = 49,
	[49][217] = 49,
	[49][218] = 49,
	[49][219] = 49,
	[49][220] = 49,
	[49][221] = 49,
	[49][222] = 49,
	[49][223] = 49,
	[49][224] = 49,
	[49][225] = 49,
	[49][226] = 49,
	[49][227] = 49,
	[49][228] = 49,
	[49][229] = 49,
	[49][230] = 49,
	[49][231] = 49,
	[49][232] = 49,
	[49][233] = 49,
	[49][234] = 49,
	[49][235] = 49,
	[49][236] = 49,
	[49][237] = 49,
	[49][238] = 49,
	[49][239] = 49,
	[49][240] = 49,
	[49][241] = 49,
	[49][242] = 49,
	[49][243] = 49,
	[49][244] = 49,
	[49][245] = 49,
	[49][246] = 49,
	[49][247] = 49,
	[49][248] = 49,
	[49][249] = 49,
	[49][250] = 49,
	[49][251] = 49,
	[49][252] = 49,
	[49][253] = 49,
	[49][254] = 49,
	[49][255] = 49,
	[50][0] = 50,
	[50][1] = 50,
	[50][2] = 50,
	[50][3] = 50,
	[50][4] = 50,
	[50][5] = 50,
	[50][6] = 50,
	[50][7] = 50,
	[50][8] = 50,
	[50][9] = 50,
	[50][10] = 50,
	[50][11] = 50,
	[50][12] = 50,
	[50][13] = 50,
	[50][14] = 50,
	[50][15] = 50,
	[50][16] = 50,
	[50][17] = 50,
	[50][18] = 50,
	[50][19] = 50,
	[50][20] = 50,
	[50][21] = 50,
	[50][22] = 50,
	[50][23] = 50,
	[50][24] = 50,
	[50][25] = 50,
	[50][26] = 50,
	[50][27] = 50,
	[50][28] = 50,
	[50][29] = 50,
	[50][30] = 50,
	[50][31] = 50,
	[50][32] = 50,
	[50][33] = 50,
	[50][34] = 50,
	[50][35] = 50,
	[50][36] = 50,
	[50][37] = 50,
	[50][38] = 50,
	[50][39] = 82,
	[50][40] = 50,
	[50][41] = 50,
	[50][42] = 50,
	[50][43] = 50,
	[50][44] = 50,
	[50][45] = 50,
	[50][46] = 50,
	[50][47] = 50,
	[50][48] = 50,
	[50][49] = 50,
	[50][50] = 50,
	[50][51] = 50,
	[50][52] = 50,
	[50][53] = 50,
	[50][54] = 50,
	[50][55] = 50,
	[50][56] = 50,
	[50][57] = 50,
	[50][58] = 50,
	[50][59] = 50,
	[50][60] = 50,
	[50][61] = 50,
	[50][62] = 50,
	[50][63] = 50,
	[50][64] = 50,
	[50][65] = 50,
	[50][66] = 50,
	[50][67] = 50,
	[50][68] = 50,
	[50][69] = 50,
	[50][70] = 50,
	[50][71] = 50,
	[50][72] = 50,
	[50][73] = 50,
	[50][74] = 50,
	[50][75] = 50,
	[50][76] = 50,
	[50][77] = 50,
	[50][78] = 50,
	[50][79] = 50,
	[50][80] = 50,
	[50][81] = 50,
	[50][82] = 50,
	[50][83] = 50,
	[50][84] = 50,
	[50][85] = 50,
	[50][86] = 50,
	[50][87] = 50,
	[50][88] = 50,
	[50][89] = 50,
	[50][90] = 50,
	[50][91] = 50,
	[50][92] = 50,
	[50][93] = 50,
	[50][94] = 50,
	[50][95] = 50,
	[50][96] = 50,
	[50][97] = 50,
	[50][98] = 50,
	[50][99] = 50,
	[50][100] = 50,
	[50][101] = 50,
	[50][102] = 50,
	[50][103] = 50,
	[50][104] = 50,
	[50][105] = 50,
	[50][106] = 50,
	[50][107] = 50,
	[50][108] = 50,
	[50][109] = 50,
	[50][110] = 50,
	[50][111] = 50,
	[50][112] = 50,
	[50][113] = 50,
	[50][114] = 50,
	[50][115] = 50,
	[50][116] = 50,
	[50][117] = 50,
	[50][118] = 50,
	[50][119] = 50,
	[50][120] = 50,
	[50][121] = 50,
	[50][122] = 50,
	[50][123] = 50,
	[50][124] = 50,
	[50][125] = 50,
	[50][126] = 50,
	[50][127] = 50,
	[50][128] = 50,
	[50][129] = 50,
	[50][130] = 50,
	[50][131] = 50,
	[50][132] = 50,
	[50][133] = 50,
	[50][134] = 50,
	[50][135] = 50,
	[50][136] = 50,
	[50][137] = 50,
	[50][138] = 50,
	[50][139] = 50,
	[50][140] = 50,
	[50][141] = 50,
	[50][142] = 50,
	[50][143] = 50,
	[50][144] = 50,
	[50][145] = 50,
	[50][146] = 50,
	[50][147] = 50,
	[50][148] = 50,
	[50][149] = 50,
	[50][150] = 50,
	[50][151] = 50,
	[50][152] = 50,
	[50][153] = 50,
	[50][154] = 50,
	[50][155] = 50,
	[50][156] = 50,
	[50][157] = 50,
	[50][158] = 50,
	[50][159] = 50,
	[50][160] = 50,
	[50][161] = 50,
	[50][162] = 50,
	[50][163] = 50,
	[50][164] = 50,
	[50][165] = 50,
	[50][166] = 50,
	[50][167] = 50,
	[50][168] = 50,
	[50][169] = 50,
	[50][170] = 50,
	[50][171] = 50,
	[50][172] = 50,
	[50][173] = 50,
	[50][174] = 50,
	[50][175] = 50,
	[50][176] = 50,
	[50][177] = 50,
	[50][178] = 50,
	[50][179] = 50,
	[50][180] = 50,
	[50][181] = 50,
	[50][182] = 50,
	[50][183] = 50,
	[50][184] = 50,
	[50][185] = 50,
	[50][186] = 50,
	[50][187] = 50,
	[50][188] = 50,
	[50][189] = 50,
	[50][190] = 50,
	[50][191] = 50,
	[50][192] = 50,
	[50][193] = 50,
	[50][194] = 50,
	[50][195] = 50,
	[50][196] = 50,
	[50][197] = 50,
	[50][198] = 50,
	[50][199] = 50,
	[50][200] = 50,
	[50][201] = 50,
	[50][202] = 50,
	[50][203] = 50,
	[50][204] = 50,
	[50][205] = 50,
	[50][206] = 50,
	[50][207] = 50,
	[50][208] = 50,
	[50][209] = 50,
	[50][210] = 50,
	[50][211] = 50,
	[50][212] = 50,
	[50][213] = 50,
	[50][214] = 50,
	[50][215] = 50,
	[50][216] = 50,
	[50][217] = 50,
	[50][218] = 50,
	[50][219] = 50,
	[50][220] = 50,
	[50][221] = 50,
	[50][222] = 50,
	[50][223] = 50,
	[50][224] = 50,
	[50][225] = 50,
	[50][226] = 50,
	[50][227] = 50,
	[50][228] = 50,
	[50][229] = 50,
	[50][230] = 50,
	[50][231] = 50,
	[50][232] = 50,
	[50][233] = 50,
	[50][234] = 50,
	[50][235] = 50,
	[50][236] = 50,
	[50][237] = 50,
	[50][238] = 50,
	[50][239] = 50,
	[50][240] = 50,
	[50][241] = 50,
	[50][242] = 50,
	[50][243] = 50,
	[50][244] = 50,
	[50][245] = 50,
	[50][246] = 50,
	[50][247] = 50,
	[50][248] = 50,
	[50][249] = 50,
	[50][250] = 50,
	[50][251] = 50,
	[50][252] = 50,
	[50][253] = 50,
	[50][254] = 50,
	[50][255] = 50,
	[52][45] = 52,
	[52][46] = 52,
	[52][47] = 52,
	[52][48] = 52,
	[52][49] = 52,
	[52][50] = 52,
	[52][51] = 52,
	[52][52] = 52,
	[52][53] = 52,
	[52][54] = 52,
	[52][55] = 52,
	[52][56] = 52,
	[52][57] = 52,
	[52][95] = 52,
	[52][97] = 52,
	[52][98] = 52,
	[52][99] = 52,
	[52][100] = 52,
	[52][101] = 52,
	[52][102] = 52,
	[52][103] = 52,
	[52][104] = 52,
	[52][105] = 52,
	[52][106] = 52,
	[52][107] = 52,
	[52][108] = 52,
	[52][109] = 52,
	[52][110] = 52,
	[52][111] = 52,
	[52][112] = 52,
	[52][113] = 52,
	[52][114] = 52,
	[52][115] = 52,
	[52][116] = 52,
	[52][117] = 52,
	[52][118] = 52,
	[52][119] = 52,
	[52][120] = 52,
	[52][121] = 52,
	[52][122] = 52,
	[53][45] = 52,
	[53][46] = 52,
	[53][47] = 52,
	[53][48] = 53,
	[53][49] = 53,
	[53][50] = 53,
	[53][51] = 53,
	[53][52] = 53,
	[53][53] = 53,
	[53][54] = 53,
	[53][55] = 53,
	[53][56] = 53,
	[53][57] = 53,
	[53][95] = 52,
	[53][97] = 53,
	[53][98] = 53,
	[53][99] = 53,
	[53][100] = 53,
	[53][101] = 53,
	[53][102] = 53,
	[53][103] = 53,
	[53][104] = 53,
	[53][105] = 53,
	[53][106] = 53,
	[53][107] = 53,
	[53][108] = 53,
	[53][109] = 53,
	[53][110] = 53,
	[53][111] = 53,
	[53][112] = 53,
	[53][113] = 53,
	[53][114] = 53,
	[53][115] = 53,
	[53][116] = 53,
	[53][117] = 53,
	[53][118] = 53,
	[53][119] = 53,
	[53][120] = 53,
	[53][121] = 53,
	[53][122] = 53,
	[54][45] = 52,
	[54][46] = 52,
	[54][47] = 52,
	[54][48] = 53,
	[54][49] = 53,
	[54][50] = 53,
	[54][51] = 53,
	[54][52] = 53,
	[54][53] = 53,
	[54][54] = 53,
	[54][55] = 53,
	[54][56] = 53,
	[54][57] = 53,
	[54][95] = 52,
	[54][97] = 53,
	[54][98] = 53,
	[54][99] = 53,
	[54][100] = 53,
	[54][101] = 53,
	[54][102] = 53,
	[54][103] = 53,
	[54][104] = 53,
	[54][105] = 53,
	[54][106] = 53,
	[54][107] = 53,
	[54][108] = 53,
	[54][109] = 53,
	[54][110] = 53,
	[54][111] = 83,
	[54][112] = 53,
	[54][113] = 53,
	[54][114] = 53,
	[54][115] = 53,
	[54][116] = 53,
	[54][117] = 53,
	[54][118] = 53,
	[54][119] = 53,
	[54][120] = 53,
	[54][121] = 53,
	[54][122] = 53,
	[55][45] = 52,
	[55][46] = 52,
	[55][47] = 52,
	[55][48] = 53,
	[55][49] = 53,
	[55][50] = 53,
	[55][51] = 53,
	[55][52] = 53,
	[55][53] = 53,
	[55][54] = 53,
	[55][55] = 53,
	[55][56] = 53,
	[55][57] = 53,
	[55][95] = 52,
	[55][97] = 53,
	[55][98] = 53,
	[55][99] = 53,
	[55][100] = 53,
	[55][101] = 53,
	[55][102] = 84,
	[55][103] = 53,
	[55][104] = 53,
	[55][105] = 53,
	[55][106] = 53,
	[55][107] = 53,
	[55][108] = 53,
	[55][109] = 53,
	[55][110] = 85,
	[55][111] = 53,
	[55][112] = 53,
	[55][113] = 53,
	[55][114] = 53,
	[55][115] = 53,
	[55][116] = 53,
	[55][117] = 53,
	[55][118] = 53,
	[55][119] = 53,
	[55][120] = 53,
	[55][121] = 53,
	[55][122] = 53,
	[58][48] = 58,
	[58][49] = 58,
	[58][50] = 58,
	[58][51] = 58,
	[58][52] = 58,
	[58][53] = 58,
	[58][54] = 58,
	[58][55] = 58,
	[58][56] = 58,
	[58][57] = 58,
	[60][48] = 60,
	[60][49] = 60,
	[60][50] = 60,
	[60][51] = 60,
	[60][52] = 60,
	[60][53] = 60,
	[60][54] = 60,
	[60][55] = 60,
	[60][56] = 60,
	[60][57] = 60,
	[60][97] = 60,
	[60][98] = 60,
	[60][99] = 60,
	[60][100] = 60,
	[60][101] = 60,
	[60][102] = 60,
	[60][103] = 60,
	[60][104] = 60,
	[60][105] = 60,
	[60][106] = 60,
	[60][107] = 60,
	[60][108] = 60,
	[60][109] = 60,
	[60][110] = 60,
	[60][111] = 60,
	[60][112] = 60,
	[60][113] = 60,
	[60][114] = 60,
	[60][115] = 60,
	[60][116] = 60,
	[60][117] = 60,
	[60][118] = 60,
	[60][119] = 60,
	[60][120] = 60,
	[60][121] = 60,
	[60][122] = 60,
	[62][61] = 86,
	[65][61] = 87,
	[69][61] = 88,
	[70][61] = 89,
	[71][61] = 90,
	[73][110] = 91,
	[76][45] = 52,
	[76][46] = 52,
	[76][47] = 52,
	[76][48] = 53,
	[76][49] = 53,
	[76][50] = 53,
	[76][51] = 53,
	[76][52] = 53,
	[76][53] = 53,
	[76][54] = 53,
	[76][55] = 53,
	[76][56] = 53,
	[76][57] = 53,
	[76][95] = 52,
	[76][97] = 53,
	[76][98] = 53,
	[76][99] = 53,
	[76][100] = 53,
	[76][101] = 53,
	[76][102] = 53,
	[76][103] = 53,
	[76][104] = 53,
	[76][105] = 53,
	[76][106] = 53,
	[76][107] = 53,
	[76][108] = 92,
	[76][109] = 53,
	[76][110] = 93,
	[76][111] = 53,
	[76][112] = 53,
	[76][113] = 53,
	[76][114] = 53,
	[76][115] = 53,
	[76][116] = 53,
	[76][117] = 53,
	[76][118] = 53,
	[76][119] = 53,
	[76][120] = 53,
	[76][121] = 53,
	[76][122] = 53,
	[80][45] = 52,
	[80][46] = 52,
	[80][47] = 52,
	[80][48] = 53,
	[80][49] = 53,
	[80][50] = 53,
	[80][51] = 53,
	[80][52] = 53,
	[80][53] = 53,
	[80][54] = 53,
	[80][55] = 53,
	[80][56] = 53,
	[80][57] = 53,
	[80][95] = 52,
	[80][97] = 53,
	[80][98] = 53,
	[80][99] = 53,
	[80][100] = 53,
	[80][101] = 53,
	[80][102] = 53,
	[80][103] = 53,
	[80][104] = 53,
	[80][105] = 53,
	[80][106] = 53,
	[80][107] = 53,
	[80][108] = 53,
	[80][109] = 53,
	[80][110] = 93,
	[80][111] = 53,
	[80][112] = 53,
	[80][113] = 53,
	[80][114] = 53,
	[80][115] = 53,
	[80][116] = 53,
	[80][117] = 53,
	[80][118] = 53,
	[80][119] = 53,
	[80][120] = 53,
	[80][121] = 53,
	[80][122] = 53,
	[81][45] = 52,
	[81][46] = 52,
	[81][47] = 52,
	[81][48] = 53,
	[81][49] = 53,
	[81][50] = 53,
	[81][51] = 53,
	[81][52] = 53,
	[81][53] = 53,
	[81][54] = 53,
	[81][55] = 53,
	[81][56] = 53,
	[81][57] = 53,
	[81][95] = 52,
	[81][97] = 53,
	[81][98] = 53,
	[81][99] = 53,
	[81][100] = 53,
	[81][101] = 53,
	[81][102] = 53,
	[81][103] = 53,
	[81][104] = 53,
	[81][105] = 53,
	[81][106] = 53,
	[81][107] = 53,
	[81][108] = 53,
	[81][109] = 53,
	[81][110] = 94,
	[81][111] = 53,
	[81][112] = 53,
	[81][113] = 53,
	[81][114] = 53,
	[81][115] = 53,
	[81][116] = 53,
	[81][117] = 53,
	[81][118] = 53,
	[81][119] = 53,
	[81][120] = 53,
	[81][121] = 53,
	[81][122] = 53,
	[83][45] = 52,
	[83][46] = 52,
	[83][47] = 52,
	[83][48] = 53,
	[83][49] = 53,
	[83][50] = 53,
	[83][51] = 53,
	[83][52] = 53,
	[83][53] = 53,
	[83][54] = 53,
	[83][55] = 53,
	[83][56] = 53,
	[83][57] = 53,
	[83][95] = 52,
	[83][97] = 53,
	[83][98] = 53,
	[83][99] = 53,
	[83][100] = 53,
	[83][101] = 53,
	[83][102] = 53,
	[83][103] = 53,
	[83][104] = 53,
	[83][105] = 53,
	[83][106] = 53,
	[83][107] = 53,
	[83][108] = 53,
	[83][109] = 53,
	[83][110] = 53,
	[83][111] = 53,
	[83][112] = 53,
	[83][113] = 53,
	[83][114] = 95,
	[83][115] = 53,
	[83][116] = 53,
	[83][117] = 53,
	[83][118] = 53,
	[83][119] = 53,
	[83][120] = 53,
	[83][121] = 53,
	[83][122] = 53,
	[84][45] = 52,
	[84][46] = 52,
	[84][47] = 52,
	[84][48] = 53,
	[84][49] = 53,
	[84][50] = 53,
	[84][51] = 53,
	[84][52] = 53,
	[84][53] = 53,
	[84][54] = 53,
	[84][55] = 53,
	[84][56] = 53,
	[84][57] = 53,
	[84][95] = 52,
	[84][97] = 53,
	[84][98] = 53,
	[84][99] = 53,
	[84][100] = 53,
	[84][101] = 53,
	[84][102] = 53,
	[84][103] = 53,
	[84][104] = 53,
	[84][105] = 53,
	[84][106] = 53,
	[84][107] = 53,
	[84][108] = 53,
	[84][109] = 53,
	[84][110] = 53,
	[84][111] = 53,
	[84][112] = 53,
	[84][113] = 53,
	[84][114] = 53,
	[84][115] = 53,
	[84][116] = 53,
	[84][117] = 53,
	[84][118] = 53,
	[84][119] = 53,
	[84][120] = 53,
	[84][121] = 53,
	[84][122] = 53,
	[85][45] = 52,
	[85][46] = 52,
	[85][47] = 52,
	[85][48] = 53,
	[85][49] = 53,
	[85][50] = 53,
	[85][51] = 53,
	[85][52] = 53,
	[85][53] = 53,
	[85][54] = 53,
	[85][55] = 53,
	[85][56] = 53,
	[85][57] = 53,
	[85][95] = 52,
	[85][97] = 53,
	[85][98] = 53,
	[85][99] = 96,
	[85][100] = 53,
	[85][101] = 53,
	[85][102] = 53,
	[85][103] = 53,
	[85][104] = 53,
	[85][105] = 53,
	[85][106] = 53,
	[85][107] = 53,
	[85][108] = 53,
	[85][109] = 53,
	[85][110] = 53,
	[85][111] = 53,
	[85][112] = 53,
	[85][113] = 53,
	[85][114] = 53,
	[85][115] = 53,
	[85][116] = 53,
	[85][117] = 53,
	[85][118] = 53,
	[85][119] = 53,
	[85][120] = 53,
	[85][121] = 53,
	[85][122] = 53,
	[92][45] = 52,
	[92][46] = 52,
	[92][47] = 52,
	[92][48] = 53,
	[92][49] = 53,
	[92][50] = 53,
	[92][51] = 53,
	[92][52] = 53,
	[92][53] = 53,
	[92][54] = 53,
	[92][55] = 53,
	[92][56] = 53,
	[92][57] = 53,
	[92][95] = 52,
	[92][97] = 53,
	[92][98] = 53,
	[92][99] = 53,
	[92][100] = 53,
	[92][101] = 53,
	[92][102] = 53,
	[92][103] = 53,
	[92][104] = 53,
	[92][105] = 53,
	[92][106] = 53,
	[92][107] = 53,
	[92][108] = 53,
	[92][109] = 53,
	[92][110] = 53,
	[92][111] = 53,
	[92][112] = 53,
	[92][113] = 53,
	[92][114] = 53,
	[92][115] = 97,
	[92][116] = 53,
	[92][117] = 53,
	[92][118] = 53,
	[92][119] = 53,
	[92][120] = 53,
	[92][121] = 53,
	[92][122] = 53,
	[93][45] = 52,
	[93][46] = 52,
	[93][47] = 52,
	[93][48] = 53,
	[93][49] = 53,
	[93][50] = 53,
	[93][51] = 53,
	[93][52] = 53,
	[93][53] = 53,
	[93][54] = 53,
	[93][55] = 53,
	[93][56] = 53,
	[93][57] = 53,
	[93][95] = 52,
	[93][97] = 53,
	[93][98] = 53,
	[93][99] = 53,
	[93][100] = 98,
	[93][101] = 53,
	[93][102] = 53,
	[93][103] = 53,
	[93][104] = 53,
	[93][105] = 53,
	[93][106] = 53,
	[93][107] = 53,
	[93][108] = 53,
	[93][109] = 53,
	[93][110] = 53,
	[93][111] = 53,
	[93][112] = 53,
	[93][113] = 53,
	[93][114] = 53,
	[93][115] = 53,
	[93][116] = 53,
	[93][117] = 53,
	[93][118] = 53,
	[93][119] = 53,
	[93][120] = 53,
	[93][121] = 53,
	[93][122] = 53,
	[94][45] = 52,
	[94][46] = 52,
	[94][47] = 52,
	[94][48] = 53,
	[94][49] = 53,
	[94][50] = 53,
	[94][51] = 53,
	[94][52] = 53,
	[94][53] = 53,
	[94][54] = 53,
	[94][55] = 53,
	[94][56] = 53,
	[94][57] = 53,
	[94][95] = 52,
	[94][97] = 53,
	[94][98] = 53,
	[94][99] = 53,
	[94][100] = 99,
	[94][101] = 53,
	[94][102] = 53,
	[94][103] = 53,
	[94][104] = 53,
	[94][105] = 53,
	[94][106] = 53,
	[94][107] = 53,
	[94][108] = 53,
	[94][109] = 53,
	[94][110] = 53,
	[94][111] = 53,
	[94][112] = 53,
	[94][113] = 53,
	[94][114] = 53,
	[94][115] = 53,
	[94][116] = 53,
	[94][117] = 53,
	[94][118] = 53,
	[94][119] = 53,
	[94][120] = 53,
	[94][121] = 53,
	[94][122] = 53,
	[95][45] = 52,
	[95][46] = 52,
	[95][47] = 52,
	[95][48] = 53,
	[95][49] = 53,
	[95][50] = 53,
	[95][51] = 53,
	[95][52] = 53,
	[95][53] = 53,
	[95][54] = 53,
	[95][55] = 53,
	[95][56] = 53,
	[95][57] = 53,
	[95][95] = 52,
	[95][97] = 53,
	[95][98] = 53,
	[95][99] = 53,
	[95][100] = 53,
	[95][101] = 53,
	[95][102] = 53,
	[95][103] = 53,
	[95][104] = 53,
	[95][105] = 53,
	[95][106] = 53,
	[95][107] = 53,
	[95][108] = 53,
	[95][109] = 53,
	[95][110] = 53,
	[95][111] = 53,
	[95][112] = 53,
	[95][113] = 53,
	[95][114] = 53,
	[95][115] = 53,
	[95][116] = 53,
	[95][117] = 53,
	[95][118] = 53,
	[95][119] = 53,
	[95][120] = 53,
	[95][121] = 53,
	[95][122] = 53,
	[96][45] = 52,
	[96][46] = 52,
	[96][47] = 52,
	[96][48] = 53,
	[96][49] = 53,
	[96][50] = 53,
	[96][51] = 53,
	[96][52] = 53,
	[96][53] = 53,
	[96][54] = 53,
	[96][55] = 53,
	[96][56] = 53,
	[96][57] = 53,
	[96][95] = 52,
	[96][97] = 53,
	[96][98] = 53,
	[96][99] = 53,
	[96][100] = 53,
	[96][101] = 53,
	[96][102] = 53,
	[96][103] = 53,
	[96][104] = 53,
	[96][105] = 53,
	[96][106] = 53,
	[96][107] = 53,
	[96][108] = 100,
	[96][109] = 53,
	[96][110] = 53,
	[96][111] = 53,
	[96][112] = 53,
	[96][113] = 53,
	[96][114] = 53,
	[96][115] = 53,
	[96][116] = 53,
	[96][117] = 53,
	[96][118] = 53,
	[96][119] = 53,
	[96][120] = 53,
	[96][121] = 53,
	[96][122] = 53,
	[97][45] = 52,
	[97][46] = 52,
	[97][47] = 52,
	[97][48] = 53,
	[97][49] = 53,
	[97][50] = 53,
	[97][51] = 53,
	[97][52] = 53,
	[97][53] = 53,
	[97][54] = 53,
	[97][55] = 53,
	[97][56] = 53,
	[97][57] = 53,
	[97][95] = 52,
	[97][97] = 53,
	[97][98] = 53,
	[97][99] = 53,
	[97][100] = 53,
	[97][101] = 101,
	[97][102] = 53,
	[97][103] = 53,
	[97][104] = 53,
	[97][105] = 53,
	[97][106] = 53,
	[97][107] = 53,
	[97][108] = 53,
	[97][109] = 53,
	[97][110] = 53,
	[97][111] = 53,
	[97][112] = 53,
	[97][113] = 53,
	[97][114] = 53,
	[97][115] = 53,
	[97][116] = 53,
	[97][117] = 53,
	[97][118] = 53,
	[97][119] = 53,
	[97][120] = 53,
	[97][121] = 53,
	[97][122] = 53,
	[98][45] = 52,
	[98][46] = 52,
	[98][47] = 52,
	[98][48] = 53,
	[98][49] = 53,
	[98][50] = 53,
	[98][51] = 53,
	[98][52] = 53,
	[98][53] = 53,
	[98][54] = 53,
	[98][55] = 53,
	[98][56] = 53,
	[98][57] = 53,
	[98][95] = 52,
	[98][97] = 53,
	[98][98] = 53,
	[98][99] = 53,
	[98][100] = 53,
	[98][101] = 53,
	[98][102] = 53,
	[98][103] = 53,
	[98][104] = 53,
	[98][105] = 102,
	[98][106] = 53,
	[98][107] = 53,
	[98][108] = 53,
	[98][109] = 53,
	[98][110] = 53,
	[98][111] = 53,
	[98][112] = 53,
	[98][113] = 53,
	[98][114] = 53,
	[98][115] = 53,
	[98][116] = 53,
	[98][117] = 53,
	[98][118] = 53,
	[98][119] = 53,
	[98][120] = 53,
	[98][121] = 53,
	[98][122] = 53,
	[99][45] = 52,
	[99][46] = 52,
	[99][47] = 52,
	[99][48] = 53,
	[99][49] = 53,
	[99][50] = 53,
	[99][51] = 53,
	[99][52] = 53,
	[99][53] = 53,
	[99][54] = 53,
	[99][55] = 53,
	[99][56] = 53,
	[99][57] = 53,
	[99][95] = 52,
	[99][97] = 53,
	[99][98] = 53,
	[99][99] = 53,
	[99][100] = 53,
	[99][101] = 53,
	[99][102] = 103,
	[99][103] = 53,
	[99][104] = 53,
	[99][105] = 53,
	[99][106] = 53,
	[99][107] = 53,
	[99][108] = 53,
	[99][109] = 53,
	[99][110] = 53,
	[99][111] = 53,
	[99][112] = 53,
	[99][113] = 53,
	[99][114] = 53,
	[99][115] = 53,
	[99][116] = 53,
	[99][117] = 53,
	[99][118] = 53,
	[99][119] = 53,
	[99][120] = 53,
	[99][121] = 53,
	[99][122] = 53,
	[100][45] = 52,
	[100][46] = 52,
	[100][47] = 52,
	[100][48] = 53,
	[100][49] = 53,
	[100][50] = 53,
	[100][51] = 53,
	[100][52] = 53,
	[100][53] = 53,
	[100][54] = 53,
	[100][55] = 53,
	[100][56] = 53,
	[100][57] = 53,
	[100][95] = 52,
	[100][97] = 53,
	[100][98] = 53,
	[100][99] = 53,
	[100][100] = 53,
	[100][101] = 53,
	[100][102] = 53,
	[100][103] = 53,
	[100][104] = 53,
	[100][105] = 53,
	[100][106] = 53,
	[100][107] = 53,
	[100][108] = 53,
	[100][109] = 53,
	[100][110] = 53,
	[100][111] = 53,
	[100][112] = 53,
	[100][113] = 53,
	[100][114] = 53,
	[100][115] = 53,
	[100][116] = 53,
	[100][117] = 104,
	[100][118] = 53,
	[100][119] = 53,
	[100][120] = 53,
	[100][121] = 53,
	[100][122] = 53,
	[101][45] = 52,
	[101][46] = 52,
	[101][47] = 52,
	[101][48] = 53,
	[101][49] = 53,
	[101][50] = 53,
	[101][51] = 53,
	[101][52] = 53,
	[101][53] = 53,
	[101][54] = 53,
	[101][55] = 53,
	[101][56] = 53,
	[101][57] = 53,
	[101][95] = 52,
	[101][97] = 53,
	[101][98] = 53,
	[101][99] = 53,
	[101][100] = 53,
	[101][101] = 53,
	[101][102] = 53,
	[101][103] = 53,
	[101][104] = 53,
	[101][105] = 53,
	[101][106] = 53,
	[101][107] = 53,
	[101][108] = 53,
	[101][109] = 53,
	[101][110] = 53,
	[101][111] = 53,
	[101][112] = 53,
	[101][113] = 53,
	[101][114] = 53,
	[101][115] = 53,
	[101][116] = 53,
	[101][117] = 53,
	[101][118] = 53,
	[101][119] = 53,
	[101][120] = 53,
	[101][121] = 53,
	[101][122] = 53,
	[102][45] = 52,
	[102][46] = 52,
	[102][47] = 52,
	[102][48] = 53,
	[102][49] = 53,
	[102][50] = 53,
	[102][51] = 53,
	[102][52] = 53,
	[102][53] = 53,
	[102][54] = 53,
	[102][55] = 53,
	[102][56] = 53,
	[102][57] = 53,
	[102][95] = 52,
	[102][97] = 53,
	[102][98] = 53,
	[102][99] = 53,
	[102][100] = 53,
	[102][101] = 53,
	[102][102] = 105,
	[102][103] = 53,
	[102][104] = 53,
	[102][105] = 53,
	[102][106] = 53,
	[102][107] = 53,
	[102][108] = 53,
	[102][109] = 53,
	[102][110] = 53,
	[102][111] = 53,
	[102][112] = 53,
	[102][113] = 53,
	[102][114] = 53,
	[102][115] = 53,
	[102][116] = 53,
	[102][117] = 53,
	[102][118] = 53,
	[102][119] = 53,
	[102][120] = 53,
	[102][121] = 53,
	[102][122] = 53,
	[103][45] = 52,
	[103][46] = 52,
	[103][47] = 52,
	[103][48] = 53,
	[103][49] = 53,
	[103][50] = 53,
	[103][51] = 53,
	[103][52] = 53,
	[103][53] = 53,
	[103][54] = 53,
	[103][55] = 53,
	[103][56] = 53,
	[103][57] = 53,
	[103][95] = 52,
	[103][97] = 53,
	[103][98] = 53,
	[103][99] = 53,
	[103][100] = 53,
	[103][101] = 53,
	[103][102] = 53,
	[103][103] = 53,
	[103][104] = 53,
	[103][105] = 53,
	[103][106] = 53,
	[103][107] = 53,
	[103][108] = 53,
	[103][109] = 53,
	[103][110] = 53,
	[103][111] = 106,
	[103][112] = 53,
	[103][113] = 53,
	[103][114] = 53,
	[103][115] = 53,
	[103][116] = 53,
	[103][117] = 53,
	[103][118] = 53,
	[103][119] = 53,
	[103][120] = 53,
	[103][121] = 53,
	[103][122] = 53,
	[104][45] = 52,
	[104][46] = 52,
	[104][47] = 52,
	[104][48] = 53,
	[104][49] = 53,
	[104][50] = 53,
	[104][51] = 53,
	[104][52] = 53,
	[104][53] = 53,
	[104][54] = 53,
	[104][55] = 53,
	[104][56] = 53,
	[104][57] = 53,
	[104][95] = 52,
	[104][97] = 53,
	[104][98] = 53,
	[104][99] = 53,
	[104][100] = 107,
	[104][101] = 53,
	[104][102] = 53,
	[104][103] = 53,
	[104][104] = 53,
	[104][105] = 53,
	[104][106] = 53,
	[104][107] = 53,
	[104][108] = 53,
	[104][109] = 53,
	[104][110] = 53,
	[104][111] = 53,
	[104][112] = 53,
	[104][113] = 53,
	[104][114] = 53,
	[104][115] = 53,
	[104][116] = 53,
	[104][117] = 53,
	[104][118] = 53,
	[104][119] = 53,
	[104][120] = 53,
	[104][121] = 53,
	[104][122] = 53,
	[105][45] = 52,
	[105][46] = 52,
	[105][47] = 52,
	[105][48] = 53,
	[105][49] = 53,
	[105][50] = 53,
	[105][51] = 53,
	[105][52] = 53,
	[105][53] = 53,
	[105][54] = 53,
	[105][55] = 53,
	[105][56] = 53,
	[105][57] = 53,
	[105][95] = 52,
	[105][97] = 53,
	[105][98] = 53,
	[105][99] = 53,
	[105][100] = 53,
	[105][101] = 53,
	[105][102] = 53,
	[105][103] = 53,
	[105][104] = 53,
	[105][105] = 53,
	[105][106] = 53,
	[105][107] = 53,
	[105][108] = 53,
	[105][109] = 53,
	[105][110] = 53,
	[105][111] = 53,
	[105][112] = 53,
	[105][113] = 53,
	[105][114] = 53,
	[105][115] = 53,
	[105][116] = 53,
	[105][117] = 53,
	[105][118] = 53,
	[105][119] = 53,
	[105][120] = 53,
	[105][121] = 53,
	[105][122] = 53,
	[106][45] = 52,
	[106][46] = 52,
	[106][47] = 52,
	[106][48] = 53,
	[106][49] = 53,
	[106][50] = 53,
	[106][51] = 53,
	[106][52] = 53,
	[106][53] = 53,
	[106][54] = 53,
	[106][55] = 53,
	[106][56] = 53,
	[106][57] = 53,
	[106][95] = 52,
	[106][97] = 53,
	[106][98] = 53,
	[106][99] = 53,
	[106][100] = 53,
	[106][101] = 53,
	[106][102] = 53,
	[106][103] = 53,
	[106][104] = 53,
	[106][105] = 53,
	[106][106] = 53,
	[106][107] = 53,
	[106][108] = 53,
	[106][109] = 53,
	[106][110] = 53,
	[106][111] = 53,
	[106][112] = 53,
	[106][113] = 53,
	[106][114] = 108,
	[106][115] = 53,
	[106][116] = 53,
	[106][117] = 53,
	[106][118] = 53,
	[106][119] = 53,
	[106][120] = 53,
	[106][121] = 53,
	[106][122] = 53,
	[107][45] = 52,
	[107][46] = 52,
	[107][47] = 52,
	[107][48] = 53,
	[107][49] = 53,
	[107][50] = 53,
	[107][51] = 53,
	[107][52] = 53,
	[107][53] = 53,
	[107][54] = 53,
	[107][55] = 53,
	[107][56] = 53,
	[107][57] = 53,
	[107][95] = 52,
	[107][97] = 53,
	[107][98] = 53,
	[107][99] = 53,
	[107][100] = 53,
	[107][101] = 109,
	[107][102] = 53,
	[107][103] = 53,
	[107][104] = 53,
	[107][105] = 53,
	[107][106] = 53,
	[107][107] = 53,
	[107][108] = 53,
	[107][109] = 53,
	[107][110] = 53,
	[107][111] = 53,
	[107][112] = 53,
	[107][113] = 53,
	[107][114] = 53,
	[107][115] = 53,
	[107][116] = 53,
	[107][117] = 53,
	[107][118] = 53,
	[107][119] = 53,
	[107][120] = 53,
	[107][121] = 53,
	[107][122] = 53,
	[108][45] = 52,
	[108][46] = 52,
	[108][47] = 52,
	[108][48] = 53,
	[108][49] = 53,
	[108][50] = 53,
	[108][51] = 53,
	[108][52] = 53,
	[108][53] = 53,
	[108][54] = 53,
	[108][55] = 53,
	[108][56] = 53,
	[108][57] = 53,
	[108][95] = 52,
	[108][97] = 53,
	[108][98] = 53,
	[108][99] = 53,
	[108][100] = 53,
	[108][101] = 53,
	[108][102] = 53,
	[108][103] = 53,
	[108][104] = 53,
	[108][105] = 53,
	[108][106] = 53,
	[108][107] = 53,
	[108][108] = 53,
	[108][109] = 53,
	[108][110] = 53,
	[108][111] = 53,
	[108][112] = 53,
	[108][113] = 53,
	[108][114] = 53,
	[108][115] = 53,
	[108][116] = 53,
	[108][117] = 53,
	[108][118] = 53,
	[108][119] = 53,
	[108][120] = 53,
	[108][121] = 53,
	[108][122] = 53,
	[109][45] = 52,
	[109][46] = 52,
	[109][47] = 52,
	[109][48] = 53,
	[109][49] = 53,
	[109][50] = 53,
	[109][51] = 53,
	[109][52] = 53,
	[109][53] = 53,
	[109][54] = 53,
	[109][55] = 53,
	[109][56] = 53,
	[109][57] = 53,
	[109][95] = 52,
	[109][97] = 53,
	[109][98] = 53,
	[109][99] = 53,
	[109][100] = 53,
	[109][101] = 53,
	[109][102] = 53,
	[109][103] = 53,
	[109][104] = 53,
	[109][105] = 53,
	[109][106] = 53,
	[109][107] = 53,
	[109][108] = 53,
	[109][109] = 53,
	[109][110] = 53,
	[109][111] = 53,
	[109][112] = 53,
	[109][113] = 53,
	[109][114] = 53,
	[109][115] = 53,
	[109][116] = 53,
	[109][117] = 53,
	[109][118] = 53,
	[109][119] = 53,
	[109][120] = 53,
	[109][121] = 53,
	[109][122] = 53,
};


const unsigned zebu_lexer_accepts[110] = {
	[47] = 1,
	[48] = 6,
	[51] = 2,
	[52] = 4,
	[53] = 5,
	[54] = 5,
	[55] = 5,
	[56] = 13,
	[57] = 14,
	[58] = 12,
	[59] = 10,
	[60] = 11,
	[61] = 15,
	[63] = 16,
	[64] = 18,
	[66] = 19,
	[67] = 22,
	[68] = 23,
	[69] = 20,
	[71] = 21,
	[72] = 28,
	[74] = 30,
	[75] = 31,
	[76] = 5,
	[77] = 20,
	[78] = 21,
	[79] = 34,
	[80] = 5,
	[81] = 5,
	[82] = 3,
	[83] = 5,
	[84] = 7,
	[85] = 5,
	[86] = 17,
	[87] = 27,
	[88] = 25,
	[89] = 26,
	[90] = 24,
	[91] = 29,
	[92] = 5,
	[93] = 5,
	[94] = 5,
	[95] = 8,
	[96] = 5,
	[97] = 5,
	[98] = 5,
	[99] = 5,
	[100] = 5,
	[101] = 32,
	[102] = 5,
	[103] = 5,
	[104] = 5,
	[105] = 33,
	[106] = 5,
	[107] = 5,
	[108] = 35,
	[109] = 9,
};


const unsigned zebu_lexer_EOFs[34] = {
	[7] = 64,
	[8] = 64,
	[32] = 64,
	[33] = 64,
};


#ifdef ZEBU_DEBUG
#include <stdbool.h>

struct link
{
    bool is_last;
    struct link* prev;
};

static void print_links(struct link* link)
{
    if (!link) return;
    print_links(link->prev);
    fputs(link->is_last ? "    " : "│   ", stdout);
}

static void print_tree_escape(char *out, char in)
{
    switch (in)
    {
        case ' ':
        case '~':
        case '!':
        case '@':
        case '#':
        case '$':
        case '%':
        case '^':
        case '&':
        case '*':
        case '-':
        case '+':
        case '=':
        case '|':
        case '<': case '>':
        case '(': case ')':
        case '{': case '}':
        case '[': case ']':
        case ':': case ';':
        case ',': case '.':
        case '_':
        case '/':
        case '`':
        case '0' ... '9':
        case 'a' ... 'z':
        case 'A' ... 'Z':
            *out++ = in;
            *out = 0;
            break;
        
        case '\\': *out++ = '\\', *out++ = '\\', *out = 0; break;
        
        case '\'': *out++ = '\\', *out++ = '\'', *out = 0; break;
        
        case '\"': *out++ = '\\', *out++ = '\"', *out = 0; break;
        
        case '\t': *out++ = '\\', *out++ = 't', *out = 0; break;
        
        case '\n': *out++ = '\\', *out++ = 'n', *out = 0; break;
        
        default:
            sprintf(out, "\\x%02X", in);
            break;
    }
}

enum prefix
{
p_root,
p_not_last_child,
p_last_child,
};

void print_token_leaf(struct link* links, enum prefix p, const char* name, struct zebu_token* token)
{
print_links(links);
switch (p)
{
case p_root: break;
case p_not_last_child: fputs("├── ", stdout); break;
case p_last_child: fputs("└── ", stdout); break;
}
printf("\e[32m%s\e[0m (\e[35m\"", name);
char escape[10];
for (unsigned i = 0, n = token->len; i < n; i++)
print_tree_escape(escape, token->data[i]), fputs(escape, stdout);
printf("\"\e[0m)");
#if ZEBU_LINE_NUMBERS
printf(" on line %u", token->line);
#endif
printf("\n");
}

void print_scanf_leaf(struct link* links, enum prefix p, const char* name, const char* format, ...)
{
va_list ap;
print_links(links);
switch (p)
{
case p_root: break;
case p_not_last_child: fputs("├── ", stdout); break;
case p_last_child: fputs("└── ", stdout); break;
}
printf("\e[32m%s\e[0m (\e[35m%s\e[m: \e[35m", name, format);
va_start(ap, format);
vprintf(format, ap);
va_end(ap);
printf("\e[0m)\n");
}

void print_empty_leaf(struct link* links, enum prefix p, const char* type, const char* name)
{
print_links(links);
switch (p)
{
case p_root: break;
case p_not_last_child: fputs("├── ", stdout); break;
case p_last_child: fputs("└── ", stdout); break;
}
printf("\e[31m%s\e[0m (\e[36m%s\e[0m)\n", name, type);
}
void print_zebu_$start(struct link* links, enum prefix p, const char* name, struct zebu_$start* ptree);

void print_zebu_additive_expression(struct link* links, enum prefix p, const char* name, struct zebu_additive_expression* ptree);

void print_zebu_argument(struct link* links, enum prefix p, const char* name, struct zebu_argument* ptree);

void print_zebu_assignment(struct link* links, enum prefix p, const char* name, struct zebu_assignment* ptree);

void print_zebu_command(struct link* links, enum prefix p, const char* name, struct zebu_command* ptree);

void print_zebu_commands(struct link* links, enum prefix p, const char* name, struct zebu_commands* ptree);

void print_zebu_conditional(struct link* links, enum prefix p, const char* name, struct zebu_conditional* ptree);

void print_zebu_equality_expression(struct link* links, enum prefix p, const char* name, struct zebu_equality_expression* ptree);

void print_zebu_expression(struct link* links, enum prefix p, const char* name, struct zebu_expression* ptree);

void print_zebu_include(struct link* links, enum prefix p, const char* name, struct zebu_include* ptree);

void print_zebu_iterative(struct link* links, enum prefix p, const char* name, struct zebu_iterative* ptree);

void print_zebu_multiplicative_expression(struct link* links, enum prefix p, const char* name, struct zebu_multiplicative_expression* ptree);

void print_zebu_postfix_expression(struct link* links, enum prefix p, const char* name, struct zebu_postfix_expression* ptree);

void print_zebu_prefix_expression(struct link* links, enum prefix p, const char* name, struct zebu_prefix_expression* ptree);

void print_zebu_primary_expression(struct link* links, enum prefix p, const char* name, struct zebu_primary_expression* ptree);

void print_zebu_recipe(struct link* links, enum prefix p, const char* name, struct zebu_recipe* ptree);

void print_zebu_relational_expression(struct link* links, enum prefix p, const char* name, struct zebu_relational_expression* ptree);

void print_zebu_root(struct link* links, enum prefix p, const char* name, struct zebu_root* ptree);

void print_zebu_simple_command(struct link* links, enum prefix p, const char* name, struct zebu_simple_command* ptree);

void print_zebu_statement(struct link* links, enum prefix p, const char* name, struct zebu_statement* ptree);

void print_zebu_$start(struct link* links, enum prefix p, const char* name, struct zebu_$start* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36m$start\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->root)
print_zebu_root(new ?: links, p_last_child, "root", ptree->root);
else
print_empty_leaf(new ?: links, p_last_child, "root", "root");
free(new);
}
void print_zebu_additive_expression(struct link* links, enum prefix p, const char* name, struct zebu_additive_expression* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36madditive_expression\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->add)
print_token_leaf(new ?: links, p_not_last_child, "add", ptree->add);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "add");
if (ptree->inner)
print_zebu_multiplicative_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
else
print_empty_leaf(new ?: links, p_not_last_child, "multiplicative_expression", "inner");
if (ptree->left)
print_zebu_additive_expression(new ?: links, p_not_last_child, "left", ptree->left);
else
print_empty_leaf(new ?: links, p_not_last_child, "additive_expression", "left");
if (ptree->right)
print_zebu_multiplicative_expression(new ?: links, p_not_last_child, "right", ptree->right);
else
print_empty_leaf(new ?: links, p_not_last_child, "multiplicative_expression", "right");
if (ptree->sub)
print_token_leaf(new ?: links, p_last_child, "sub", ptree->sub);
else
print_empty_leaf(new ?: links, p_last_child, "token", "sub");
free(new);
}
void print_zebu_argument(struct link* links, enum prefix p, const char* name, struct zebu_argument* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36margument\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->expression)
print_zebu_expression(new ?: links, p_not_last_child, "expression", ptree->expression);
else
print_empty_leaf(new ?: links, p_not_last_child, "expression", "expression");
if (ptree->string)
print_token_leaf(new ?: links, p_not_last_child, "string", ptree->string);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "string");
if (ptree->text)
print_token_leaf(new ?: links, p_last_child, "text", ptree->text);
else
print_empty_leaf(new ?: links, p_last_child, "token", "text");
free(new);
}
void print_zebu_assignment(struct link* links, enum prefix p, const char* name, struct zebu_assignment* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36massignment\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->eq)
print_token_leaf(new ?: links, p_not_last_child, "eq", ptree->eq);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "eq");
if (ptree->expression)
print_zebu_expression(new ?: links, p_not_last_child, "expression", ptree->expression);
else
print_empty_leaf(new ?: links, p_not_last_child, "expression", "expression");
if (ptree->peq)
print_token_leaf(new ?: links, p_not_last_child, "peq", ptree->peq);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "peq");
if (ptree->variable)
print_token_leaf(new ?: links, p_last_child, "variable", ptree->variable);
else
print_empty_leaf(new ?: links, p_last_child, "token", "variable");
free(new);
}
void print_zebu_command(struct link* links, enum prefix p, const char* name, struct zebu_command* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mcommand\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->redirect_in)
print_zebu_argument(new ?: links, p_not_last_child, "redirect_in", ptree->redirect_in);
else
print_empty_leaf(new ?: links, p_not_last_child, "argument", "redirect_in");
if (ptree->redirect_out)
print_zebu_argument(new ?: links, p_not_last_child, "redirect_out", ptree->redirect_out);
else
print_empty_leaf(new ?: links, p_not_last_child, "argument", "redirect_out");
if (ptree->simples.n)
{
for (unsigned i = 0, n = ptree->simples.n; i < n; i++)
{
char label[7 + 30];
snprintf(label, sizeof(label), "simples[%u]", i);
print_zebu_simple_command(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->simples.data[i]);
}
}
else
{
print_empty_leaf(new ?: links, p_last_child, "simple_command[]", "simples");
}
free(new);
}
void print_zebu_commands(struct link* links, enum prefix p, const char* name, struct zebu_commands* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mcommands\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->commands.n)
{
for (unsigned i = 0, n = ptree->commands.n; i < n; i++)
{
char label[8 + 30];
snprintf(label, sizeof(label), "commands[%u]", i);
print_zebu_command(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->commands.data[i]);
}
}
else
{
print_empty_leaf(new ?: links, p_last_child, "command[]", "commands");
}
free(new);
}
void print_zebu_conditional(struct link* links, enum prefix p, const char* name, struct zebu_conditional* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mconditional\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
free(new);
}
void print_zebu_equality_expression(struct link* links, enum prefix p, const char* name, struct zebu_equality_expression* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mequality_expression\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->eq)
print_token_leaf(new ?: links, p_not_last_child, "eq", ptree->eq);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "eq");
if (ptree->inner)
print_zebu_relational_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
else
print_empty_leaf(new ?: links, p_not_last_child, "relational_expression", "inner");
if (ptree->left)
print_zebu_equality_expression(new ?: links, p_not_last_child, "left", ptree->left);
else
print_empty_leaf(new ?: links, p_not_last_child, "equality_expression", "left");
if (ptree->nq)
print_token_leaf(new ?: links, p_not_last_child, "nq", ptree->nq);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "nq");
if (ptree->right)
print_zebu_relational_expression(new ?: links, p_last_child, "right", ptree->right);
else
print_empty_leaf(new ?: links, p_last_child, "relational_expression", "right");
free(new);
}
void print_zebu_expression(struct link* links, enum prefix p, const char* name, struct zebu_expression* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mexpression\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->inner)
print_zebu_equality_expression(new ?: links, p_last_child, "inner", ptree->inner);
else
print_empty_leaf(new ?: links, p_last_child, "equality_expression", "inner");
free(new);
}
void print_zebu_include(struct link* links, enum prefix p, const char* name, struct zebu_include* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36minclude\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->argument)
print_zebu_argument(new ?: links, p_last_child, "argument", ptree->argument);
else
print_empty_leaf(new ?: links, p_last_child, "argument", "argument");
free(new);
}
void print_zebu_iterative(struct link* links, enum prefix p, const char* name, struct zebu_iterative* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36miterative\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->body.n)
{
for (unsigned i = 0, n = ptree->body.n; i < n; i++)
{
char label[4 + 30];
snprintf(label, sizeof(label), "body[%u]", i);
print_zebu_statement(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->body.data[i]);
}
}
else
{
print_empty_leaf(new ?: links, p_not_last_child, "statement[]", "body");
}
if (ptree->list)
print_zebu_expression(new ?: links, p_not_last_child, "list", ptree->list);
else
print_empty_leaf(new ?: links, p_not_last_child, "expression", "list");
if (ptree->variable)
print_token_leaf(new ?: links, p_last_child, "variable", ptree->variable);
else
print_empty_leaf(new ?: links, p_last_child, "token", "variable");
free(new);
}
void print_zebu_multiplicative_expression(struct link* links, enum prefix p, const char* name, struct zebu_multiplicative_expression* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mmultiplicative_expression\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->div)
print_token_leaf(new ?: links, p_not_last_child, "div", ptree->div);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "div");
if (ptree->inner)
print_zebu_prefix_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
else
print_empty_leaf(new ?: links, p_not_last_child, "prefix_expression", "inner");
if (ptree->left)
print_zebu_multiplicative_expression(new ?: links, p_not_last_child, "left", ptree->left);
else
print_empty_leaf(new ?: links, p_not_last_child, "multiplicative_expression", "left");
if (ptree->mul)
print_token_leaf(new ?: links, p_not_last_child, "mul", ptree->mul);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "mul");
if (ptree->right)
print_zebu_prefix_expression(new ?: links, p_last_child, "right", ptree->right);
else
print_empty_leaf(new ?: links, p_last_child, "prefix_expression", "right");
free(new);
}
void print_zebu_postfix_expression(struct link* links, enum prefix p, const char* name, struct zebu_postfix_expression* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mpostfix_expression\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->inner)
print_zebu_primary_expression(new ?: links, p_last_child, "inner", ptree->inner);
else
print_empty_leaf(new ?: links, p_last_child, "primary_expression", "inner");
free(new);
}
void print_zebu_prefix_expression(struct link* links, enum prefix p, const char* name, struct zebu_prefix_expression* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mprefix_expression\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->inner)
print_zebu_postfix_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
else
print_empty_leaf(new ?: links, p_not_last_child, "postfix_expression", "inner");
if (ptree->neg)
print_token_leaf(new ?: links, p_not_last_child, "neg", ptree->neg);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "neg");
if (ptree->pos)
print_token_leaf(new ?: links, p_not_last_child, "pos", ptree->pos);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "pos");
if (ptree->sub)
print_zebu_prefix_expression(new ?: links, p_last_child, "sub", ptree->sub);
else
print_empty_leaf(new ?: links, p_last_child, "prefix_expression", "sub");
free(new);
}
void print_zebu_primary_expression(struct link* links, enum prefix p, const char* name, struct zebu_primary_expression* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mprimary_expression\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->elements.n)
{
for (unsigned i = 0, n = ptree->elements.n; i < n; i++)
{
char label[8 + 30];
snprintf(label, sizeof(label), "elements[%u]", i);
print_zebu_expression(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->elements.data[i]);
}
}
else
{
print_empty_leaf(new ?: links, p_not_last_child, "expression[]", "elements");
}
if (ptree->inner)
print_zebu_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
else
print_empty_leaf(new ?: links, p_not_last_child, "expression", "inner");
if (ptree->integer)
print_token_leaf(new ?: links, p_not_last_child, "integer", ptree->integer);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "integer");
if (ptree->list)
print_token_leaf(new ?: links, p_not_last_child, "list", ptree->list);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "list");
if (ptree->string)
print_token_leaf(new ?: links, p_not_last_child, "string", ptree->string);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "string");
if (ptree->variable)
print_token_leaf(new ?: links, p_last_child, "variable", ptree->variable);
else
print_empty_leaf(new ?: links, p_last_child, "token", "variable");
free(new);
}
void print_zebu_recipe(struct link* links, enum prefix p, const char* name, struct zebu_recipe* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mrecipe\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->commands)
print_zebu_commands(new ?: links, p_not_last_child, "commands", ptree->commands);
else
print_empty_leaf(new ?: links, p_not_last_child, "commands", "commands");
if (ptree->dependencies.n)
{
for (unsigned i = 0, n = ptree->dependencies.n; i < n; i++)
{
char label[12 + 30];
snprintf(label, sizeof(label), "dependencies[%u]", i);
print_zebu_argument(new ?: links, i + 1 < n ? p_not_last_child : p_not_last_child, label, ptree->dependencies.data[i]);
}
}
else
{
print_empty_leaf(new ?: links, p_not_last_child, "argument[]", "dependencies");
}
if (ptree->target)
print_zebu_argument(new ?: links, p_last_child, "target", ptree->target);
else
print_empty_leaf(new ?: links, p_last_child, "argument", "target");
free(new);
}
void print_zebu_relational_expression(struct link* links, enum prefix p, const char* name, struct zebu_relational_expression* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mrelational_expression\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->gt)
print_token_leaf(new ?: links, p_not_last_child, "gt", ptree->gt);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "gt");
if (ptree->gte)
print_token_leaf(new ?: links, p_not_last_child, "gte", ptree->gte);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "gte");
if (ptree->inner)
print_zebu_additive_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
else
print_empty_leaf(new ?: links, p_not_last_child, "additive_expression", "inner");
if (ptree->left)
print_zebu_relational_expression(new ?: links, p_not_last_child, "left", ptree->left);
else
print_empty_leaf(new ?: links, p_not_last_child, "relational_expression", "left");
if (ptree->lt)
print_token_leaf(new ?: links, p_not_last_child, "lt", ptree->lt);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "lt");
if (ptree->lte)
print_token_leaf(new ?: links, p_not_last_child, "lte", ptree->lte);
else
print_empty_leaf(new ?: links, p_not_last_child, "token", "lte");
if (ptree->right)
print_zebu_additive_expression(new ?: links, p_last_child, "right", ptree->right);
else
print_empty_leaf(new ?: links, p_last_child, "additive_expression", "right");
free(new);
}
void print_zebu_root(struct link* links, enum prefix p, const char* name, struct zebu_root* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mroot\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->statements.n)
{
for (unsigned i = 0, n = ptree->statements.n; i < n; i++)
{
char label[10 + 30];
snprintf(label, sizeof(label), "statements[%u]", i);
print_zebu_statement(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->statements.data[i]);
}
}
else
{
print_empty_leaf(new ?: links, p_last_child, "statement[]", "statements");
}
free(new);
}
void print_zebu_simple_command(struct link* links, enum prefix p, const char* name, struct zebu_simple_command* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36msimple_command\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->args.n)
{
for (unsigned i = 0, n = ptree->args.n; i < n; i++)
{
char label[4 + 30];
snprintf(label, sizeof(label), "args[%u]", i);
print_zebu_argument(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->args.data[i]);
}
}
else
{
print_empty_leaf(new ?: links, p_last_child, "argument[]", "args");
}
free(new);
}
void print_zebu_statement(struct link* links, enum prefix p, const char* name, struct zebu_statement* ptree)
{
print_links(links);

struct link* new = NULL;

switch (p)
{
case p_root:
break;

case p_not_last_child:
fputs("├── ", stdout);
new = malloc(sizeof(*new));
new->is_last = false;
new->prev = links;
break;

case p_last_child:
fputs("└── ", stdout);
new = malloc(sizeof(*new));
new->is_last = true;
new->prev = links;
break;
}
printf("\e[34m%s\e[m (\e[36mstatement\e[m)", name);
#if ZEBU_LINE_NUMBERS
printf(" on line %u through %u", ptree->startline, ptree->endline);
#endif
printf("\n");
if (ptree->assignment)
print_zebu_assignment(new ?: links, p_not_last_child, "assignment", ptree->assignment);
else
print_empty_leaf(new ?: links, p_not_last_child, "assignment", "assignment");
if (ptree->conditional)
print_zebu_conditional(new ?: links, p_not_last_child, "conditional", ptree->conditional);
else
print_empty_leaf(new ?: links, p_not_last_child, "conditional", "conditional");
if (ptree->include)
print_zebu_include(new ?: links, p_not_last_child, "include", ptree->include);
else
print_empty_leaf(new ?: links, p_not_last_child, "include", "include");
if (ptree->iterative)
print_zebu_iterative(new ?: links, p_not_last_child, "iterative", ptree->iterative);
else
print_empty_leaf(new ?: links, p_not_last_child, "iterative", "iterative");
if (ptree->recipe)
print_zebu_recipe(new ?: links, p_last_child, "recipe", ptree->recipe);
else
print_empty_leaf(new ?: links, p_last_child, "recipe", "recipe");
free(new);
}

#endif

struct zebu_token* inc_zebu_token(struct zebu_token* token)
{
	if (token) token->refcount++;
	return token;
}
struct zebu_$start* inc_zebu_$start(struct zebu_$start* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_additive_expression* inc_zebu_additive_expression(struct zebu_additive_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_argument* inc_zebu_argument(struct zebu_argument* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_assignment* inc_zebu_assignment(struct zebu_assignment* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_command* inc_zebu_command(struct zebu_command* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_commands* inc_zebu_commands(struct zebu_commands* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_conditional* inc_zebu_conditional(struct zebu_conditional* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_equality_expression* inc_zebu_equality_expression(struct zebu_equality_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_expression* inc_zebu_expression(struct zebu_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_include* inc_zebu_include(struct zebu_include* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_iterative* inc_zebu_iterative(struct zebu_iterative* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_multiplicative_expression* inc_zebu_multiplicative_expression(struct zebu_multiplicative_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_postfix_expression* inc_zebu_postfix_expression(struct zebu_postfix_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_prefix_expression* inc_zebu_prefix_expression(struct zebu_prefix_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_primary_expression* inc_zebu_primary_expression(struct zebu_primary_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_recipe* inc_zebu_recipe(struct zebu_recipe* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_relational_expression* inc_zebu_relational_expression(struct zebu_relational_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_root* inc_zebu_root(struct zebu_root* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_simple_command* inc_zebu_simple_command(struct zebu_simple_command* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_statement* inc_zebu_statement(struct zebu_statement* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}



extern void free_zebu_token(struct zebu_token* token);
extern void free_zebu_$start(struct zebu_$start* ptree);

extern void free_zebu_additive_expression(struct zebu_additive_expression* ptree);

extern void free_zebu_argument(struct zebu_argument* ptree);

extern void free_zebu_assignment(struct zebu_assignment* ptree);

extern void free_zebu_command(struct zebu_command* ptree);

extern void free_zebu_commands(struct zebu_commands* ptree);

extern void free_zebu_conditional(struct zebu_conditional* ptree);

extern void free_zebu_equality_expression(struct zebu_equality_expression* ptree);

extern void free_zebu_expression(struct zebu_expression* ptree);

extern void free_zebu_include(struct zebu_include* ptree);

extern void free_zebu_iterative(struct zebu_iterative* ptree);

extern void free_zebu_multiplicative_expression(struct zebu_multiplicative_expression* ptree);

extern void free_zebu_postfix_expression(struct zebu_postfix_expression* ptree);

extern void free_zebu_prefix_expression(struct zebu_prefix_expression* ptree);

extern void free_zebu_primary_expression(struct zebu_primary_expression* ptree);

extern void free_zebu_recipe(struct zebu_recipe* ptree);

extern void free_zebu_relational_expression(struct zebu_relational_expression* ptree);

extern void free_zebu_root(struct zebu_root* ptree);

extern void free_zebu_simple_command(struct zebu_simple_command* ptree);

extern void free_zebu_statement(struct zebu_statement* ptree);

void free_zebu_token(struct zebu_token* token)
{
	if (token && !--token->refcount)
	{
		free(token->data);
		free(token);
	}
}
void free_zebu_$start(struct zebu_$start* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_root(ptree->root);
		free(ptree);
	}
}

void free_zebu_additive_expression(struct zebu_additive_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->add);
		free_zebu_multiplicative_expression(ptree->inner);
		free_zebu_additive_expression(ptree->left);
		free_zebu_multiplicative_expression(ptree->right);
		free_zebu_token(ptree->sub);
		free(ptree);
	}
}

void free_zebu_argument(struct zebu_argument* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_expression(ptree->expression);
		free_zebu_token(ptree->string);
		free_zebu_token(ptree->text);
		free(ptree);
	}
}

void free_zebu_assignment(struct zebu_assignment* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->eq);
		free_zebu_expression(ptree->expression);
		free_zebu_token(ptree->peq);
		free_zebu_token(ptree->variable);
		free(ptree);
	}
}

void free_zebu_command(struct zebu_command* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_argument(ptree->redirect_in);
		free_zebu_argument(ptree->redirect_out);
		for (unsigned i = 0, n = ptree->simples.n; i < n; i++)
			free_zebu_simple_command(ptree->simples.data[i]);
		free(ptree->simples.data);
		free(ptree);
	}
}

void free_zebu_commands(struct zebu_commands* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		for (unsigned i = 0, n = ptree->commands.n; i < n; i++)
			free_zebu_command(ptree->commands.data[i]);
		free(ptree->commands.data);
		free(ptree);
	}
}

void free_zebu_conditional(struct zebu_conditional* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free(ptree);
	}
}

void free_zebu_equality_expression(struct zebu_equality_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->eq);
		free_zebu_relational_expression(ptree->inner);
		free_zebu_equality_expression(ptree->left);
		free_zebu_token(ptree->nq);
		free_zebu_relational_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_expression(struct zebu_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_equality_expression(ptree->inner);
		free(ptree);
	}
}

void free_zebu_include(struct zebu_include* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_argument(ptree->argument);
		free(ptree);
	}
}

void free_zebu_iterative(struct zebu_iterative* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		for (unsigned i = 0, n = ptree->body.n; i < n; i++)
			free_zebu_statement(ptree->body.data[i]);
		free(ptree->body.data);
		free_zebu_expression(ptree->list);
		free_zebu_token(ptree->variable);
		free(ptree);
	}
}

void free_zebu_multiplicative_expression(struct zebu_multiplicative_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->div);
		free_zebu_prefix_expression(ptree->inner);
		free_zebu_multiplicative_expression(ptree->left);
		free_zebu_token(ptree->mul);
		free_zebu_prefix_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_postfix_expression(struct zebu_postfix_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_primary_expression(ptree->inner);
		free(ptree);
	}
}

void free_zebu_prefix_expression(struct zebu_prefix_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_postfix_expression(ptree->inner);
		free_zebu_token(ptree->neg);
		free_zebu_token(ptree->pos);
		free_zebu_prefix_expression(ptree->sub);
		free(ptree);
	}
}

void free_zebu_primary_expression(struct zebu_primary_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		for (unsigned i = 0, n = ptree->elements.n; i < n; i++)
			free_zebu_expression(ptree->elements.data[i]);
		free(ptree->elements.data);
		free_zebu_expression(ptree->inner);
		free_zebu_token(ptree->integer);
		free_zebu_token(ptree->list);
		free_zebu_token(ptree->string);
		free_zebu_token(ptree->variable);
		free(ptree);
	}
}

void free_zebu_recipe(struct zebu_recipe* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_commands(ptree->commands);
		for (unsigned i = 0, n = ptree->dependencies.n; i < n; i++)
			free_zebu_argument(ptree->dependencies.data[i]);
		free(ptree->dependencies.data);
		free_zebu_argument(ptree->target);
		free(ptree);
	}
}

void free_zebu_relational_expression(struct zebu_relational_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->gt);
		free_zebu_token(ptree->gte);
		free_zebu_additive_expression(ptree->inner);
		free_zebu_relational_expression(ptree->left);
		free_zebu_token(ptree->lt);
		free_zebu_token(ptree->lte);
		free_zebu_additive_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_root(struct zebu_root* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		for (unsigned i = 0, n = ptree->statements.n; i < n; i++)
			free_zebu_statement(ptree->statements.data[i]);
		free(ptree->statements.data);
		free(ptree);
	}
}

void free_zebu_simple_command(struct zebu_simple_command* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		for (unsigned i = 0, n = ptree->args.n; i < n; i++)
			free_zebu_argument(ptree->args.data[i]);
		free(ptree->args.data);
		free(ptree);
	}
}

void free_zebu_statement(struct zebu_statement* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_assignment(ptree->assignment);
		free_zebu_conditional(ptree->conditional);
		free_zebu_include(ptree->include);
		free_zebu_iterative(ptree->iterative);
		free_zebu_recipe(ptree->recipe);
		free(ptree);
	}
}



#define argv0 (program_invocation_name)

#define N(array) (sizeof(array) / sizeof(*array))

#ifdef ZEBU_DEBUG
static void escape(char *out, unsigned char in)
{
	switch (in)
	{
		case ' ':
		case '~':
		case '!':
		case '@':
		case '#':
		case '$':
		case '%':
		case '^':
		case '&':
		case '*':
		case '-':
		case '+':
		case '=':
		case '|':
		case '/':
		case '<': case '>':
		case '(': case ')':
		case '{': case '}':
		case '[': case ']':
		case ':': case ';':
		case ',': case '.':
		case '_':
		case '0' ... '9':
		case 'a' ... 'z':
		case 'A' ... 'Z':
			*out++ = in;
			*out = 0;
			break;
		
		case '\\': *out++ = '\\', *out++ = '\\', *out = 0; break;
		
		case '\'': *out++ = '\\', *out++ = '\'', *out = 0; break;
		
		case '\"': *out++ = '\\', *out++ = '\"', *out = 0; break;
		
		case '\t': *out++ = '\\', *out++ = 't', *out = 0; break;
		
		case '\n': *out++ = '\\', *out++ = 'n', *out = 0; break;
		
		default:
			sprintf(out, "\\x%02hhX", in);
			break;
	}
}
#endif

struct zebu_$start* zebu_parse(FILE* stream)
{
	void* root;
	struct { unsigned* data, n, cap; } yacc = {};
	struct { void** data; unsigned n, cap; } data = {};
	struct { unsigned char* data; unsigned n, cap, line; } lexer = {
		.line = 1,
	};
	
	void push_state(unsigned y)
	{
		if (yacc.n + 1 >= yacc.cap)
		{
			yacc.cap = yacc.cap << 1 ?: 1;
			yacc.data = realloc(yacc.data, sizeof(*yacc.data) * yacc.cap);
		}
		yacc.data[yacc.n++] = y;
	}
	
	void push_data(void* d)
	{
		if (data.n + 1 >= data.cap)
		{
			data.cap = data.cap << 1 ?: 1;
			data.data = realloc(data.data, sizeof(*data.data) * data.cap);
		}
		data.data[data.n++] = d;
	}
	
	#ifdef ZEBU_DEBUG
	void ddprintf(const char* fmt, ...)
	{
		for (unsigned i = 0, n = yacc.n; i < n; i++)
			printf("%u ", yacc.data[i]);
		
		printf("| ");
		
		va_list va;
		va_start(va, fmt);
		vprintf(fmt, va);
		va_end(va);
	}
	#endif
	
	void push_char(unsigned char c)
	{
		while (lexer.n + 1 >= lexer.cap)
		{
			lexer.cap = lexer.cap << 1 ?: 1;
			#ifdef ZEBU_DEBUG
			ddprintf("lexer.cap == %u\n", lexer.cap);
			#endif
			lexer.data = realloc(lexer.data, lexer.cap);
		}
		
		lexer.data[lexer.n++] = c;
	}
	
	unsigned y, t, s, r;
	void* td;
	
	void read_token(unsigned l)
	{
		unsigned original_l = l, i = 0, a, b, c, f = 0;
		
		unsigned line = lexer.line;
		
		t = 0;
		
		#ifdef ZEBU_DEBUG
		ddprintf("lexer: \"%.*s\": l = %u\n", lexer.n, lexer.data, l);
		#endif
		
		while (1)
		{
			if (i < lexer.n)
			{
				c = lexer.data[i];
				
				#ifdef ZEBU_DEBUG
				char escaped[10];
				
				escape(escaped, c);
				
				ddprintf("lexer: c = '%s' (0x%X) (from cache)\n", escaped, c);
				#endif
				
				a = l < N(zebu_lexer) && c < N(*zebu_lexer) ? zebu_lexer[l][c] : 0;
			}
			else if ((c = getc(stream)) != EOF)
			{
				push_char(c);
				
				#ifdef ZEBU_DEBUG
				char escaped[10];
				
				escape(escaped, c);
				
				ddprintf("lexer: c = '%s' (0x%X)\n", escaped, c);
				#endif
				
				a = l < N(zebu_lexer) && c < N(*zebu_lexer) ? zebu_lexer[l][c] : 0;
			}
			else
			{
				c = EOF;
				
				#ifdef ZEBU_DEBUG
				ddprintf("lexer: c = <EOF>\n");
				#endif
				
				a = l < N(zebu_lexer_EOFs) ? zebu_lexer_EOFs[l] : 0;
			}
			
			b = l < N(zebu_lexer_accepts) ? zebu_lexer_accepts[l] : 0;
			
			#ifdef ZEBU_DEBUG
			ddprintf("lexer: \"%.*s\" (%u): a = %u, b = %u\n", lexer.n, lexer.data, i, a, b);
			#endif
			
			if (a)
			{
				if (b)
				{
					l = a, t = b, f = i++, lexer.line = line;
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: l = %u\n", l);
					#endif
				}
				else
				{
					l = a, i++;
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: l = %u\n", l);
					#endif
				}
				
				if (c == '\n')
				{
					line++;
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: line: %u\n", line);
					#endif
				}
			}
			else if (b)
			{
				#ifdef ZEBU_DEBUG
				ddprintf("lexer: token: \"%.*s\", line: %u\n", i, lexer.data, line);
				#endif
				
				if (!lexer.n)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: EOF.\n");
					#endif
					t = b, td = NULL;
					break;
				}
				else if (b == 1)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: whitespace: \"%.*s\"\n", i, lexer.data);
					#endif
					
					l = original_l, t = 0, lexer.line = line;
					memmove(lexer.data, lexer.data + i, lexer.n - i), lexer.n -= i, i = 0;
				}
				else
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: i = %u\n", i);
					#endif
					
					struct zebu_token* token = malloc(sizeof(*token));
					token->refcount = 1;
					token->line = line;
					token->data = memcpy(malloc(i + 1), lexer.data, i);
					token->data[i] = 0;
					token->len = i;
					t = b, td = token;
					
					lexer.line = line;
					memmove(lexer.data, lexer.data + i, lexer.n - i), lexer.n -= i;
					break;
				}
			}
			else if (t)
			{
				if (t == 1)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: falling back to whitespace: \"%.*s\"\n", f, lexer.data);
					#endif
					
					l = original_l, t = 0, line = lexer.line;
					memmove(lexer.data, lexer.data + f, lexer.n - f), lexer.n -= f, f = 0, i = 0;
				}
				else
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: falling back to token: \"%.*s\"\n", f, lexer.data);
					#endif
					
					struct zebu_token* token = malloc(sizeof(*token));
					token->refcount = 1;
					token->line = lexer.line;
					token->data = memcpy(malloc(f + 1), lexer.data, f);
					token->data[f] = 0;
					token->len = f;
					td = token;
					
					memmove(lexer.data, lexer.data + f, lexer.n - f), lexer.n -= f, f = 0;
					break;
				}
			}
			else
			{
				if (i != 0)
				{
					if (c == (unsigned) EOF)
						fprintf(stderr, "%s: unexpected '<EOF>' when reading '%.*s' on line %u!\n", argv0, i, lexer.data, line);
					else
						fprintf(stderr, "%s: unexpected '%c' when reading '%.*s' on line %u!\n", argv0, c, i, lexer.data, line);
				}
				else
				{
					if (c == (unsigned) EOF)
						fprintf(stderr, "%s: unexpected '<EOF>' on line %u!\n", argv0, line);
					else
						fprintf(stderr, "%s: unexpected '%c' on line %u!\n", argv0, c, line);
				}
				exit(1);
			}
		}
	}
	
	push_state(1), y = 1, read_token(1);
	
	#ifdef ZEBU_DEBUG
	ddprintf("y = %u, t = %u\n", y, t);
	#endif
	
	while (yacc.n)
	{
		if (y < N(zebu_shifts) && t < N(*zebu_shifts) && (s = zebu_shifts[y][t]))
		{
			#ifdef ZEBU_DEBUG
			ddprintf("s == %u\n", s);
			#endif
			
			y = s, push_state(y), push_data(td);
			
			read_token(zebu_lexer_starts[y]);
			
			#ifdef ZEBU_DEBUG
			ddprintf("t = %u\n", t);
			#endif
		}
		else if (y < N( zebu_reduces) && t < N(*zebu_reduces) && (r = zebu_reduces[y][t]))
		{
			#ifdef ZEBU_DEBUG
			ddprintf("r == %u\n", r);
			#endif
			
			unsigned g;
			void* d;
			
			switch (r)
{
case 8:
{
struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_root* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_root(value->root), value->root = inc_zebu_root(subgrammar);
free_zebu_root(subgrammar);
}
d = value, g = 43;
break;
}
case 40:
{
struct zebu_additive_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_multiplicative_expression(value->right), value->right = inc_zebu_multiplicative_expression(subgrammar);
free_zebu_multiplicative_expression(subgrammar);
}
d = value, g = 24;
break;
}
case 53:
{
struct zebu_assignment* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(value->expression), value->expression = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
d = value, g = 19;
break;
}
case 65:
{
struct zebu_assignment* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_assignment* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->eq) { free_zebu_token(value->eq); value->eq = inc_zebu_token(trie->eq); }
if (trie->expression) { free_zebu_expression(value->expression); value->expression = inc_zebu_expression(trie->expression); }
if (trie->peq) { free_zebu_token(value->peq); value->peq = inc_zebu_token(trie->peq); }
if (trie->variable) { free_zebu_token(value->variable); value->variable = inc_zebu_token(trie->variable); }
free_zebu_assignment(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(value->expression), value->expression = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
d = value, g = 19;
break;
}
case 84:
{
struct zebu_conditional* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 39;
break;
}
case 92:
{
struct zebu_conditional* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_conditional* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
free_zebu_conditional(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 39;
break;
}
case 43:
{
struct zebu_equality_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_relational_expression(value->right), value->right = inc_zebu_relational_expression(subgrammar);
free_zebu_relational_expression(subgrammar);
}
d = value, g = 25;
break;
}
case 54:
{
struct zebu_include* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 28;
break;
}
case 67:
{
struct zebu_include* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_include* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->argument) { free_zebu_argument(value->argument); value->argument = inc_zebu_argument(trie->argument); }
free_zebu_include(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 28;
break;
}
case 96:
{
struct zebu_iterative* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 41;
break;
}
case 99:
{
struct zebu_iterative* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_iterative* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->body.n)
{
while (value->body.n + trie->body.n > value->body.cap)
{
value->body.cap = value->body.cap << 1 ?: 1;
value->body.data = realloc(value->body.data, sizeof(*value->body.data) * value->body.cap);
}
memmove(value->body.data + trie->body.n, value->body.data, sizeof(*value->body.data) * value->body.n);
for (unsigned i = 0, n = trie->body.n; i < n; i++)
value->body.data[i] = inc_zebu_statement(trie->body.data[i]);
value->body.n += trie->body.n;
}
if (trie->list) { free_zebu_expression(value->list); value->list = inc_zebu_expression(trie->list); }
if (trie->variable) { free_zebu_token(value->variable); value->variable = inc_zebu_token(trie->variable); }
free_zebu_iterative(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 41;
break;
}
case 97:
{
struct zebu_iterative* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_iterative* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->body.n)
{
while (value->body.n + trie->body.n > value->body.cap)
{
value->body.cap = value->body.cap << 1 ?: 1;
value->body.data = realloc(value->body.data, sizeof(*value->body.data) * value->body.cap);
}
memmove(value->body.data + trie->body.n, value->body.data, sizeof(*value->body.data) * value->body.n);
for (unsigned i = 0, n = trie->body.n; i < n; i++)
value->body.data[i] = inc_zebu_statement(trie->body.data[i]);
value->body.n += trie->body.n;
}
if (trie->list) { free_zebu_expression(value->list); value->list = inc_zebu_expression(trie->list); }
if (trie->variable) { free_zebu_token(value->variable); value->variable = inc_zebu_token(trie->variable); }
free_zebu_iterative(trie);
}
{
struct zebu_statement* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->body.n == value->body.cap)
{
value->body.cap = value->body.cap << 1 ?: 1;
value->body.data = realloc(value->body.data, sizeof(*value->body.data) * value->body.cap);
}
memmove(value->body.data + 1, value->body.data, sizeof(*value->body.data) * value->body.n);
value->body.data[0] = inc_zebu_statement(subgrammar), value->body.n++;
free_zebu_statement(subgrammar);
}
d = value, g = 41;
break;
}
case 98:
{
struct zebu_iterative* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 42;
break;
}
case 100:
{
struct zebu_iterative* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_iterative* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->body.n)
{
while (value->body.n + trie->body.n > value->body.cap)
{
value->body.cap = value->body.cap << 1 ?: 1;
value->body.data = realloc(value->body.data, sizeof(*value->body.data) * value->body.cap);
}
memmove(value->body.data + trie->body.n, value->body.data, sizeof(*value->body.data) * value->body.n);
for (unsigned i = 0, n = trie->body.n; i < n; i++)
value->body.data[i] = inc_zebu_statement(trie->body.data[i]);
value->body.n += trie->body.n;
}
if (trie->list) { free_zebu_expression(value->list); value->list = inc_zebu_expression(trie->list); }
if (trie->variable) { free_zebu_token(value->variable); value->variable = inc_zebu_token(trie->variable); }
free_zebu_iterative(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 42;
break;
}
case 46:
{
struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_prefix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_prefix_expression(value->right), value->right = inc_zebu_prefix_expression(subgrammar);
free_zebu_prefix_expression(subgrammar);
}
d = value, g = 26;
break;
}
case 25:
{
struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_prefix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_prefix_expression(value->sub), value->sub = inc_zebu_prefix_expression(subgrammar);
free_zebu_prefix_expression(subgrammar);
}
d = value, g = 18;
break;
}
case 75:
{
struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_primary_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->elements.n)
{
while (value->elements.n + trie->elements.n > value->elements.cap)
{
value->elements.cap = value->elements.cap << 1 ?: 1;
value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
}
memmove(value->elements.data + trie->elements.n, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
for (unsigned i = 0, n = trie->elements.n; i < n; i++)
value->elements.data[i] = inc_zebu_expression(trie->elements.data[i]);
value->elements.n += trie->elements.n;
}
if (trie->inner) { free_zebu_expression(value->inner); value->inner = inc_zebu_expression(trie->inner); }
if (trie->integer) { free_zebu_token(value->integer); value->integer = inc_zebu_token(trie->integer); }
if (trie->list) { free_zebu_token(value->list); value->list = inc_zebu_token(trie->list); }
if (trie->string) { free_zebu_token(value->string); value->string = inc_zebu_token(trie->string); }
if (trie->variable) { free_zebu_token(value->variable); value->variable = inc_zebu_token(trie->variable); }
free_zebu_primary_expression(trie);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->elements.n == value->elements.cap)
{
value->elements.cap = value->elements.cap << 1 ?: 1;
value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
}
memmove(value->elements.data + 1, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
value->elements.data[0] = inc_zebu_expression(subgrammar), value->elements.n++;
free_zebu_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 23;
break;
}
case 37:
{
struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 23;
break;
}
case 31:
{
struct zebu_recipe* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 20;
break;
}
case 57:
{
struct zebu_recipe* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 20;
break;
}
case 71:
{
struct zebu_recipe* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_recipe* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->commands) { free_zebu_commands(value->commands); value->commands = inc_zebu_commands(trie->commands); }
if (trie->dependencies.n)
{
while (value->dependencies.n + trie->dependencies.n > value->dependencies.cap)
{
value->dependencies.cap = value->dependencies.cap << 1 ?: 1;
value->dependencies.data = realloc(value->dependencies.data, sizeof(*value->dependencies.data) * value->dependencies.cap);
}
memmove(value->dependencies.data + trie->dependencies.n, value->dependencies.data, sizeof(*value->dependencies.data) * value->dependencies.n);
for (unsigned i = 0, n = trie->dependencies.n; i < n; i++)
value->dependencies.data[i] = inc_zebu_argument(trie->dependencies.data[i]);
value->dependencies.n += trie->dependencies.n;
}
if (trie->target) { free_zebu_argument(value->target); value->target = inc_zebu_argument(trie->target); }
free_zebu_recipe(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 20;
break;
}
case 58:
{
struct zebu_recipe* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_commands* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_commands(value->commands), value->commands = inc_zebu_commands(subgrammar);
free_zebu_commands(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 20;
break;
}
case 72:
{
struct zebu_recipe* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_recipe* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->commands) { free_zebu_commands(value->commands); value->commands = inc_zebu_commands(trie->commands); }
if (trie->dependencies.n)
{
while (value->dependencies.n + trie->dependencies.n > value->dependencies.cap)
{
value->dependencies.cap = value->dependencies.cap << 1 ?: 1;
value->dependencies.data = realloc(value->dependencies.data, sizeof(*value->dependencies.data) * value->dependencies.cap);
}
memmove(value->dependencies.data + trie->dependencies.n, value->dependencies.data, sizeof(*value->dependencies.data) * value->dependencies.n);
for (unsigned i = 0, n = trie->dependencies.n; i < n; i++)
value->dependencies.data[i] = inc_zebu_argument(trie->dependencies.data[i]);
value->dependencies.n += trie->dependencies.n;
}
if (trie->target) { free_zebu_argument(value->target); value->target = inc_zebu_argument(trie->target); }
free_zebu_recipe(trie);
}
{
struct zebu_commands* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_commands(value->commands), value->commands = inc_zebu_commands(subgrammar);
free_zebu_commands(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 20;
break;
}
case 59:
{
struct zebu_recipe* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_recipe* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->commands) { free_zebu_commands(value->commands); value->commands = inc_zebu_commands(trie->commands); }
if (trie->dependencies.n)
{
while (value->dependencies.n + trie->dependencies.n > value->dependencies.cap)
{
value->dependencies.cap = value->dependencies.cap << 1 ?: 1;
value->dependencies.data = realloc(value->dependencies.data, sizeof(*value->dependencies.data) * value->dependencies.cap);
}
memmove(value->dependencies.data + trie->dependencies.n, value->dependencies.data, sizeof(*value->dependencies.data) * value->dependencies.n);
for (unsigned i = 0, n = trie->dependencies.n; i < n; i++)
value->dependencies.data[i] = inc_zebu_argument(trie->dependencies.data[i]);
value->dependencies.n += trie->dependencies.n;
}
if (trie->target) { free_zebu_argument(value->target); value->target = inc_zebu_argument(trie->target); }
free_zebu_recipe(trie);
}
{
struct zebu_argument* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->dependencies.n == value->dependencies.cap)
{
value->dependencies.cap = value->dependencies.cap << 1 ?: 1;
value->dependencies.data = realloc(value->dependencies.data, sizeof(*value->dependencies.data) * value->dependencies.cap);
}
memmove(value->dependencies.data + 1, value->dependencies.data, sizeof(*value->dependencies.data) * value->dependencies.n);
value->dependencies.data[0] = inc_zebu_argument(subgrammar), value->dependencies.n++;
free_zebu_argument(subgrammar);
}
d = value, g = 20;
break;
}
case 34:
{
struct zebu_recipe* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_commands* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_commands(value->commands), value->commands = inc_zebu_commands(subgrammar);
free_zebu_commands(subgrammar);
}
d = value, g = 20;
break;
}
case 63:
{
struct zebu_recipe* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_recipe* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->commands) { free_zebu_commands(value->commands); value->commands = inc_zebu_commands(trie->commands); }
if (trie->dependencies.n)
{
while (value->dependencies.n + trie->dependencies.n > value->dependencies.cap)
{
value->dependencies.cap = value->dependencies.cap << 1 ?: 1;
value->dependencies.data = realloc(value->dependencies.data, sizeof(*value->dependencies.data) * value->dependencies.cap);
}
memmove(value->dependencies.data + trie->dependencies.n, value->dependencies.data, sizeof(*value->dependencies.data) * value->dependencies.n);
for (unsigned i = 0, n = trie->dependencies.n; i < n; i++)
value->dependencies.data[i] = inc_zebu_argument(trie->dependencies.data[i]);
value->dependencies.n += trie->dependencies.n;
}
if (trie->target) { free_zebu_argument(value->target); value->target = inc_zebu_argument(trie->target); }
free_zebu_recipe(trie);
}
{
struct zebu_commands* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_commands(value->commands), value->commands = inc_zebu_commands(subgrammar);
free_zebu_commands(subgrammar);
}
d = value, g = 20;
break;
}
case 62:
{
struct zebu_recipe* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 31;
break;
}
case 74:
{
struct zebu_recipe* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_recipe* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->commands) { free_zebu_commands(value->commands); value->commands = inc_zebu_commands(trie->commands); }
if (trie->dependencies.n)
{
while (value->dependencies.n + trie->dependencies.n > value->dependencies.cap)
{
value->dependencies.cap = value->dependencies.cap << 1 ?: 1;
value->dependencies.data = realloc(value->dependencies.data, sizeof(*value->dependencies.data) * value->dependencies.cap);
}
memmove(value->dependencies.data + trie->dependencies.n, value->dependencies.data, sizeof(*value->dependencies.data) * value->dependencies.n);
for (unsigned i = 0, n = trie->dependencies.n; i < n; i++)
value->dependencies.data[i] = inc_zebu_argument(trie->dependencies.data[i]);
value->dependencies.n += trie->dependencies.n;
}
if (trie->target) { free_zebu_argument(value->target); value->target = inc_zebu_argument(trie->target); }
free_zebu_recipe(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 31;
break;
}
case 64:
{
struct zebu_assignment* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 32;
break;
}
case 76:
{
struct zebu_assignment* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_assignment* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->eq) { free_zebu_token(value->eq); value->eq = inc_zebu_token(trie->eq); }
if (trie->expression) { free_zebu_expression(value->expression); value->expression = inc_zebu_expression(trie->expression); }
if (trie->peq) { free_zebu_token(value->peq); value->peq = inc_zebu_token(trie->peq); }
if (trie->variable) { free_zebu_token(value->variable); value->variable = inc_zebu_token(trie->variable); }
free_zebu_assignment(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 32;
break;
}
case 49:
{
struct zebu_relational_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_additive_expression(value->right), value->right = inc_zebu_additive_expression(subgrammar);
free_zebu_additive_expression(subgrammar);
}
d = value, g = 27;
break;
}
case 22:
{
struct zebu_root* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_statement* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->statements.n == value->statements.cap)
{
value->statements.cap = value->statements.cap << 1 ?: 1;
value->statements.data = realloc(value->statements.data, sizeof(*value->statements.data) * value->statements.cap);
}
memmove(value->statements.data + 1, value->statements.data, sizeof(*value->statements.data) * value->statements.n);
value->statements.data[0] = inc_zebu_statement(subgrammar), value->statements.n++;
free_zebu_statement(subgrammar);
}
d = value, g = 17;
break;
}
case 35:
{
struct zebu_root* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_root* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->statements.n)
{
while (value->statements.n + trie->statements.n > value->statements.cap)
{
value->statements.cap = value->statements.cap << 1 ?: 1;
value->statements.data = realloc(value->statements.data, sizeof(*value->statements.data) * value->statements.cap);
}
memmove(value->statements.data + trie->statements.n, value->statements.data, sizeof(*value->statements.data) * value->statements.n);
for (unsigned i = 0, n = trie->statements.n; i < n; i++)
value->statements.data[i] = inc_zebu_statement(trie->statements.data[i]);
value->statements.n += trie->statements.n;
}
free_zebu_root(trie);
}
{
struct zebu_statement* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->statements.n == value->statements.cap)
{
value->statements.cap = value->statements.cap << 1 ?: 1;
value->statements.data = realloc(value->statements.data, sizeof(*value->statements.data) * value->statements.cap);
}
memmove(value->statements.data + 1, value->statements.data, sizeof(*value->statements.data) * value->statements.n);
value->statements.data[0] = inc_zebu_statement(subgrammar), value->statements.n++;
free_zebu_statement(subgrammar);
}
d = value, g = 17;
break;
}
case 69:
{
struct zebu_simple_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_argument* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->args.n == value->args.cap)
{
value->args.cap = value->args.cap << 1 ?: 1;
value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
}
memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
value->args.data[0] = inc_zebu_argument(subgrammar), value->args.n++;
free_zebu_argument(subgrammar);
}
d = value, g = 34;
break;
}
case 80:
{
struct zebu_simple_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_simple_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->args.n)
{
while (value->args.n + trie->args.n > value->args.cap)
{
value->args.cap = value->args.cap << 1 ?: 1;
value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
}
memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
for (unsigned i = 0, n = trie->args.n; i < n; i++)
value->args.data[i] = inc_zebu_argument(trie->args.data[i]);
value->args.n += trie->args.n;
}
free_zebu_simple_command(trie);
}
{
struct zebu_argument* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->args.n == value->args.cap)
{
value->args.cap = value->args.cap << 1 ?: 1;
value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
}
memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
value->args.data[0] = inc_zebu_argument(subgrammar), value->args.n++;
free_zebu_argument(subgrammar);
}
d = value, g = 34;
break;
}
case 94:
{
struct zebu_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->redirect_in) { free_zebu_argument(value->redirect_in); value->redirect_in = inc_zebu_argument(trie->redirect_in); }
if (trie->redirect_out) { free_zebu_argument(value->redirect_out); value->redirect_out = inc_zebu_argument(trie->redirect_out); }
if (trie->simples.n)
{
while (value->simples.n + trie->simples.n > value->simples.cap)
{
value->simples.cap = value->simples.cap << 1 ?: 1;
value->simples.data = realloc(value->simples.data, sizeof(*value->simples.data) * value->simples.cap);
}
memmove(value->simples.data + trie->simples.n, value->simples.data, sizeof(*value->simples.data) * value->simples.n);
for (unsigned i = 0, n = trie->simples.n; i < n; i++)
value->simples.data[i] = inc_zebu_simple_command(trie->simples.data[i]);
value->simples.n += trie->simples.n;
}
free_zebu_command(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 40;
break;
}
case 95:
{
struct zebu_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->redirect_in) { free_zebu_argument(value->redirect_in); value->redirect_in = inc_zebu_argument(trie->redirect_in); }
if (trie->redirect_out) { free_zebu_argument(value->redirect_out); value->redirect_out = inc_zebu_argument(trie->redirect_out); }
if (trie->simples.n)
{
while (value->simples.n + trie->simples.n > value->simples.cap)
{
value->simples.cap = value->simples.cap << 1 ?: 1;
value->simples.data = realloc(value->simples.data, sizeof(*value->simples.data) * value->simples.cap);
}
memmove(value->simples.data + trie->simples.n, value->simples.data, sizeof(*value->simples.data) * value->simples.n);
for (unsigned i = 0, n = trie->simples.n; i < n; i++)
value->simples.data[i] = inc_zebu_simple_command(trie->simples.data[i]);
value->simples.n += trie->simples.n;
}
free_zebu_command(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 40;
break;
}
case 86:
{
struct zebu_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 40;
break;
}
case 88:
{
struct zebu_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->redirect_in) { free_zebu_argument(value->redirect_in); value->redirect_in = inc_zebu_argument(trie->redirect_in); }
if (trie->redirect_out) { free_zebu_argument(value->redirect_out); value->redirect_out = inc_zebu_argument(trie->redirect_out); }
if (trie->simples.n)
{
while (value->simples.n + trie->simples.n > value->simples.cap)
{
value->simples.cap = value->simples.cap << 1 ?: 1;
value->simples.data = realloc(value->simples.data, sizeof(*value->simples.data) * value->simples.cap);
}
memmove(value->simples.data + trie->simples.n, value->simples.data, sizeof(*value->simples.data) * value->simples.n);
for (unsigned i = 0, n = trie->simples.n; i < n; i++)
value->simples.data[i] = inc_zebu_simple_command(trie->simples.data[i]);
value->simples.n += trie->simples.n;
}
free_zebu_command(trie);
}
{
struct zebu_simple_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->simples.n == value->simples.cap)
{
value->simples.cap = value->simples.cap << 1 ?: 1;
value->simples.data = realloc(value->simples.data, sizeof(*value->simples.data) * value->simples.cap);
}
memmove(value->simples.data + 1, value->simples.data, sizeof(*value->simples.data) * value->simples.n);
value->simples.data[0] = inc_zebu_simple_command(subgrammar), value->simples.n++;
free_zebu_simple_command(subgrammar);
}
d = value, g = 36;
break;
}
case 89:
{
struct zebu_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_argument* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_argument(value->redirect_out), value->redirect_out = inc_zebu_argument(subgrammar);
free_zebu_argument(subgrammar);
}
d = value, g = 37;
break;
}
case 61:
{
struct zebu_commands* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->commands.n == value->commands.cap)
{
value->commands.cap = value->commands.cap << 1 ?: 1;
value->commands.data = realloc(value->commands.data, sizeof(*value->commands.data) * value->commands.cap);
}
memmove(value->commands.data + 1, value->commands.data, sizeof(*value->commands.data) * value->commands.n);
value->commands.data[0] = inc_zebu_command(subgrammar), value->commands.n++;
free_zebu_command(subgrammar);
}
d = value, g = 30;
break;
}
case 73:
{
struct zebu_commands* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_commands* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->commands.n)
{
while (value->commands.n + trie->commands.n > value->commands.cap)
{
value->commands.cap = value->commands.cap << 1 ?: 1;
value->commands.data = realloc(value->commands.data, sizeof(*value->commands.data) * value->commands.cap);
}
memmove(value->commands.data + trie->commands.n, value->commands.data, sizeof(*value->commands.data) * value->commands.n);
for (unsigned i = 0, n = trie->commands.n; i < n; i++)
value->commands.data[i] = inc_zebu_command(trie->commands.data[i]);
value->commands.n += trie->commands.n;
}
free_zebu_commands(trie);
}
{
struct zebu_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->commands.n == value->commands.cap)
{
value->commands.cap = value->commands.cap << 1 ?: 1;
value->commands.data = realloc(value->commands.data, sizeof(*value->commands.data) * value->commands.cap);
}
memmove(value->commands.data + 1, value->commands.data, sizeof(*value->commands.data) * value->commands.n);
value->commands.data[0] = inc_zebu_command(subgrammar), value->commands.n++;
free_zebu_command(subgrammar);
}
d = value, g = 30;
break;
}
case 83:
{
struct zebu_conditional* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_conditional* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
free_zebu_conditional(trie);
}
{
struct zebu_statement* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_statement(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 33;
break;
}
case 78:
{
struct zebu_conditional* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_conditional* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
free_zebu_conditional(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 33;
break;
}
case 79:
{
struct zebu_conditional* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_conditional* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
free_zebu_conditional(trie);
}
{
struct zebu_statement* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_statement(subgrammar);
}
d = value, g = 33;
break;
}
case 77:
{
struct zebu_conditional* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 35;
break;
}
case 85:
{
struct zebu_conditional* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_conditional* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
free_zebu_conditional(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 35;
break;
}
case 90:
{
struct zebu_conditional* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_conditional* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
free_zebu_conditional(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 38;
break;
}
case 91:
{
struct zebu_conditional* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_conditional* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
free_zebu_conditional(trie);
}
{
struct zebu_statement* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_statement(subgrammar);
}
d = value, g = 38;
break;
}
case 41:
{
struct zebu_additive_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_additive_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->add) { free_zebu_token(value->add); value->add = inc_zebu_token(trie->add); }
if (trie->inner) { free_zebu_multiplicative_expression(value->inner); value->inner = inc_zebu_multiplicative_expression(trie->inner); }
if (trie->left) { free_zebu_additive_expression(value->left); value->left = inc_zebu_additive_expression(trie->left); }
if (trie->right) { free_zebu_multiplicative_expression(value->right); value->right = inc_zebu_multiplicative_expression(trie->right); }
if (trie->sub) { free_zebu_token(value->sub); value->sub = inc_zebu_token(trie->sub); }
free_zebu_additive_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->sub), value->sub = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_additive_expression(value->left), value->left = inc_zebu_additive_expression(subgrammar);
free_zebu_additive_expression(subgrammar);
}
d = value, g = 9;
break;
}
case 15:
{
struct zebu_additive_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_multiplicative_expression(value->inner), value->inner = inc_zebu_multiplicative_expression(subgrammar);
free_zebu_multiplicative_expression(subgrammar);
}
d = value, g = 9;
break;
}
case 39:
{
struct zebu_additive_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_additive_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->add) { free_zebu_token(value->add); value->add = inc_zebu_token(trie->add); }
if (trie->inner) { free_zebu_multiplicative_expression(value->inner); value->inner = inc_zebu_multiplicative_expression(trie->inner); }
if (trie->left) { free_zebu_additive_expression(value->left); value->left = inc_zebu_additive_expression(trie->left); }
if (trie->right) { free_zebu_multiplicative_expression(value->right); value->right = inc_zebu_multiplicative_expression(trie->right); }
if (trie->sub) { free_zebu_token(value->sub); value->sub = inc_zebu_token(trie->sub); }
free_zebu_additive_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->add), value->add = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_additive_expression(value->left), value->left = inc_zebu_additive_expression(subgrammar);
free_zebu_additive_expression(subgrammar);
}
d = value, g = 9;
break;
}
case 27:
{
struct zebu_argument* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(value->expression), value->expression = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 1;
break;
}
case 1:
{
struct zebu_argument* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->string), value->string = inc_zebu_token(token);
free_zebu_token(token);
}
d = value, g = 1;
break;
}
case 2:
{
struct zebu_argument* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->text), value->text = inc_zebu_token(token);
free_zebu_token(token);
}
d = value, g = 1;
break;
}
case 28:
{
struct zebu_assignment* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_assignment* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->eq) { free_zebu_token(value->eq); value->eq = inc_zebu_token(trie->eq); }
if (trie->expression) { free_zebu_expression(value->expression); value->expression = inc_zebu_expression(trie->expression); }
if (trie->peq) { free_zebu_token(value->peq); value->peq = inc_zebu_token(trie->peq); }
if (trie->variable) { free_zebu_token(value->variable); value->variable = inc_zebu_token(trie->variable); }
free_zebu_assignment(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->eq), value->eq = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->variable), value->variable = inc_zebu_token(token);
free_zebu_token(token);
}
d = value, g = 2;
break;
}
case 29:
{
struct zebu_assignment* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_assignment* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->eq) { free_zebu_token(value->eq); value->eq = inc_zebu_token(trie->eq); }
if (trie->expression) { free_zebu_expression(value->expression); value->expression = inc_zebu_expression(trie->expression); }
if (trie->peq) { free_zebu_token(value->peq); value->peq = inc_zebu_token(trie->peq); }
if (trie->variable) { free_zebu_token(value->variable); value->variable = inc_zebu_token(trie->variable); }
free_zebu_assignment(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->peq), value->peq = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->variable), value->variable = inc_zebu_token(token);
free_zebu_token(token);
}
d = value, g = 2;
break;
}
case 87:
{
struct zebu_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->redirect_in) { free_zebu_argument(value->redirect_in); value->redirect_in = inc_zebu_argument(trie->redirect_in); }
if (trie->redirect_out) { free_zebu_argument(value->redirect_out); value->redirect_out = inc_zebu_argument(trie->redirect_out); }
if (trie->simples.n)
{
while (value->simples.n + trie->simples.n > value->simples.cap)
{
value->simples.cap = value->simples.cap << 1 ?: 1;
value->simples.data = realloc(value->simples.data, sizeof(*value->simples.data) * value->simples.cap);
}
memmove(value->simples.data + trie->simples.n, value->simples.data, sizeof(*value->simples.data) * value->simples.n);
for (unsigned i = 0, n = trie->simples.n; i < n; i++)
value->simples.data[i] = inc_zebu_simple_command(trie->simples.data[i]);
value->simples.n += trie->simples.n;
}
free_zebu_command(trie);
}
{
struct zebu_argument* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_argument(value->redirect_in), value->redirect_in = inc_zebu_argument(subgrammar);
free_zebu_argument(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_simple_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->simples.n == value->simples.cap)
{
value->simples.cap = value->simples.cap << 1 ?: 1;
value->simples.data = realloc(value->simples.data, sizeof(*value->simples.data) * value->simples.cap);
}
memmove(value->simples.data + 1, value->simples.data, sizeof(*value->simples.data) * value->simples.n);
value->simples.data[0] = inc_zebu_simple_command(subgrammar), value->simples.n++;
free_zebu_simple_command(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 21;
break;
}
case 81:
{
struct zebu_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->redirect_in) { free_zebu_argument(value->redirect_in); value->redirect_in = inc_zebu_argument(trie->redirect_in); }
if (trie->redirect_out) { free_zebu_argument(value->redirect_out); value->redirect_out = inc_zebu_argument(trie->redirect_out); }
if (trie->simples.n)
{
while (value->simples.n + trie->simples.n > value->simples.cap)
{
value->simples.cap = value->simples.cap << 1 ?: 1;
value->simples.data = realloc(value->simples.data, sizeof(*value->simples.data) * value->simples.cap);
}
memmove(value->simples.data + trie->simples.n, value->simples.data, sizeof(*value->simples.data) * value->simples.n);
for (unsigned i = 0, n = trie->simples.n; i < n; i++)
value->simples.data[i] = inc_zebu_simple_command(trie->simples.data[i]);
value->simples.n += trie->simples.n;
}
free_zebu_command(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_simple_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->simples.n == value->simples.cap)
{
value->simples.cap = value->simples.cap << 1 ?: 1;
value->simples.data = realloc(value->simples.data, sizeof(*value->simples.data) * value->simples.cap);
}
memmove(value->simples.data + 1, value->simples.data, sizeof(*value->simples.data) * value->simples.n);
value->simples.data[0] = inc_zebu_simple_command(subgrammar), value->simples.n++;
free_zebu_simple_command(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 21;
break;
}
case 82:
{
struct zebu_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->redirect_in) { free_zebu_argument(value->redirect_in); value->redirect_in = inc_zebu_argument(trie->redirect_in); }
if (trie->redirect_out) { free_zebu_argument(value->redirect_out); value->redirect_out = inc_zebu_argument(trie->redirect_out); }
if (trie->simples.n)
{
while (value->simples.n + trie->simples.n > value->simples.cap)
{
value->simples.cap = value->simples.cap << 1 ?: 1;
value->simples.data = realloc(value->simples.data, sizeof(*value->simples.data) * value->simples.cap);
}
memmove(value->simples.data + trie->simples.n, value->simples.data, sizeof(*value->simples.data) * value->simples.n);
for (unsigned i = 0, n = trie->simples.n; i < n; i++)
value->simples.data[i] = inc_zebu_simple_command(trie->simples.data[i]);
value->simples.n += trie->simples.n;
}
free_zebu_command(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_simple_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->simples.n == value->simples.cap)
{
value->simples.cap = value->simples.cap << 1 ?: 1;
value->simples.data = realloc(value->simples.data, sizeof(*value->simples.data) * value->simples.cap);
}
memmove(value->simples.data + 1, value->simples.data, sizeof(*value->simples.data) * value->simples.n);
value->simples.data[0] = inc_zebu_simple_command(subgrammar), value->simples.n++;
free_zebu_simple_command(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 21;
break;
}
case 70:
{
struct zebu_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_simple_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->simples.n == value->simples.cap)
{
value->simples.cap = value->simples.cap << 1 ?: 1;
value->simples.data = realloc(value->simples.data, sizeof(*value->simples.data) * value->simples.cap);
}
memmove(value->simples.data + 1, value->simples.data, sizeof(*value->simples.data) * value->simples.n);
value->simples.data[0] = inc_zebu_simple_command(subgrammar), value->simples.n++;
free_zebu_simple_command(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 21;
break;
}
case 60:
{
struct zebu_commands* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_commands* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->commands.n)
{
while (value->commands.n + trie->commands.n > value->commands.cap)
{
value->commands.cap = value->commands.cap << 1 ?: 1;
value->commands.data = realloc(value->commands.data, sizeof(*value->commands.data) * value->commands.cap);
}
memmove(value->commands.data + trie->commands.n, value->commands.data, sizeof(*value->commands.data) * value->commands.n);
for (unsigned i = 0, n = trie->commands.n; i < n; i++)
value->commands.data[i] = inc_zebu_command(trie->commands.data[i]);
value->commands.n += trie->commands.n;
}
free_zebu_commands(trie);
}
{
struct zebu_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->commands.n == value->commands.cap)
{
value->commands.cap = value->commands.cap << 1 ?: 1;
value->commands.data = realloc(value->commands.data, sizeof(*value->commands.data) * value->commands.cap);
}
memmove(value->commands.data + 1, value->commands.data, sizeof(*value->commands.data) * value->commands.n);
value->commands.data[0] = inc_zebu_command(subgrammar), value->commands.n++;
free_zebu_command(subgrammar);
}
d = value, g = 22;
break;
}
case 33:
{
struct zebu_commands* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_command* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->commands.n == value->commands.cap)
{
value->commands.cap = value->commands.cap << 1 ?: 1;
value->commands.data = realloc(value->commands.data, sizeof(*value->commands.data) * value->commands.cap);
}
memmove(value->commands.data + 1, value->commands.data, sizeof(*value->commands.data) * value->commands.n);
value->commands.data[0] = inc_zebu_command(subgrammar), value->commands.n++;
free_zebu_command(subgrammar);
}
d = value, g = 22;
break;
}
case 66:
{
struct zebu_conditional* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_conditional* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
free_zebu_conditional(trie);
}
{
struct zebu_statement* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_statement(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 3;
break;
}
case 42:
{
struct zebu_equality_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_equality_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->eq) { free_zebu_token(value->eq); value->eq = inc_zebu_token(trie->eq); }
if (trie->inner) { free_zebu_relational_expression(value->inner); value->inner = inc_zebu_relational_expression(trie->inner); }
if (trie->left) { free_zebu_equality_expression(value->left); value->left = inc_zebu_equality_expression(trie->left); }
if (trie->nq) { free_zebu_token(value->nq); value->nq = inc_zebu_token(trie->nq); }
if (trie->right) { free_zebu_relational_expression(value->right); value->right = inc_zebu_relational_expression(trie->right); }
free_zebu_equality_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->eq), value->eq = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_equality_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_equality_expression(value->left), value->left = inc_zebu_equality_expression(subgrammar);
free_zebu_equality_expression(subgrammar);
}
d = value, g = 10;
break;
}
case 44:
{
struct zebu_equality_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_equality_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->eq) { free_zebu_token(value->eq); value->eq = inc_zebu_token(trie->eq); }
if (trie->inner) { free_zebu_relational_expression(value->inner); value->inner = inc_zebu_relational_expression(trie->inner); }
if (trie->left) { free_zebu_equality_expression(value->left); value->left = inc_zebu_equality_expression(trie->left); }
if (trie->nq) { free_zebu_token(value->nq); value->nq = inc_zebu_token(trie->nq); }
if (trie->right) { free_zebu_relational_expression(value->right); value->right = inc_zebu_relational_expression(trie->right); }
free_zebu_equality_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->nq), value->nq = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_equality_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_equality_expression(value->left), value->left = inc_zebu_equality_expression(subgrammar);
free_zebu_equality_expression(subgrammar);
}
d = value, g = 10;
break;
}
case 19:
{
struct zebu_equality_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_relational_expression(value->inner), value->inner = inc_zebu_relational_expression(subgrammar);
free_zebu_relational_expression(subgrammar);
}
d = value, g = 10;
break;
}
case 14:
{
struct zebu_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_equality_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_equality_expression(value->inner), value->inner = inc_zebu_equality_expression(subgrammar);
free_zebu_equality_expression(subgrammar);
}
d = value, g = 11;
break;
}
case 30:
{
struct zebu_include* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_argument* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_argument(value->argument), value->argument = inc_zebu_argument(subgrammar);
free_zebu_argument(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 4;
break;
}
case 55:
{
struct zebu_include* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_include* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->argument) { free_zebu_argument(value->argument); value->argument = inc_zebu_argument(trie->argument); }
free_zebu_include(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_argument* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_argument(value->argument), value->argument = inc_zebu_argument(subgrammar);
free_zebu_argument(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 4;
break;
}
case 93:
{
struct zebu_iterative* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_iterative* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->body.n)
{
while (value->body.n + trie->body.n > value->body.cap)
{
value->body.cap = value->body.cap << 1 ?: 1;
value->body.data = realloc(value->body.data, sizeof(*value->body.data) * value->body.cap);
}
memmove(value->body.data + trie->body.n, value->body.data, sizeof(*value->body.data) * value->body.n);
for (unsigned i = 0, n = trie->body.n; i < n; i++)
value->body.data[i] = inc_zebu_statement(trie->body.data[i]);
value->body.n += trie->body.n;
}
if (trie->list) { free_zebu_expression(value->list); value->list = inc_zebu_expression(trie->list); }
if (trie->variable) { free_zebu_token(value->variable); value->variable = inc_zebu_token(trie->variable); }
free_zebu_iterative(trie);
}
{
struct zebu_statement* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->body.n == value->body.cap)
{
value->body.cap = value->body.cap << 1 ?: 1;
value->body.data = realloc(value->body.data, sizeof(*value->body.data) * value->body.cap);
}
memmove(value->body.data + 1, value->body.data, sizeof(*value->body.data) * value->body.n);
value->body.data[0] = inc_zebu_statement(subgrammar), value->body.n++;
free_zebu_statement(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(value->list), value->list = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->variable), value->variable = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 5;
break;
}
case 45:
{
struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_multiplicative_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->div) { free_zebu_token(value->div); value->div = inc_zebu_token(trie->div); }
if (trie->inner) { free_zebu_prefix_expression(value->inner); value->inner = inc_zebu_prefix_expression(trie->inner); }
if (trie->left) { free_zebu_multiplicative_expression(value->left); value->left = inc_zebu_multiplicative_expression(trie->left); }
if (trie->mul) { free_zebu_token(value->mul); value->mul = inc_zebu_token(trie->mul); }
if (trie->right) { free_zebu_prefix_expression(value->right); value->right = inc_zebu_prefix_expression(trie->right); }
free_zebu_multiplicative_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->mul), value->mul = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_multiplicative_expression(value->left), value->left = inc_zebu_multiplicative_expression(subgrammar);
free_zebu_multiplicative_expression(subgrammar);
}
d = value, g = 12;
break;
}
case 47:
{
struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_multiplicative_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->div) { free_zebu_token(value->div); value->div = inc_zebu_token(trie->div); }
if (trie->inner) { free_zebu_prefix_expression(value->inner); value->inner = inc_zebu_prefix_expression(trie->inner); }
if (trie->left) { free_zebu_multiplicative_expression(value->left); value->left = inc_zebu_multiplicative_expression(trie->left); }
if (trie->mul) { free_zebu_token(value->mul); value->mul = inc_zebu_token(trie->mul); }
if (trie->right) { free_zebu_prefix_expression(value->right); value->right = inc_zebu_prefix_expression(trie->right); }
free_zebu_multiplicative_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->div), value->div = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_multiplicative_expression(value->left), value->left = inc_zebu_multiplicative_expression(subgrammar);
free_zebu_multiplicative_expression(subgrammar);
}
d = value, g = 12;
break;
}
case 17:
{
struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_prefix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_prefix_expression(value->inner), value->inner = inc_zebu_prefix_expression(subgrammar);
free_zebu_prefix_expression(subgrammar);
}
d = value, g = 12;
break;
}
case 18:
{
struct zebu_postfix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_primary_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_primary_expression(value->inner), value->inner = inc_zebu_primary_expression(subgrammar);
free_zebu_primary_expression(subgrammar);
}
d = value, g = 13;
break;
}
case 24:
{
struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_prefix_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_postfix_expression(value->inner); value->inner = inc_zebu_postfix_expression(trie->inner); }
if (trie->neg) { free_zebu_token(value->neg); value->neg = inc_zebu_token(trie->neg); }
if (trie->pos) { free_zebu_token(value->pos); value->pos = inc_zebu_token(trie->pos); }
if (trie->sub) { free_zebu_prefix_expression(value->sub); value->sub = inc_zebu_prefix_expression(trie->sub); }
free_zebu_prefix_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->pos), value->pos = inc_zebu_token(token);
free_zebu_token(token);
}
d = value, g = 14;
break;
}
case 26:
{
struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_prefix_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_postfix_expression(value->inner); value->inner = inc_zebu_postfix_expression(trie->inner); }
if (trie->neg) { free_zebu_token(value->neg); value->neg = inc_zebu_token(trie->neg); }
if (trie->pos) { free_zebu_token(value->pos); value->pos = inc_zebu_token(trie->pos); }
if (trie->sub) { free_zebu_prefix_expression(value->sub); value->sub = inc_zebu_prefix_expression(trie->sub); }
free_zebu_prefix_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->neg), value->neg = inc_zebu_token(token);
free_zebu_token(token);
}
d = value, g = 14;
break;
}
case 16:
{
struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_postfix_expression(value->inner), value->inner = inc_zebu_postfix_expression(subgrammar);
free_zebu_postfix_expression(subgrammar);
}
d = value, g = 14;
break;
}
case 36:
{
struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(value->inner), value->inner = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 15;
break;
}
case 10:
{
struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->string), value->string = inc_zebu_token(token);
free_zebu_token(token);
}
d = value, g = 15;
break;
}
case 23:
{
struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->list), value->list = inc_zebu_token(token);
free_zebu_token(token);
}
d = value, g = 15;
break;
}
case 38:
{
struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_primary_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->elements.n)
{
while (value->elements.n + trie->elements.n > value->elements.cap)
{
value->elements.cap = value->elements.cap << 1 ?: 1;
value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
}
memmove(value->elements.data + trie->elements.n, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
for (unsigned i = 0, n = trie->elements.n; i < n; i++)
value->elements.data[i] = inc_zebu_expression(trie->elements.data[i]);
value->elements.n += trie->elements.n;
}
if (trie->inner) { free_zebu_expression(value->inner); value->inner = inc_zebu_expression(trie->inner); }
if (trie->integer) { free_zebu_token(value->integer); value->integer = inc_zebu_token(trie->integer); }
if (trie->list) { free_zebu_token(value->list); value->list = inc_zebu_token(trie->list); }
if (trie->string) { free_zebu_token(value->string); value->string = inc_zebu_token(trie->string); }
if (trie->variable) { free_zebu_token(value->variable); value->variable = inc_zebu_token(trie->variable); }
free_zebu_primary_expression(trie);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->elements.n == value->elements.cap)
{
value->elements.cap = value->elements.cap << 1 ?: 1;
value->elements.data = realloc(value->elements.data, sizeof(*value->elements.data) * value->elements.cap);
}
memmove(value->elements.data + 1, value->elements.data, sizeof(*value->elements.data) * value->elements.n);
value->elements.data[0] = inc_zebu_expression(subgrammar), value->elements.n++;
free_zebu_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->list), value->list = inc_zebu_token(token);
free_zebu_token(token);
}
d = value, g = 15;
break;
}
case 11:
{
struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->variable), value->variable = inc_zebu_token(token);
free_zebu_token(token);
}
d = value, g = 15;
break;
}
case 12:
{
struct zebu_primary_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->integer), value->integer = inc_zebu_token(token);
free_zebu_token(token);
}
d = value, g = 15;
break;
}
case 32:
{
struct zebu_recipe* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_recipe* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->commands) { free_zebu_commands(value->commands); value->commands = inc_zebu_commands(trie->commands); }
if (trie->dependencies.n)
{
while (value->dependencies.n + trie->dependencies.n > value->dependencies.cap)
{
value->dependencies.cap = value->dependencies.cap << 1 ?: 1;
value->dependencies.data = realloc(value->dependencies.data, sizeof(*value->dependencies.data) * value->dependencies.cap);
}
memmove(value->dependencies.data + trie->dependencies.n, value->dependencies.data, sizeof(*value->dependencies.data) * value->dependencies.n);
for (unsigned i = 0, n = trie->dependencies.n; i < n; i++)
value->dependencies.data[i] = inc_zebu_argument(trie->dependencies.data[i]);
value->dependencies.n += trie->dependencies.n;
}
if (trie->target) { free_zebu_argument(value->target); value->target = inc_zebu_argument(trie->target); }
free_zebu_recipe(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_argument* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_argument(value->target), value->target = inc_zebu_argument(subgrammar);
free_zebu_argument(subgrammar);
}
d = value, g = 6;
break;
}
case 13:
{
struct zebu_relational_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_additive_expression(value->inner), value->inner = inc_zebu_additive_expression(subgrammar);
free_zebu_additive_expression(subgrammar);
}
d = value, g = 16;
break;
}
case 48:
{
struct zebu_relational_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_relational_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->gt) { free_zebu_token(value->gt); value->gt = inc_zebu_token(trie->gt); }
if (trie->gte) { free_zebu_token(value->gte); value->gte = inc_zebu_token(trie->gte); }
if (trie->inner) { free_zebu_additive_expression(value->inner); value->inner = inc_zebu_additive_expression(trie->inner); }
if (trie->left) { free_zebu_relational_expression(value->left); value->left = inc_zebu_relational_expression(trie->left); }
if (trie->lt) { free_zebu_token(value->lt); value->lt = inc_zebu_token(trie->lt); }
if (trie->lte) { free_zebu_token(value->lte); value->lte = inc_zebu_token(trie->lte); }
if (trie->right) { free_zebu_additive_expression(value->right); value->right = inc_zebu_additive_expression(trie->right); }
free_zebu_relational_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->lt), value->lt = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_relational_expression(value->left), value->left = inc_zebu_relational_expression(subgrammar);
free_zebu_relational_expression(subgrammar);
}
d = value, g = 16;
break;
}
case 50:
{
struct zebu_relational_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_relational_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->gt) { free_zebu_token(value->gt); value->gt = inc_zebu_token(trie->gt); }
if (trie->gte) { free_zebu_token(value->gte); value->gte = inc_zebu_token(trie->gte); }
if (trie->inner) { free_zebu_additive_expression(value->inner); value->inner = inc_zebu_additive_expression(trie->inner); }
if (trie->left) { free_zebu_relational_expression(value->left); value->left = inc_zebu_relational_expression(trie->left); }
if (trie->lt) { free_zebu_token(value->lt); value->lt = inc_zebu_token(trie->lt); }
if (trie->lte) { free_zebu_token(value->lte); value->lte = inc_zebu_token(trie->lte); }
if (trie->right) { free_zebu_additive_expression(value->right); value->right = inc_zebu_additive_expression(trie->right); }
free_zebu_relational_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->gt), value->gt = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_relational_expression(value->left), value->left = inc_zebu_relational_expression(subgrammar);
free_zebu_relational_expression(subgrammar);
}
d = value, g = 16;
break;
}
case 51:
{
struct zebu_relational_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_relational_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->gt) { free_zebu_token(value->gt); value->gt = inc_zebu_token(trie->gt); }
if (trie->gte) { free_zebu_token(value->gte); value->gte = inc_zebu_token(trie->gte); }
if (trie->inner) { free_zebu_additive_expression(value->inner); value->inner = inc_zebu_additive_expression(trie->inner); }
if (trie->left) { free_zebu_relational_expression(value->left); value->left = inc_zebu_relational_expression(trie->left); }
if (trie->lt) { free_zebu_token(value->lt); value->lt = inc_zebu_token(trie->lt); }
if (trie->lte) { free_zebu_token(value->lte); value->lte = inc_zebu_token(trie->lte); }
if (trie->right) { free_zebu_additive_expression(value->right); value->right = inc_zebu_additive_expression(trie->right); }
free_zebu_relational_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->gte), value->gte = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_relational_expression(value->left), value->left = inc_zebu_relational_expression(subgrammar);
free_zebu_relational_expression(subgrammar);
}
d = value, g = 16;
break;
}
case 52:
{
struct zebu_relational_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_relational_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->gt) { free_zebu_token(value->gt); value->gt = inc_zebu_token(trie->gt); }
if (trie->gte) { free_zebu_token(value->gte); value->gte = inc_zebu_token(trie->gte); }
if (trie->inner) { free_zebu_additive_expression(value->inner); value->inner = inc_zebu_additive_expression(trie->inner); }
if (trie->left) { free_zebu_relational_expression(value->left); value->left = inc_zebu_relational_expression(trie->left); }
if (trie->lt) { free_zebu_token(value->lt); value->lt = inc_zebu_token(trie->lt); }
if (trie->lte) { free_zebu_token(value->lte); value->lte = inc_zebu_token(trie->lte); }
if (trie->right) { free_zebu_additive_expression(value->right); value->right = inc_zebu_additive_expression(trie->right); }
free_zebu_relational_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->lte), value->lte = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_relational_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_relational_expression(value->left), value->left = inc_zebu_relational_expression(subgrammar);
free_zebu_relational_expression(subgrammar);
}
d = value, g = 16;
break;
}
case 20:
{
struct zebu_root* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_root* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->statements.n)
{
while (value->statements.n + trie->statements.n > value->statements.cap)
{
value->statements.cap = value->statements.cap << 1 ?: 1;
value->statements.data = realloc(value->statements.data, sizeof(*value->statements.data) * value->statements.cap);
}
memmove(value->statements.data + trie->statements.n, value->statements.data, sizeof(*value->statements.data) * value->statements.n);
for (unsigned i = 0, n = trie->statements.n; i < n; i++)
value->statements.data[i] = inc_zebu_statement(trie->statements.data[i]);
value->statements.n += trie->statements.n;
}
free_zebu_root(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
d = value, g = 7;
break;
}
case 9:
{
struct zebu_root* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_statement* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->statements.n == value->statements.cap)
{
value->statements.cap = value->statements.cap << 1 ?: 1;
value->statements.data = realloc(value->statements.data, sizeof(*value->statements.data) * value->statements.cap);
}
memmove(value->statements.data + 1, value->statements.data, sizeof(*value->statements.data) * value->statements.n);
value->statements.data[0] = inc_zebu_statement(subgrammar), value->statements.n++;
free_zebu_statement(subgrammar);
}
d = value, g = 7;
break;
}
case 21:
{
struct zebu_root* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_root* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->statements.n)
{
while (value->statements.n + trie->statements.n > value->statements.cap)
{
value->statements.cap = value->statements.cap << 1 ?: 1;
value->statements.data = realloc(value->statements.data, sizeof(*value->statements.data) * value->statements.cap);
}
memmove(value->statements.data + trie->statements.n, value->statements.data, sizeof(*value->statements.data) * value->statements.n);
for (unsigned i = 0, n = trie->statements.n; i < n; i++)
value->statements.data[i] = inc_zebu_statement(trie->statements.data[i]);
value->statements.n += trie->statements.n;
}
free_zebu_root(trie);
}
{
struct zebu_statement* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->statements.n == value->statements.cap)
{
value->statements.cap = value->statements.cap << 1 ?: 1;
value->statements.data = realloc(value->statements.data, sizeof(*value->statements.data) * value->statements.cap);
}
memmove(value->statements.data + 1, value->statements.data, sizeof(*value->statements.data) * value->statements.n);
value->statements.data[0] = inc_zebu_statement(subgrammar), value->statements.n++;
free_zebu_statement(subgrammar);
}
d = value, g = 7;
break;
}
case 56:
{
struct zebu_simple_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_argument* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->args.n == value->args.cap)
{
value->args.cap = value->args.cap << 1 ?: 1;
value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
}
memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
value->args.data[0] = inc_zebu_argument(subgrammar), value->args.n++;
free_zebu_argument(subgrammar);
}
d = value, g = 29;
break;
}
case 68:
{
struct zebu_simple_command* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_simple_command* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->args.n)
{
while (value->args.n + trie->args.n > value->args.cap)
{
value->args.cap = value->args.cap << 1 ?: 1;
value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
}
memmove(value->args.data + trie->args.n, value->args.data, sizeof(*value->args.data) * value->args.n);
for (unsigned i = 0, n = trie->args.n; i < n; i++)
value->args.data[i] = inc_zebu_argument(trie->args.data[i]);
value->args.n += trie->args.n;
}
free_zebu_simple_command(trie);
}
{
struct zebu_argument* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->args.n == value->args.cap)
{
value->args.cap = value->args.cap << 1 ?: 1;
value->args.data = realloc(value->args.data, sizeof(*value->args.data) * value->args.cap);
}
memmove(value->args.data + 1, value->args.data, sizeof(*value->args.data) * value->args.n);
value->args.data[0] = inc_zebu_argument(subgrammar), value->args.n++;
free_zebu_argument(subgrammar);
}
d = value, g = 29;
break;
}
case 3:
{
struct zebu_statement* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_assignment* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_assignment(value->assignment), value->assignment = inc_zebu_assignment(subgrammar);
free_zebu_assignment(subgrammar);
}
d = value, g = 8;
break;
}
case 4:
{
struct zebu_statement* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_conditional* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_conditional(value->conditional), value->conditional = inc_zebu_conditional(subgrammar);
free_zebu_conditional(subgrammar);
}
d = value, g = 8;
break;
}
case 5:
{
struct zebu_statement* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_include* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_include(value->include), value->include = inc_zebu_include(subgrammar);
free_zebu_include(subgrammar);
}
d = value, g = 8;
break;
}
case 6:
{
struct zebu_statement* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_iterative* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_iterative(value->iterative), value->iterative = inc_zebu_iterative(subgrammar);
free_zebu_iterative(subgrammar);
}
d = value, g = 8;
break;
}
case 7:
{
struct zebu_statement* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
value->refcount = 1;
value->startline = -1;
value->endline = 0;
{
struct zebu_recipe* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_recipe(value->recipe), value->recipe = inc_zebu_recipe(subgrammar);
free_zebu_recipe(subgrammar);
}
d = value, g = 8;
break;
}
}
			
			if (g == 43)
			{
				free_zebu_token(td);
				yacc.n = 0, root = d;
			}
			else
			{
				y = yacc.data[yacc.n - 1];
				
				#ifdef ZEBU_DEBUG
				ddprintf("y = %u\n", y);
				#endif
				
				assert(y < N(zebu_gotos) && g < N(*zebu_gotos));
				
				s = zebu_gotos[y][g];
				
				#ifdef ZEBU_DEBUG
				ddprintf("s = %u\n", s);
				#endif
				
				y = s, push_state(y), push_data(d);
			}
		}
		else
		{
			struct zebu_token* token = td;
			
			fprintf(stderr, "zebu: unexpected token '%.*s'!\n", token->len, token->data);
			
			exit(1);
		}
	}
	
	#ifdef ZEBU_DEBUG
	print_zebu_$start(NULL, p_root, "start", root);
	#endif
	
	free(yacc.data);
	free(data.data);
	free(lexer.data);
	
	return root;
}

















